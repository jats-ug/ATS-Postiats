%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="dataviews">
#langeng("
#title("Dataviews as Linear Dataprops")
")
#langja("
#title("線形なデータ命題としてのデータ観 (dataview)")
")

#langeng("
#para("\

The at-views of the form #stacode("T@L") for types T and addresses L are
building blocks for constructing other forms of views. One mechanism for
putting together such building blocks is by declaring dataviews, which is
mostly identical to declaring dataprops. I now present in this chapter some
commonly encountered dataviews and their uses.

")
")
#langja("
#para("\

型 T とアドレス L について #stacode("T@L") をなす駐観 (at-view) は他の形の観をコンストラクトするブロックを形成します。
そのような形成されたブロックを一緒に配置するメカニズムはデータ観 (dataview) として宣言されます。
大部分においてそれはデータ命題 (dataprop) の宣言と同じです。
この章ではいくつかの一般なデータ観とその使い方を紹介します。

")
")

#langeng("
#para('\

Please find #mycodelink("CHAP_DATAVIEW/", "on-line") the code presented
for illustration in this chapter.

')
")
#langja("
#para('\

この章で解説するコードは
#mycodelink("CHAP_DATAVIEW/", "オンライン")
から入手できます。

')
")

<sect1
id="optional_views">
#langeng("
#title("Optional Views")
")
#langja("
#title("オプショナル観")
")

#langeng("
#para('\

The dataview #stacode("option_v") is declared as follows:

#atscode('\
dataview option_v (v:view+, bool) =
  | Some_v (v, true) of (v) | None_v (v, false) of ()
')

This declaration indicates that the dataview #stacode("option_v") is
covariant in its first argument and there are two proof constructors
associated with it: #dyncode("Some_v") and #dyncode("None_v").  Given a
view V, #stacode("option_v(V, b)") is often called an optional view, where
b is a boolean. Clearly, a proof of the view #dyncode("option_v(V, true)")
contains a proof of the view V while a proof the view #stacode("option_v(V,
false)") contains nothing.

')
")
#langja("
#para('\

データ観 #stacode("option_v") は次のように宣言されます:

#atscode('\
dataview option_v (v:view+, bool) =
  | Some_v (v, true) of (v) | None_v (v, false) of ()
')

この宣言はデータ観 #stacode("option_v") が1番目の引数に対して共変で、
関連する2つの証明コンストラクタ #dyncode("Some_v") と #dyncode("None_v") があることを示しています。
観 V が与えられ、b がブールの時、#stacode("option_v(V, b)") はしばしばオプショナル観 (optional view)
と呼ばれます。
明確に観 #dyncode("option_v(V, true)") の証明は観 V の証明を含んでいますが、観 #stacode("option_v(V, false)") の証明は何も含んでいません。

')
")

#langeng("
#para('\

As an example, the following function interface involves a typical use of
optional view:

#atscode('\
fun{a:t@ype}
ptr_alloc_opt (): [l:addr] (option_v (a? @ l, l > null) | ptr l)
')

Given a type T, the function #dyncode("ptr_alloc_opt&lt;T&gt;") returns a
pointer paired with a proof of an optional view; if the returned pointer is
not null, then the proof can be turned into a proof of the view
#stacode("T?@L"), where L is the location to which the pointer points;
otherwise, there is no at-view associated with the returned pointer.

')
")
#langja("
#para('\

例として、次の関数インターフェイスはオプショナル観の典型的な使用例です:

#atscode('\
fun{a:t@ype}
ptr_alloc_opt (): [l:addr] (option_v (a? @ l, l > null) | ptr l)
')

型 T が与えられた時、
関数 #dyncode("ptr_alloc_opt&lt;T&gt;") はオプショナル観の証明とポインタのペアを返します;
もし返されたポインタが NULL でなければ、
ポインタが指す場所 L についてその証明は観 #stacode("T?@L") の証明に成ることができます;
そうでなければ、返されたポインタに関連する駐観は含まれません。

')
")

</sect1>#comment("sect1/id=optional_views")

<sect1
id="disjunctive_views">
#langeng("
#title("Disjunctive Views")
")
#langja("
#title("選言的な観")
")

#langeng("
#para('\

The dataview #stacode("VOR") is declared as follows:

#atscode('\
dataview VOR (v0:view+, v1:view+, int) =
  | VORleft (v0, v1, 0) of (v0) | VORright (v0, v1, 1) of (v1)
')

This declaration indicates that the dataview #stacode("VOR") is covariant
in its first and second arguments and there are two proof constructors
associated with it: #dyncode("VORleft") and #dyncode("VORright"). Given
views V#sub("0") and V#sub("1"), a proof of #stacode("VOR(V#sub("0"),
V#sub("1"), 0)") can be turned into a proof of V#sub("0") and a proof of
#stacode("VOR(V#sub("0"), V#sub("1"), 1)") can be turned into a proof of
V#sub("1").

')
")
#langja("
#para('\

データ観 #stacode("VOR") は次のように宣言されています:

#atscode('\
dataview VOR (v0:view+, v1:view+, int) =
  | VORleft (v0, v1, 0) of (v0) | VORright (v0, v1, 1) of (v1)
')

この宣言はデータ観 #stacode("VOR") が1番目と2番目の引数について共変であることを示しています。
そして関連する2つの証明コンストラクタ #dyncode("VORleft") と #dyncode("VORright") があります。
観 V#sub("0") と V#sub("1") が与えられた時、
#stacode("VOR(V#sub("0"), V#sub("1"), 0)") の証明は V#sub("0") の証明になります。
また #stacode("VOR(V#sub("0"), V#sub("1"), 1)") の証明は V#sub("1") の証明になります。

')
")

#langeng("
#para('\

Let T be some type. The following function interface states that
#dyncode("getopt") takes an unintialized pointer and returns an integers
indicating whether the pointer is initialized:

#atscode('\
fun getopt{l:addr}
  (pf: T? @ l | ptr (l)): [i:int] (VOR (T? @ l, T @ l, i) | int (i))
')

The following code shows a typical use of #dyncode("getopt"):

#atscode('\
fun foo (): void = let
  var x: T?
  val (pfor | i) = getopt (view@(x) | addr@(x))
in
//
if i = 0
  then let
    prval VORleft (pf0) = pfor in view@(x) := pf0 // uninitialized
  end // end of [then]
  else let
    prval VORright (pf1) = pfor in view@(x) := pf1 // initialized
  end // end of [else]
// end of [if]
//
end // end of [foo]
')

')
")
#langja("
#para('\

なんらかの型 T を考えます。次の関数インターフェイスは #dyncode("getopt")
が未初期化のポインタを取り、ポインタが初期化されたかどうかを示す整数を返すことを表わしています:

#atscode('\
fun getopt{l:addr}
  (pf: T? @ l | ptr (l)): [i:int] (VOR (T? @ l, T @ l, i) | int (i))
')

次のコードは #dyncode("getopt") の典型的な使用例を示しています:

#atscode('\
fun foo (): void = let
  var x: T?
  val (pfor | i) = getopt (view@(x) | addr@(x))
in
//
if i = 0
  then let
    prval VORleft (pf0) = pfor in view@(x) := pf0 // uninitialized
  end // end of [then]
  else let
    prval VORright (pf1) = pfor in view@(x) := pf1 // initialized
  end // end of [else]
// end of [if]
//
end // end of [foo]
')

')
")

#langeng("
#para('\

In ATS, there is a type constructor #stacode("opt") that takes a type T and
a boolean B to form an opt-type #dyncode("opt(T, B)") such that
#dyncode("opt(T, B)") equals T if B is true and it equals T? if B is false.
The function #dyncode("getopt") can be given the following interface
that makes use of an opt-type:

#atscode('\
fun getopt (x: &T? >> opt (T, b)): #[b:bool] bool(b)
')

The code that calls #dyncode("getopt") can now be implemented as follows:

#atscode('\
fun foo (): void = let
  var x: T?
  val ans = getopt (x)
in
//
if (ans)
  then let
    prval () = opt_unsome(x) in (*initialized*)
  end // end of [then]
  else let
    prval () = opt_unnone(x) in (*uninitialized*)
  end // end of [else]
// end of [if]
//
end // end of [foo]
')

where the proof functions #dyncode("opt_unsome") and #dyncode("opt_unnone")
are assgined the following types:

#atscode('\
prfun opt_unsome{a:t@ype} (x: !opt (a, true) >> a): void
prfun opt_unnone{a:t@ype} (x: !opt (a, false) >> a?): void
')

Compared to the version that uses #stacode("VOR"), this version based on
opt-type is considerably less verbose.

')
")
#langja("
#para('\

ATS には、型 T とブール B を取り、opt 型 #dyncode("opt(T, B)") を作るような型コンストラクタ #stacode("opt")
があります。
このとき B が true ならば #dyncode("opt(T, B)") は T に等しく、B が false ならそれは T? に等しくなります。
関数 #dyncode("getopt") には次のような opt 型を使ったインターフェイスを与えることができます:

#atscode('\
fun getopt (x: &T? >> opt (T, b)): #[b:bool] bool(b)
')

これで #dyncode("getopt") 呼び出しコードは次のように実装できます:

#atscode('\
fun foo (): void = let
  var x: T?
  val ans = getopt (x)
in
//
if (ans)
  then let
    prval () = opt_unsome(x) in (*initialized*)
  end // end of [then]
  else let
    prval () = opt_unnone(x) in (*uninitialized*)
  end // end of [else]
// end of [if]
//
end // end of [foo]
')

このとき、証明関数 #dyncode("opt_unsome") と #dyncode("opt_unnone") には次の型が割り当てられています:

#atscode('\
prfun opt_unsome{a:t@ype} (x: !opt (a, true) >> a): void
prfun opt_unnone{a:t@ype} (x: !opt (a, false) >> a?): void
')

#stacode("VOR") を使うバージョンと比較して、
opt 型を用いたこのバージョンはかなりすっきりしています。

')
")

</sect1>#comment("sect1/id=disjunctive_views")

<sect1
id="linear_arrays">
#langeng("
#title("Dataview for Linear Arrays")
")
#langja("
#title("線形配列のデータ観")
")

#langeng("
#para('\

Unlike in most programming languages, arrays are not a primitive data
structure in ATS. More specifically, persistent arrays can be implemented
based on linear arrays, which allow for being freed safely by the
programmer, and linear arrays can be implemented based on
at-views. Intuitively, the view for an array storing N elements of type
T consists of N at-views: T@L#sub("0"), T@L#sub("1"), ..., and
T@L#sub("N-1"), where L#sub("0") is the starting address of the array and
each subsequent L equals the previous one plus the size of T, that is, the
number of bytes needed to store a value of the type T. The following
declared dataview #stacode("array_v") precisely captures this intuituion:

')
")
#langja("
#para('\

ほとんどのプログラミング言語と異なり、ATS では配列はプリミティブなデータ構造ではありません。
もっと正確に言えば、永続的な配列はプログラマが安全に解放できる線形配列を用いて実装できます。
その線形配列は駐観を用いて実装できます。
直観的には、N 個の駐観からなる 型 T の N 個の要素が保存されている配列の観:
T@L#sub("0"), T@L#sub("1"), ..., T@L#sub("N-1") です。
ここで、L#sub("0") は配列の開始アドレスで、L に続くそれぞれの要素は直前の要素に T
のサイズを加えたものと等しくなります。
すなわち、型 T の値を保存するのに必要なバイト数です。
次に宣言するデータ観 #stacode("array_v") はこの直感を正確に捕捉しています:

')
")

#atscode('\
dataview
array_v (
  a:t@ype+ // covariant argument
, addr(*beg*)
, int(*size*)
) = // array_v
  | {l:addr}
    array_v_nil (a, l, 0)
  | {l:addr}{n:nat}
    array_v_cons (a, l, n+1) of (a @ l, array_v (a, l+sizeof(a), n))
// end of [array_v]
')

#langeng("
#para('\

Given a type T, an address L and an integer N, #stacode("array_v(T, L, N)")
is a view for the array starting at L that stores N elements of the type T.
As can be readily expected, the function templates for array-accessing and
array-updating are given the following interfaces:

')
")
#langja("
#para('\

型 T, アドレス L, 整数 N が与えられた時、#stacode("array_v(T, L, N)")
は型 T の N 個の要素を保存する L からはじまる配列の観です。
すぐに予想できることですが、
配列をアクセスしたり更新する関数テンプレートは次のインターフェイスで与えられます:

')
")

#atscode('\
fun{
a:t@ype
} arrget{l:addr}{n,i:nat | i < n}
  (pf: !array_v (a, l, n) | p: ptr l, i: int i): a
// end of [arrget] // end of [fun]

fun{
a:t@ype
} arrset{l:addr}{n,i:nat | i < n}
  (pf: !array_v (a, l, n) | p: ptr l, i: int i, x: a): void
// end of [arrset] // end of [fun]
')

#langeng("
#para('\

Before implementing #dyncode("arrget") and #dyncode("arrset"), I present as
follows some code that implements a function template to access the first
element of a nonempty array:

')
")
#langja("
#para('\

#dyncode("arrget") と #dyncode("arrset")
を実装する前に、空でない配列の最初の要素にアクセスする関数テンプレートを実装する次のコードを紹介します:

')
")

#atscode('\
fun{
a:t@ype
} arrgetfst{l:addr}{n:pos}
(
  pf: !array_v (a, l, n) | p: ptr l
) : a = x where {
  prval array_v_cons (pf1, pf2) = pf
  // pf1: a @ l; pf2: array_v (a, l+sizeof(a), n-1)
  val x = !p
  prval () = pf := array_v_cons (pf1, pf2)
} // end of [arrgetfst]
')

#langeng("
#para('\

Obviously, the function template #dyncode("arrget") can be implemented
based on #dyncode("arrgetfst"):

')
")
#langja("
#para('\

明らかに、関数テンプレート #dyncode("arrget") は #dyncode("arrgetfst") を用いて実装することができます:

')
")

#atscode('\
implement
{a}(*tmp*)
arrget (pf | p, i) =
  if i > 0 then let
    prval array_v_cons (pf1, pf2) = pf
    val x = arrget (pf2 | ptr_succ<a> (p), i-1)
    prval () = pf := array_v_cons (pf1, pf2)
  in
    x
  end else
    arrgetfst (pf | p)
  // end of [if]
')

#langeng("
#para('\

This is a tail-recursive implementation of time-complexity O(n). However,
the very point of having arrays is to support O(1)-time accessing and
updating operations. My initial effort spent on implementing such
operations immediately dawned on me the need to construct proof functions
for supporting view-changes (of no run-time cost).

')
")
#langja("
#para('\

これは末尾再帰的な実装で時間的計算量は O(n) です。
けれども、配列の重要なメリットは O(1) の時間でアクセスと更新操作ができることにあります。
(実行時のコストなしに) 観の変更をサポートするような証明関数をコンストラクトする必要性に気づき、私は最初にそのような即時的な操作を実装することに注力しました。

')
")

#langeng("
#para('\

Clearly, an array starting at L that stores N elements of type T can also
be thought of as two arrays: one starting at L that stores I elements while
the other starting at L+I*sizeof(T) that stores N-I elements, where I is
an natural number less that or equal to N. Formally, this statement can be
encoded in the type of the proof function #dyncode("array_v_split"):

')
")
#langja("
#para('\

明確に、型 T の N 個の要素を保存する L から開始する配列は2つの方法で考えることができます:
一つは I 個の要素が L から保管されていると考える方法で、もう一つは N-I 個の要素が L+I*sizeof(T)
から保管されていると考える方法です。このとき I は N 以下の自然数です。
形式的には、この文は証明関数 #dyncode("array_v_split") の型にエンコードできます:

')
")

#atscode('\
prfun
array_v_split
  {a:t@ype}
  {l:addr}{n,i:nat | i <= n}
(
  pfarr: array_v (a, l, n)
) : (array_v (a, l, i), array_v (a, l+i*sizeof(a), n-i))
')

#langeng("
#para('\

The other direction of the above statement can be encoded in the type of
the proof function #dyncode("array_v_unsplit"):

')
")
#langja("
#para('\

上記の文のもう一方は証明関数 #dyncode("array_v_unsplit") の型にエンコードできます:

')
")

#atscode('\
prfun
array_v_unsplit
  {a:t@ype}
  {l:addr}{n1,n2:nat}
(
  pf1arr: array_v (a, l, n1), pf2arr: array_v (a, l+n1*sizeof(a), n2)
) : array_v (a, l, n1+n2)
')

#langeng("
#para('\

With #dyncode("array_v_split") and #dyncode("array_v_unsplit"), we can
readily give implementations of #dyncode("arrget") and #dyncode("arrset")
that are O(1)-time:

')
")
#langja("
#para('\

#dyncode("array_v_split") と #dyncode("array_v_unsplit") を使って、
O(1) 時間の #dyncode("arrget") と #dyncode("arrset") をたやすく実装することができます:

')
")

#atscode('\
implement
{a}(*tmp*)
arrget{l}{n,i}
  (pf | p, i) = x where {
  prval (pf1, pf2) = array_v_split{a}{l}{n,i}(pf)
  prval array_v_cons (pf21, pf22) = pf2
  val x = ptr_get1<a> (pf21 | ptr_add<a> (p, i))
  prval pf2 = array_v_cons (pf21, pf22)
  prval () = pf := array_v_unsplit{a}{l}{i,n-i}(pf1, pf2)
} (* end of [arrget] *)

implement
{a}(*tmp*)
arrset{l}{n,i}
  (pf | p, i, x) = () where {
  prval (pf1, pf2) = array_v_split{a}{l}{n,i}(pf)
  prval array_v_cons (pf21, pf22) = pf2
  val () = ptr_set1<a> (pf21 | ptr_add<a> (p, i), x)
  prval pf2 = array_v_cons (pf21, pf22)
  prval () = pf := array_v_unsplit{a}{l}{i,n-i}(pf1, pf2)
} (* end of [arrset] *)
')

#langeng("
#para('\

Of course, the proof functions #dyncode("array_v_split") and
#dyncode("array_v_split") are still to be implemented, which I will do when
covering the topic of view-change.

')
")
#langja("
#para('\

もちろん、証明関数 #dyncode("array_v_split") と #dyncode("array_v_split") はまだ実装されていません。
これは、観の変更に関するトピックを紹介するときに説明します。

')
")

#langeng("
#para('\

Given a type T, an address L and a natural number N, a proof of the view
#stacode("array_v(T?, L, N)") can be obtained and released by calling the
functions #dyncode("malloc") and #dyncode("free"), respectively, which are
to be explained in details elsewhere. I now give as follows an implemention
of a function template for array intialization:

')
")
#langja("
#para('\

型 T, アドレス L, 自然数 N が与えられた時、
観 #stacode("array_v(T?, L, N)") の証明は関数 #dyncode("malloc") と #dyncode("free")
をそれぞれ使って獲得と解放をすることができます。
これについては別の章で詳細を解説します。
ここで、次のような配列を初期化する関数テンプレートの実装を見てみましょう:

')
")

#atscode('\
typedef natLt (n:int) = [i:nat | i < n] int (i)

fun{a:t@ype}
array_ptr_tabulate
  {l:addr}{n:nat}
(
  pf: !array_v (a?,l,n) >> array_v (a,l,n)
| p: ptr (l), n: int (n), f: natLt(n) -<cloref1> a
) : void = let
  fun loop{l:addr}
    {i:nat | i <= n} .<n-i>.
  (
    pf: !array_v (a?,l,n-i) >> array_v (a,l,n-i)
  | p: ptr l, n: int n, f: natLt(n) -<cloref1> a, i: int i
  ) : void =
    if i < n then let
      prval array_v_cons (pf1, pf2) = pf
      val () = !p := f (i)
      val () = loop (pf2 | ptr_succ<a> (p), n, f, i+1)
    in
      pf := array_v_cons (pf1, pf2)
    end else let
      prval array_v_nil () = pf in pf := array_v_nil {a} ()
    end // end of [if]
  // end of [loop]
in
  loop (pf | p, n, f, 0)
end // end of [array_ptr_tabulate]
')

#langeng("
#para('\

Given a natural number n, the type #stacode("natLt(n)") is for all natural
numbers less than n. Given a type T, the function
#dyncode("array_ptr_tabulate&lt;T&gt;") takes a pointer to an uninitialized
array, the size of the array and a function f that maps each natural number
less than n to a value of the type T, and it initializes the array with the
sequence of values of f(0), f(1), ..., and f(n-1). In other words, the
array stores a tabulation of the given function f after the initialization
is over.

')
")
#langja("
#para('\

自然数 n が与えられた時、型 #stacode("natLt(n)") は n より小さい全ての自然数です。
型 T が与えられた時、関数 #dyncode("array_ptr_tabulate&lt;T&gt;") は未初期化配列へのポインタ、
その配列のサイズ、そして型 T の値に n より小さい自然数それぞれをマップする関数 f を取ります。
そしてこの関数は配列を f(0), f(1), ..., f(n-1) の値のシーケンスで初期化します。
言い方をかえると、初期化が終わるとこの配列は与えられた関数 f の表を保存していることになります。

')
")

#langeng("
#para('\

Given a type T and an integer N, @[T][N] is a built-in type in ATS for N
consecutive values of the type T. Therefore, the at-view @[T][N]@L for any
given address L is equivalent to the array-view #dyncode("array_v(T, L,
N)").  By making use of the feature of call-by-reference, we can also
assign the following interfaces to the previously presented functions
#dyncode("arrget") and #dyncode("arrset"):

#atscode('\
fun{
a:t@ype
} arrget {n,i:nat | i < n} (A: &(@[a][n]), i: int i): a

fun{
a:t@ype
} arrset {n,i:nat | i < n} (A: &(@[a][n]), i: int i, x: a): void
')

These interfaces are more concise as they obviate the need to mention
explicitly where the array argument is located.

')
")
#langja("
#para('\

型 T と自然数 N が与えられた時、@[T][N] は ATS のビルトイン型で 型 T の N 個連続した値を表わします。
したがって、与えられたアドレス L について駐観 @[T][N]@L は配列観 #dyncode("array_v(T, L, N)")
と等価です。
参照渡しの機能を使えば、以前示した関数 #dyncode("arrget") と #dyncode("arrset")
に次のインターフェイスを割り当てることができます:

#atscode('\
fun{
a:t@ype
} arrget {n,i:nat | i < n} (A: &(@[a][n]), i: int i): a

fun{
a:t@ype
} arrset {n,i:nat | i < n} (A: &(@[a][n]), i: int i, x: a): void
')

配列引数が配置された場所を明示的に示す必要がないので、これらのインターフェイスはより簡潔です。

')
")

#langeng("
#para("\

Please find the entirety of the above presented code
#mycodelink("CHAP_DATAVIEW/array.dats", "on-line").

")
")
#langja("
#para("\

上記で紹介したコードの全体は
#mycodelink("CHAP_DATAVIEW/array.dats", "オンライン")
から入手できます。

")
")

</sect1>#comment("sect1/id=linear_arrays")

<!-- ****** ****** -->

<sect1
id="linear_strings">
#langeng("
#title("Dataview for Linear Strings")
")
#langja("
#title("線形文字列のデータ観")
")

#langeng("
#para('\

The following dataview #stacode("strbuf_v") captures the notion of a
string in C, which consisits a sequence of non-null characters followed by the
null character:

#atscode('\
dataview
strbuf_v(addr, int) =
  | {l:addr}
    strbuf_v_nil(l, 0) of (char(0) @ l)
  | {l:addr}{n:nat}
    strbuf_v_cons(l, n+1) of (charNZ @ l, strbuf_v(l+sizeof(char), n))
')

Let us define a linear type #stacode("strptr") as follows:

#atscode('\
vtypedef strptr(l:addr, n:int) = (strbuf_v(l, n) | ptr(l))
')

Then a C-string of length N that is stored at location L can be assigned
the type #stacode("strptr(L, N)").

')#comment("para")
")
#langja("
#para('\

次のデータ観 #stacode("strbuf_v") はC言語文字列の概念を補足しています。C言語文字列は NULL 文字で終端する非 NULL 文字の列から成り立っています:

#atscode('\
dataview
strbuf_v(addr, int) =
  | {l:addr}
    strbuf_v_nil(l, 0) of (char(0) @ l)
  | {l:addr}{n:nat}
    strbuf_v_cons(l, n+1) of (charNZ @ l, strbuf_v(l+sizeof(char), n))
')

線形型 #stacode("strptr") を次のように定義してみましょう:

#atscode('\
vtypedef strptr(l:addr, n:int) = (strbuf_v(l, n) | ptr(l))
')

すると位置 L に保管された長さ N のC言語文字列には型 #stacode("strptr(L, N)") を割り当てることができます。

')#comment("para")
")

#langeng("
#para('\

Given a C-string, one can always access its first character; if the
character is null, then the C-string is empty; if it is not, then the
C-string is non-empty. The following implementation of
#dyncode("strptr_is_nil") precisely follows this simple way of testing
whether a C-string is empty or not:

#atscode('\
//
fun
strptr_is_nil
  {l:addr}{n:int}
(
  str: !strptr(l, n)
) : bool(n==0) = let
//
  prval
  (pf_at, fpf) =
    strbuf_v_getfst(str.0)
  // prval
  val c0 = !(str.1)
  prval () = str.0 := fpf(pf_at)
in
  iseqz(c0) // testing whether [c0] is null
end // end of [strptr_is_nil]
//
')

where the proof function #dyncode("strbuf_v_getfst")
is declared and implemented as follows:

#atscode('\
extern
prfun
strbuf_v_getfst
  {l:addr}{n:int}
(
  pf: strbuf_v(l, n)
) : [
  c:int | (c==0 && n==0) || (c != 0 && n > 0)
] (char(c) @ l, char(c) @ l -<lin,prf> strbuf_v(l, n))

(* ****** ****** *)

primplmnt
strbuf_v_getfst
  (pf) =
(
case+ pf of
| strbuf_v_nil(pf_at) => #[.. | (pf_at, llam(pf_at) => strbuf_v_nil(pf_at))]
| strbuf_v_cons(pf_at, pf2) => #[.. | (pf_at, llam(pf_at) => strbuf_v_cons(pf_at, pf2))]
)
')

')#comment("para")
")
#langja("
#para('\

C言語文字列が与えられたとき、その最初の文字には常にアクセスできます;
もしその文字が NULL であった場合、そのC言語文字列は空です;
もしその文字が NULL でなかった場合、そのC言語文字列は空ではありません。
#dyncode("strptr_is_nil") の次の実装は、C言語文字列が空か空でないかを判定するこの単純な方法を正確に実装しています:

#atscode('\
//
fun
strptr_is_nil
  {l:addr}{n:int}
(
  str: !strptr(l, n)
) : bool(n==0) = let
//
  prval
  (pf_at, fpf) =
    strbuf_v_getfst(str.0)
  // prval
  val c0 = !(str.1)
  prval () = str.0 := fpf(pf_at)
in
  iseqz(c0) // testing whether [c0] is null
end // end of [strptr_is_nil]
//
')

このとき、証明関数 #dyncode("strbuf_v_getfst") は次のように宣言され実装されます:

#atscode('\
extern
prfun
strbuf_v_getfst
  {l:addr}{n:int}
(
  pf: strbuf_v(l, n)
) : [
  c:int | (c==0 && n==0) || (c != 0 && n > 0)
] (char(c) @ l, char(c) @ l -<lin,prf> strbuf_v(l, n))

(* ****** ****** *)

primplmnt
strbuf_v_getfst
  (pf) =
(
case+ pf of
| strbuf_v_nil(pf_at) => #[.. | (pf_at, llam(pf_at) => strbuf_v_nil(pf_at))]
| strbuf_v_cons(pf_at, pf2) => #[.. | (pf_at, llam(pf_at) => strbuf_v_cons(pf_at, pf2))]
)
')

')#comment("para")
")

#langeng("
#para('\

The following implementation gives another example of handling the dataview
#stacode("strbuf_v"):

#atscode('\
fun
strptr_length
  {l:addr}{n:int}
(
  str: !strptr(l, n)
) : size_t(n) = let
//
fun
loop
{l:addr}
{i,j:int}
(
  pf: !strbuf_v(l, i)
| p0: ptr(l), j: size_t(j)
) : size_t(i+j) = let
//
prval
[c:int]
(pf_at, fpf) = strbuf_v_getfst(pf)
//
val c0 = !p0
//
prval ((*return*)) = pf := fpf(pf_at)
//
in
//
if
iseqz(c0)
then j
else res where
{
  prval
  strbuf_v_cons(pf_at, pf2) = pf
  val res = loop(pf2 | ptr_succ<char>(p0), succ(j))
  prval ((*folded*)) = pf := strbuf_v_cons(pf_at, pf2)
} (* end of [else] *)
//
end // end of [loop]
//
in
  loop(str.0 | str.1, i2sz(0))
end // end of [strptr_length]  
')

Clearly, the implemented function of #dyncode("strptr_length") computes the
length of a given C-string.

')#comment("para")
")
#langja("
#para('\

次の実装はデータ観 #stacode("strbuf_v") を扱う別の例です:

#atscode('\
fun
strptr_length
  {l:addr}{n:int}
(
  str: !strptr(l, n)
) : size_t(n) = let
//
fun
loop
{l:addr}
{i,j:int}
(
  pf: !strbuf_v(l, i)
| p0: ptr(l), j: size_t(j)
) : size_t(i+j) = let
//
prval
[c:int]
(pf_at, fpf) = strbuf_v_getfst(pf)
//
val c0 = !p0
//
prval ((*return*)) = pf := fpf(pf_at)
//
in
//
if
iseqz(c0)
then j
else res where
{
  prval
  strbuf_v_cons(pf_at, pf2) = pf
  val res = loop(pf2 | ptr_succ<char>(p0), succ(j))
  prval ((*folded*)) = pf := strbuf_v_cons(pf_at, pf2)
} (* end of [else] *)
//
end // end of [loop]
//
in
  loop(str.0 | str.1, i2sz(0))
end // end of [strptr_length]  
')

明確に、実装された関数 #dyncode("strptr_length") は与えられたC言語文字列の長さを計算します。

')#comment("para")
")

#langeng("
#para('\

Please find the entirety of the above presented code
#mycodelink("CHAP_DATAVIEW/strbuf.dats", "on-line").

')#comment("para")
")
#langja("
#para('\

上記で示したコード全体は #mycodelink("CHAP_DATAVIEW/strbuf.dats", "オンライン") から入手できます。

')#comment("para")
")

</sect1>#comment("sect1/id=linear_strings")

<!-- ****** ****** -->

<sect1
id="singly-linked_lists">
#langeng("
#title("Dataview for Singly-Linked Lists")
")
#langja("
#title("片方向リストのデータ観")
")

#langeng("
#para('\

The following dataview #stacode("slseg_v") captures the notion of a
singly-linked list segment:\

#atscode('\
dataview
slseg_v (
  a:t@ype+ // covariant argument
, addr(*beg*)
, addr(*end*)
, int(*length*)
) = // slseg_v
  | {l:addr}
    slseg_v_nil (a, l, l, 0) of ()
  | {l_fst:agz}{l_nxt,l_end:addr}{n:nat}
    slseg_v_cons (a, l_fst, l_end, n+1) of
      ((a, ptr l_nxt) @ l_fst, slseg_v (a, l_nxt, l_end, n))
// end of [slseg]_v
')

There are two proof constructors #dyncode("slseg_v_nil") and
#dyncode("slseg_v_cons") associated with #stacode("slseg_v"), which are
assigned the following types:

#atscode('\
slseg_v_nil :
  {a:t@ype}{l:addr} () -> slseg_v (a, l, l, 0)
slseg_v_cons :
  {a:t@ype}{l_fst:agz}{l_nxt,l_end:addr}{n:nat}
  ((a, ptr l_nxt) @ l_fst, slseg_v (a, l_nxt, l_end, n)) -> slseg_v (a, l_fst, l_end, n+1)
')

')#comment("para")
")
#langja("
#para('\

次のデータ観 #stacode("slseg_v") は片方向リストの部分の概念を捕捉しています:

#atscode('\
dataview
slseg_v (
  a:t@ype+ // covariant argument
, addr(*beg*)
, addr(*end*)
, int(*len*)
) =
  | {l:addr}
    slseg_v_nil (a, l, l, 0) of ()
  | {l_fst:agz}{l_nxt,l_end:addr}{n:nat}
    slseg_v_cons (a, l_fst, l_end, n+1) of
      ((a, ptr l_nxt) @ l_fst, slseg_v (a, l_nxt, l_end, n))
// end of [slseg]_v
')

#stacode("slseg_v") に関連する2つの証明コンストラクタ #dyncode("slseg_v_nil") と #dyncode("slseg_v_cons")
があり、それらに割り当てられた型は次のようになります:

#atscode('\
slseg_v_nil :
  {a:t@ype}{l:addr} () -> slseg_v (a, l, l, 0)
slseg_v_cons :
  {a:t@ype}{l_fst:agz}{l_nxt,l_end:addr}{n:nat}
  ((a, ptr l_nxt) @ l_fst, slseg_v (a, l_nxt, l_end, n)) -> slseg_v (a, l_fst, l_end, n+1)
')

')#comment("para")

#langeng("
#para('\

Note that #stacode("agz") is a subset sort for addresses that are not null.
Given a type T, two addresses L1 and L2, and a natural number N, the view
#stacode("slseg_v(T, L1, L2, N)") is for a singly-linked list segment
containing N elements of the type T that starts at L1 and finishes at L2.
In the case where L2 is the null pointer, then the list segment is considered
a list as is formally defined below:

#atscode('\
viewdef slist_v
  (a:t@ype, l:addr, n:int) = slseg_v (a, l, null, n)
// end of [slist_v]
')

')#comment("para")
")
#langja("
#para('\

#stacode("agz") は NULL ではないアドレスのサブセット種であることに注意してください。
型 T, 2つのアドレス L1 と L2, 自然数 N が与えられた時、観 #stacode("slseg_v(T, L1, L2, N)") は L1 からはじまり L2 で終わるような型 T の N
個の要素を含む片方向リストの部分を表わします。
L2 が NULL ポインタである場合、このリスト部分は次に形式的に定義されるリストと考えられます:

#atscode('\
viewdef slist_v
  (a:t@ype, l:addr, n:int) = slseg_v (a, l, null, n)
// end of [slist_v]
')

')#comment("para")
")

#langeng("
#para('\

Given a type T, a pointer pointing to L plus a proof of the view
#stacode("slist_v(T, L, N)") for some natural number N is essentially the
same as a pointer to a struct of the following declared type
#stacode("slist_struct") in C:

#atscode('\
typedef
struct slist {
  T data ; /* [T] matches the corresponding type in ATS */
  struct slist *next ; /* pointing to the tail of the list */
} slist_struct ;
')

')#comment("para")
")
#langja("
#para('\

型 T が与えられた時、L を指すポインタと自然数 N について観 #stacode("slist_v(T, L, N)") の証明は、C言語において次に宣言された構造体型 #stacode("slist_struct") へのポインタと本質的に同じです:

#atscode('\
typedef
struct slist {
  T data ; /* [T] matches the corresponding type in ATS */
  struct slist *next ; /* pointing to the tail of the list */
} slist_struct ;
')

')#comment("para")
")

#langeng("
#para('\

Let us now see a simple example involving singly-linked lists:

#atscode('\
fn{a:t@ype}
slist_ptr_length
  {l:addr}{n:nat}
(
  pflst: !slist_v (a, l, n) | p: ptr l
) : int (n) = let
  fun loop
    {l:addr}{i,j:nat} .<i>.
  (
    pflst: !slist_v (a, l, i) | p: ptr l, j: int (j)
  ) : int (i+j) =
    if p > 0 then let
      prval slseg_v_cons (pfat, pf1lst) = pflst
      val res = loop (pf1lst | !p.1, j+1) // !p.1 points to the tail
      prval () = pflst := slseg_v_cons (pfat, pf1lst)
    in
      res
    end else let // the length of a null list is 0
      prval slseg_v_nil () = pflst in pflst := slseg_v_nil (); j
    end (* end of [if] *)
  // end of [loop]
in
  loop (pflst | p, 0)
end // end of [slist_ptr_length]
')

The function template #dyncode("slist_ptr_length") computes the length of a
given singly-linked list. Note that the inner function #dyncode("loop") is
tail-recursive. The above implementation of #dyncode("slist_ptr_length")
essentially corresponds to the following implementation in C:

#atscode('\
int slist_ptr_length (slist_struct *p) {
  int res = 0 ;
  while (p != NULL) { res = res + 1 ; p = p->next ; }
  return res ;
} // end of [slist_ptr_length]
')

')#comment("para")
")
#langja("
#para('\

ここで片方向リストを使った単純な例を見てみましょう:

#atscode('\
fn{a:t@ype}
slist_ptr_length
  {l:addr}{n:nat}
(
  pflst: !slist_v (a, l, n) | p: ptr l
) : int (n) = let
  fun loop
    {l:addr}{i,j:nat} .<i>.
  (
    pflst: !slist_v (a, l, i) | p: ptr l, j: int (j)
  ) : int (i+j) =
    if p > 0 then let
      prval slseg_v_cons (pfat, pf1lst) = pflst
      val res = loop (pf1lst | !p.1, j+1) // !p.1 points to the tail
      prval () = pflst := slseg_v_cons (pfat, pf1lst)
    in
      res
    end else let // the length of a null list is 0
      prval slseg_v_nil () = pflst in pflst := slseg_v_nil (); j
    end (* end of [if] *)
  // end of [loop]
in
  loop (pflst | p, 0)
end // end of [slist_ptr_length]
')

関数テンプレート #dyncode("slist_ptr_length") は与えられた片方向リストの長さを計算します。
内部の関数 #dyncode("loop") が末尾再帰であることに注意してください。
#dyncode("slist_ptr_length") の上記の実装はC言語における次の実装と本質的に一致します:

#atscode('\
int slist_ptr_length (slist_struct *p) {
  int res = 0 ;
  while (p != NULL) { res = res + 1 ; p = p->next ; }
  return res ;
} // end of [slist_ptr_length]
')

')#comment("para")
")

#langeng("
#para('\

As another example, the following function template
#dyncode("slist_ptr_reverse") turns a given linked list into its reverse:

#atscode('\
fn{a:t@ype}
slist_ptr_reverse
  {l:addr}{n:nat}
(
  pflst: slist_v (a, l, n) | p: ptr l
) : [l:addr] (slist_v (a, l, n) | ptr l) = let
  fun loop
    {n1,n2:nat}
    {l1,l2:addr} .<n1>. (
    pf1lst: slist_v (a, l1, n1)
  , pf2lst: slist_v (a, l2, n2)
  | p1: ptr l1, p2: ptr l2
  ) : [l:addr] (slist_v (a, l, n1+n2) | ptr l) =
    if p1 > 0 then let
      prval slseg_v_cons (pf1at, pf1lst) = pf1lst
      val p1_nxt = !p1.1
      val () = !p1.1 := p2
    in
      loop (pf1lst, slseg_v_cons (pf1at, pf2lst) | p1_nxt, p1)
    end else let
      prval slseg_v_nil () = pf1lst in (pf2lst | p2)
    end // end of [if]
in
  loop (pflst, slseg_v_nil | p, the_null_ptr)
end // end of [slist_ptr_reverse]
')

By translating the tail-recursive function #dyncode("loop") into a
while-loop, we can readily turn the implementation of
#dyncode("slist_ptr_reverse") in ATS into the following implementation in
C:

#atscode('\
slist_struct*
slist_ptr_reverse (slist_struct *p)
{
  slist_struct *tmp, *res = NULL ;
  while (p != NULL) {
    tmp = p->next ; p->next = res ; res = p ; p = tmp ;
  }
  return res ;
} // end of [slist_ptr_reverse]
')

')#comment("para")
")
#langja("
#para('\

もう一つの例として、次の関数テンプレート #dyncode("slist_ptr_reverse") は与えられた連結リストを逆順にします:

#atscode('\
fn{a:t@ype}
slist_ptr_reverse
  {l:addr}{n:nat}
(
  pflst: slist_v (a, l, n) | p: ptr l
) : [l:addr] (slist_v (a, l, n) | ptr l) = let
  fun loop
    {n1,n2:nat}
    {l1,l2:addr} .<n1>. (
    pf1lst: slist_v (a, l1, n1)
  , pf2lst: slist_v (a, l2, n2)
  | p1: ptr l1, p2: ptr l2
  ) : [l:addr] (slist_v (a, l, n1+n2) | ptr l) =
    if p1 > 0 then let
      prval slseg_v_cons (pf1at, pf1lst) = pf1lst
      val p1_nxt = !p1.1
      val () = !p1.1 := p2
    in
      loop (pf1lst, slseg_v_cons (pf1at, pf2lst) | p1_nxt, p1)
    end else let
      prval slseg_v_nil () = pf1lst in (pf2lst | p2)
    end // end of [if]
in
  loop (pflst, slseg_v_nil | p, the_null_ptr)
end // end of [slist_ptr_reverse]
')

末尾再帰関数 #dyncode("loop") を while ループに翻訳すれば、ATS における #dyncode("slist_ptr_reverse")
の実装を次のようなC言語の実装にたやすく変換できるでしょう:

#atscode('\
slist_struct*
slist_ptr_reverse (slist_struct *p)
{
  slist_struct *tmp, *res = NULL ;
  while (p != NULL) {
    tmp = p->next ; p->next = res ; res = p ; p = tmp ;
  }
  return res ;
} // end of [slist_ptr_reverse]
')

')#comment("para")
")

#langeng("
#para('\

Let us see yet another example.
List concatenation is a common operation on lists. This time, we first give
an implementation of list concatenation in C:

#atscode('\
slist_struct*
slist_ptr_append
  (slist_struct *p, slist_struct *q) {
  slist_struct *p1 = p ;
  if (p1 == NULL) return q ;
  while (p1->next != NULL) p1 = p1->next ; p1->next = q ;
  return p ;
} // end of [slist_ptr_append]
')

The algorithm is straightforward. If #dyncode("p") is null, then
#dyncode("q") is returned. Otherwise, the last node in the list pointed to
by #dyncode("p") is first found and its field of the name #dyncode("next")
then replaced with #dyncode("q").  This implementation of
#dyncode("slist_ptr_append") in C can be translated directly into to
the following one in ATS:

#atscode('\
fn{a:t@ype}
slist_ptr_append
  {l1,l2:addr}{n1,n2:nat}
(
  pf1lst: slist_v (a, l1, n1)
, pf2lst: slist_v (a, l2, n2)
| p1: ptr l1, p2: ptr l2
) : [l:addr] (slist_v (a, l, n1+n2) | ptr l) = let
  fun loop
    {n1,n2:nat}
    {l1,l2:addr | l1 > null} .<n1>. (
    pf1lst: slist_v (a, l1, n1)
  , pf2lst: slist_v (a, l2, n2)
  | p1: ptr l1, p2: ptr l2
  ) : (slist_v (a, l1, n1+n2) | void) = let
    prval slseg_v_cons (pf1at, pf1lst) = pf1lst
    val p1_nxt = !p1.1
  in
    if p1_nxt > 0 then let
      val (pflst | ()) = loop (pf1lst, pf2lst | p1_nxt, p2)
    in
      (slseg_v_cons (pf1at, pflst) | ())
    end else let
      val () = !p1.1 := p2
      prval slseg_v_nil () = pf1lst
    in
      (slseg_v_cons (pf1at, pf2lst) | ())
    end (* end of [if] *)
  end // end of [loop]
in
  if p1 > 0 then let
    val (pflst | ()) = loop (pf1lst, pf2lst | p1, p2)
  in
    (pflst | p1)
  end else let
    prval slseg_v_nil () = pf1lst in (pf2lst | p2)
  end (* end of [if] *)
end // end of [slist_ptr_append]
')

')#comment("para")
")
#langja("
#para('\

また別の例を見てみましょう。
様々なリストにおいてリストの連結は共通した操作です。
ここで、まずはじめにC言語でリストの連結を実装してみましょう:

#atscode('\
slist_struct*
slist_ptr_append
  (slist_struct *p, slist_struct *q) {
  slist_struct *p1 = p ;
  if (p1 == NULL) return q ;
  while (p1->next != NULL) p1 = p1->next ; p1->next = q ;
  return p ;
} // end of [slist_ptr_append]
')

素直なアルゴリズムです。
もし #dyncode("p") が NULL だった場合、#dyncode("q") が返されます。
そうでなければ、はじめに #dyncode("p") で指し示されたリストの最後のノードを見つけて、
そのノードの #dyncode("next") フィールドは #dyncode("q") に置換されます。
C言語における #dyncode("slist_ptr_append") のこの実装は、次のような ATS の実装に直接変換できます:

#atscode('\
fn{a:t@ype}
slist_ptr_append
  {l1,l2:addr}{n1,n2:nat}
(
  pf1lst: slist_v (a, l1, n1)
, pf2lst: slist_v (a, l2, n2)
| p1: ptr l1, p2: ptr l2
) : [l:addr] (slist_v (a, l, n1+n2) | ptr l) = let
  fun loop
    {n1,n2:nat}
    {l1,l2:addr | l1 > null} .<n1>. (
    pf1lst: slist_v (a, l1, n1)
  , pf2lst: slist_v (a, l2, n2)
  | p1: ptr l1, p2: ptr l2
  ) : (slist_v (a, l1, n1+n2) | void) = let
    prval slseg_v_cons (pf1at, pf1lst) = pf1lst
    val p1_nxt = !p1.1
  in
    if p1_nxt > 0 then let
      val (pflst | ()) = loop (pf1lst, pf2lst | p1_nxt, p2)
    in
      (slseg_v_cons (pf1at, pflst) | ())
    end else let
      val () = !p1.1 := p2
      prval slseg_v_nil () = pf1lst
    in
      (slseg_v_cons (pf1at, pf2lst) | ())
    end (* end of [if] *)
  end // end of [loop]
in
  if p1 > 0 then let
    val (pflst | ()) = loop (pf1lst, pf2lst | p1, p2)
  in
    (pflst | p1)
  end else let
    prval slseg_v_nil () = pf1lst in (pf2lst | p2)
  end (* end of [if] *)
end // end of [slist_ptr_append]
')

')#comment("para")
")

#langeng("
#para('\

In the above examples, it is evident that the code in ATS is a lot more
verbose than its counterpart in C. However, the former is also a lot more
robust than the latter in the following sense: If a minor change is made to
the code in ATS (e.g., renaming identifiers, reordering function
arguments), it is most likely that a type-error is to be reported when the
changed code is typechecked. On the other hand, the same thing cannot be
said about the code written in C. For instance, the following erroneous
implementation of #dyncode("slist_ptr_reverse") in C is certainly
type-correct:

#atscode('\
/*
** This implementation is *incorrect* but type-correct:
*/
slist_struct*
slist_ptr_reverse
  (slist_struct *p)
{
  slist_struct *tmp, *res = NULL ;
  while (p != NULL) {
    tmp = p->next ; res = p ; p->next = res ; p = tmp ;
  }
  return res ;
} // end of [slist_ptr_reverse]
')

')#comment("para")
")
#langja("
#para('\

上記の例では、ATS のコードがC言語の該当するコードよりも冗長であることは明らかです。
けれども、前者は後者よりも次の点でより堅牢です:
もし ATS のコードに小さな変更 (例: 識別子の名前変更、関数の引数の並べ替え) を加えた場合、
変更したコードは型検査されておそらく型エラーが発生します。
他方、C言語で書かれたコードについては同じことは起きません。
例えば、次のようなC言語における #dyncode("slist_ptr_reverse") の誤った実装はもちろん正しい型です:

#atscode('\
/*
** This implementation is *incorrect* but type-correct:
*/
slist_struct*
slist_ptr_reverse
  (slist_struct *p)
{
  slist_struct *tmp, *res = NULL ;
  while (p != NULL) {
    tmp = p->next ; res = p ; p->next = res ; p = tmp ;
  }
  return res ;
} // end of [slist_ptr_reverse]
')

')#comment("para")
")

#langeng("
#para('\

I now point out that the dataview #stacode("slseg_v") is declared here in a
manner that does not address the issue of allocating and freeing list
nodes, and it is done so for the sake of a less involved presentation. A
dataview for singly-linked lists that does handle allocation and
deallocation of list nodes can also be declared in ATS, but there is really
little need for it as we can declare a dataviewtype for such lists that is
far more convenient to use.  However, dataviews are fundamentally more
general and flexible than dataviewtypes, and there are many common data
structures (e.g. doubly-linked lists) that can only be properly handled
with dataviews in ATS.

')#comment("para")
")
#langja("
#para('\

ここで宣言したデータ観 #stacode("slseg_v")
はリストのノードを確保/解放する問題に対処していないことを指摘しておこうと思います。
これは複雑な表現を避けることを意図しています。
確保と解放を扱うような片方向リストのデータ観もまた ATS で宣言することができます。
しかしデータ観型 (dataviewtype) で宣言することでそのようなリストをより使い易くすることができます。
けれども、データ観は根本的にデータ観型よりも一般的で柔軟です。
多くの一般的なデータ構造 (例: 双方向リスト) は ATS においてデータ観を用いてのみ適切に取り扱うことができます。

')#comment("para")
")

</sect1>#comment("sect1/id=singly-linked_lists")

<!-- ****** ****** -->

<sect1 id=""view-changes">
#langeng("
#title("Proof Functions for View-Changes")
")
#langja("
#title("観変化のための証明関数")
")

#langeng("
#para("\

By the phrase #emphasis("view-change"), I mean applying a function to
proofs of a set of views to turn them into proofs of another set of views.
As this function itself is a proof function, there is no run-time cost
associated with each view-change. For instance, a proof of the at-view
int32@L for any address L can be turned into a proof of a tuple of 4
at-views: int8@L, int8@L+1, int8@L+2 and int8@L+3, where int32 and int8 are
types for 32-bit and 8-bit integers, respectively. Often more interesting
view-changes involve recursively defined proof functions, and I present
several of such cases in the rest of this section.

")
")
#langja("
#para("\

#emphasis("観変化 (view-change)") という言いまわしは、関数を一連の観の証明に適用してそれらを別の観の証明に変換することを意味しています。
この関数自身も証明関数なので、観変化それぞれに関連する実行時のコストはありません。
例えば、どこかのアドレス L について駐観 int32@L の証明は4つの駐観: int8@L, int8@L+1, int8@L+2, int8@L+3
からなるタプルに変化できます。
このとき int32 と int8 はそれぞれ32ビットと8ビット整数の型です。
より興味深い観変化が証明関数としてそれぞれ定義されています。
この章の残りではそのようないくつかの例を紹介します。

")
")

#langeng("
#para("\

When implementing an array subscripting operation of O(1)-time, we need a
proof function to change the view of one array into the views of two
adjacently located arrays and another proof function to do precisely the
opposite. Formally speaking, we need to construct the following two proof
functions #dyncode("array_v_split") and #dyncode("array_v_unsplit"):

")
")
#langja("
#para("\

配列の添字操作を O(1) 時間で実装するには、1つの配列の観を2つの隣接した配列の観に変換する証明関数と、その逆の変換を行なう別の証明関数が必要です。
形式的に言うと、次の2つの証明関数 #dyncode("array_v_split") と #dyncode("array_v_unsplit")
を作る必要があるのです:

")
")

#atscode('\
prfun
array_v_split
  {a:t@ype}
  {l:addr}{n,i:nat | i <= n}
(
  pfarr: array_v (a, l, n)
) : (array_v (a, i, l), array_v (a, n-i, l+i*sizeof(a)))

prfun
array_v_unsplit
  {a:t@ype}
  {l:addr}{n1,n2:nat}
(
  pf1arr: array_v (a, l, n1), pf2arr: array_v (a, l+n1*sizeof(a), n2)
) : array_v (a, l, n1+n2)
')

#langeng("
#para('\

An implementation of #dyncode("array_v_split") is given as follows:

')
")
#langja("
#para('\

#dyncode("array_v_split") の実装は次のように与えられます:

')
")

#atscode('\
primplmnt
array_v_split
  {a}{l}{n,i}(pfarr) = let
  prfun split
    {l:addr}{n,i:nat | i <= n} .<i>.
  (
    pfarr: array_v (a, l, n)
  ) : (
    array_v (a, l, i)
  , array_v (a, l+i*sizeof(a), n-i)
  ) =
    sif i > 0 then let
      prval array_v_cons (pf1, pf2arr) = pfarr
      prval (pf1res1, pf1res2) = split{..}{n-1,i-1} (pf2arr)
    in
      (array_v_cons (pf1, pf1res1), pf1res2)
    end else let
      prval EQINT () = eqint_make{i,0}((*void*))
    in
      (array_v_nil (), pfarr)
    end // end of [sif]
in
  split (pfarr)
end // end of [array_v_split]
')

#langeng("
#para('\

Note that the keyword #keycode("primplmnt") (instead of
#keycode("implement")) should be used for implementing proof functions.
One can also choose to use the keyword #keycode("primplement") in place of
#keycode("primplmnt"). Clearly, the proof function #dyncode("split")
directly encodes a proof based on mathematical induction. Following is an
implementation of #dyncode("array_v_unsplit"):

#atscode('\
primplmnt
array_v_unsplit
  {a}{l}{n1,n2}
  (pf1arr, pf2arr) = let
  prfun unsplit
    {l:addr}{n1,n2:nat} .<n1>.
  (
    pf1arr: array_v (a, l, n1)
  , pf2arr: array_v (a, l+n1*sizeof(a), n2)
  ) : array_v (a, l, n1+n2) =
    sif n1 > 0 then let
      prval
      array_v_cons (pf1, pf1arr) = pf1arr
      prval pfres = unsplit (pf1arr, pf2arr)
    in
      array_v_cons (pf1, pfres)
    end else let
      prval array_v_nil () = pf1arr in pf2arr
    end // end of [sif]
in
  unsplit (pf1arr, pf2arr)
end // end of [array_v_unsplit]
')

The proof function #dyncode("unsplit") also directly encodes a proof based on
mathematical induction.

')
")
#langja("
#para('\

(#dyncode("implement") の代わりに) キーワード #dyncode("primplement")
は証明関数の実装に使われることに注意してください。
明確に、証明関数 #dyncode("split") は数学的帰納法を使って証明を直接エンコードしています。
#dyncode("array_v_unsplit") の実装を次に示します:

#atscode('\
primplement
array_v_unsplit
  {a}{l}{n1,n2}
  (pf1arr, pf2arr) = let
  prfun unsplit
    {l:addr}{n1,n2:nat} .<n1>.
  (
    pf1arr: array_v (a, l, n1)
  , pf2arr: array_v (a, l+n1*sizeof(a), n2)
  ) : array_v (a, l, n1+n2) =
    sif n1 > 0 then let
      prval
      array_v_cons (pf1, pf1arr) = pf1arr
      prval pfres = unsplit (pf1arr, pf2arr)
    in
      array_v_cons (pf1, pfres)
    end else let
      prval array_v_nil () = pf1arr in pf2arr
    end // end of [sif]
in
  unsplit (pf1arr, pf2arr)
end // end of [array_v_unsplit]
')

証明関数 #dyncode("unsplit") もまた数学的帰納法を用いて証明を直接エンコードしています。

')
")

#langeng("
#para('\

Let us now see an even more interesting proof function for performing
view-change.  The interface of the proof function #dyncode("array_v_takeout")
is given as follows:

')
")
#langja("
#para('\

ここで観変化を行なうより興味深い証明関数を見てみましょう。
証明関数 #dyncode("array_v_takeout") のインターフェイスは次のように与えられます:

')
")

#atscode('\
prfun
array_v_takeout
  {a:t@ype}
  {l:addr}{n,i:nat | i < n}
(
  pfarr: array_v (a, l, n)
) : (a @ l+i*sizeof(a), a @ l+i*sizeof(a) -<lin,prf> array_v (a, l, n))
')

#langeng("
#para('\

Note that the following type is for a linear proof function that takes a
proof of an at-view to return a proof of an array-view:

#atscode('\
a @ l+i*sizeof(a) -<lin,prf> array_v (a, l, n)
')

As such a function essentially represents an array with one missing cell,
we may simply say that #dyncode("array_v_takeout") turns the view of an
array into an at-view (for one cell) and a view for the rest of the array.
By making use of #dyncode("array_v_takeout"), we can give another
implementation of #dyncode("arrget"):

#atscode('\
implement
{a}(*tmp*)
arrget{l}{n,i}
  (pf | p, i) = x where {
  prval (pf1, fpf2) =
  array_v_takeout{a}{l}{n,i} (pf)
  val x = ptr_get1<a> (pf1 | ptr_add<a> (p, i))
  prval () = pf := fpf2 (pf1) // putting the cell and the rest together
} (* end of [arrget] *)
')

')
")
#langja("
#para('\

次の型は、駐観の証明を取り配列観の証明を返すような線形証明関数を表わすことに注意してください:

#atscode('\
a @ l+i*sizeof(a) -<lin,prf> array_v (a, l, n)
')

そのような関数は1つ要素が欠けた配列を本質的に表わし、単純に
#dyncode("array_v_takeout") は配列の観を (1つの要素に対する) 駐観と配列の残りを表わす観に変更すると、表現することができます。
#dyncode("array_v_takeout") を使うことで、#dyncode("arrget") に別の実装を与えることができます:

#atscode('\
implement{a}
arrget{l}{n,i}
  (pf | p, i) = x where {
  prval (pf1, fpf2) =
  array_v_takeout{a}{l}{n,i} (pf)
  val x = ptr_get1<a> (pf1 | ptr_add<a> (p, i))
  prval () = pf := fpf2 (pf1) // putting the cell and the rest together
} // end of [arrget]
')

')
")

#langeng("
#para('\

The proof function #dyncode("array_v_takeout") can be implemented as follows:\

')
")
#langja("
#para('\

証明関数 #dyncode("array_v_takeout") は次のように実装できます:\

')
")

#atscode('\
primplmnt
array_v_takeout
  {a}{l}{n,i}(pfarr) = let
  prfun takeout
    {l:addr}{n,i:nat | i < n} .<i>.
  (
    pfarr: array_v (a, l, n)
  ) : (
    a @ l+i*sizeof(a)
  , a @ l+i*sizeof(a) -<lin,prf> array_v (a, l, n)
  ) = let
    prval array_v_cons (pf1at, pf1arr) = pfarr
  in
    sif i > 0 then let
      prval (pfres, fpfres) = takeout{..}{n-1,i-1}(pf1arr)
    in
      (pfres, llam (pfres) => array_v_cons (pf1at, fpfres (pfres)))
    end else let
      prval EQINT () = eqint_make{i,0}((*void*))
    in
      (pf1at, llam (pf1at) => array_v_cons (pf1at, pf1arr))
    end // end of [sif]
  end // end of [takeout]
in
  takeout{l}{n,i}(pfarr)
end // end of [array_v_takeout]
')

#langeng("
#para('\

Note that #dyncode("llam") is a keyword for forming linear functons.  Once
a linear function is applied, it is consumed and the resource in it, if not
reclaimed, moves into the result it returns.

')
")
#langja("
#para('\

#dyncode("llam") は線形関数を作るキーワードであることに注意してください。
線形関数が適用されるとそれは消費されてその内にリソースを作り、そしてもし未回収ならば、それが返す結果の中に移動します。

')
")

#langeng("
#para('\

The proof functions presented so far for view-changes are all manipulating
array-views. The following one is different in this regard as it combines
two views for singly-linked list segments into one:

#atscode('\
prfun
slseg_v_unsplit
  {a:t@ype}
  {l1,l2,l3:addr}{n1,n2:nat}
(
  pf1lst: slseg_v (a, l1, l2, n1), pf2lst: slseg_v (a, l2, l3, n2)
) : slseg_v (a, l1, l3, n1+n2)
')

The type of #dyncode("slseg_v_unsplit") essentially states that a list
segment from L1 to L2 that is of length N1 and another list segment from L2
to L3 that is of length N2 can be thought of as a list segment from L1 to
L3 that is of length N1+N2. The following implementation of
#dyncode("slseg_v_unsplit") is largely parallel to that of
#dyncode("array_v_unsplit"):

#atscode('\
primplmnt
slseg_v_unsplit
  {a}(pf1lst, pf2lst) = let
  prfun unsplit
    {l1,l2,l3:addr}{n1,n2:nat} .<n1>.
  (
    pf1lst: slseg_v (a, l1, l2, n1), pf2lst: slseg_v (a, l2, l3, n2)
  ) : slseg_v (a, l1, l3, n1+n2) =
    sif n1 > 0 then let
      prval slseg_v_cons (pf1at, pf1lst) = pf1lst
    in
      slseg_v_cons (pf1at, unsplit (pf1lst, pf2lst))
    end else let
      prval slseg_v_nil () = pf1lst in pf2lst
    end // end of [sif]
in
  unsplit (pf1lst, pf2lst)
end // end of [slseg_v_unsplit]
')

')
")
#langja("
#para('\

これまで示してきた観変化のための証明関数は全て配列観の操作でした。
次のコードはこれらとは異なり、片方向リストを表わす2つの観を1つに結合するものと考えることができます:

#atscode('\
prfun slseg_v_unsplit
  {a:t@ype}
  {l1,l2,l3:addr}{n1,n2:nat}
(
  pf1lst: slseg_v (a, l1, l2, n1), pf2lst: slseg_v (a, l2, l3, n2)
) : slseg_v (a, l1, l3, n1+n2)
')

#dyncode("slseg_v_unsplit") の型は、長さ N1 の L1 から L2 へのリスト片と長さ N2 の L2 から L3
への別のリスト片は、長さ N1+N2 の L1 から L3 へのリスト片であると考えることができることを本質的に表わしています。
次の #dyncode("slseg_v_unsplit") の実装は #dyncode("array_v_unsplit") の実装とおおまかに類似しています:

#atscode('\
primplement
slseg_v_unsplit
  {a}(pf1lst, pf2lst) = let
  prfun unsplit
    {l1,l2,l3:addr}{n1,n2:nat} .<n1>.
  (
    pf1lst: slseg_v (a, l1, l2, n1), pf2lst: slseg_v (a, l2, l3, n2)
  ) : slseg_v (a, l1, l3, n1+n2) =
    sif n1 > 0 then let
      prval slseg_v_cons (pf1at, pf1lst) = pf1lst
    in
      slseg_v_cons (pf1at, unsplit (pf1lst, pf2lst))
    end else let
      prval slseg_v_nil () = pf1lst in pf2lst
    end // end of [sif]
in
  unsplit (pf1lst, pf2lst)
end // end of [slseg_v_unsplit]
')

')
")

#langeng("
#para('\

The reader may find it interesting to give an implementation of
#dyncode("slist_ptr_append") by making use of #dyncode("slseg_v_unsplit").

')
")
#langja("
#para('\

興味深くも #dyncode("slseg_v_unsplit") を使って #dyncode("slist_ptr_append")
を実装できることに読者は気が付くかもしれえません。

')
")

#langeng("
#para('\

Please find on-line the files #mycodelink("CHAP_DATAVIEW/array.dats",
"array.dats") and #mycodelink("CHAP_DATAVIEW/slist.dats", "slist.dats"),
which contains the code employed for illustration in this section.

')
")
#langja("
#para('\

オンラインのファイル #mycodelink("CHAP_DATAVIEW/array.dats", "array.dats") と
#mycodelink("CHAP_DATAVIEW/slist.dats", "slist.dats") からこの章で紹介したコードを入手できます。

')
")

</sect1>#comment("sect1/id=view-changes")

#comment(" ****** ****** ")

</chapter><!--id="dataviews"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
