%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="dataviewtypes">
#langeng("
#title("Dataviewtypes as Linear Datatypes")
")
#langja("
#title("線形データ型としてのデータ観型 (dataviewtype)")
")

#langeng("
#para("\

A dataviewtype can be thought of as a linear version of datatype. To a
large extent, it is a combination of a datatype and a dataview. This
programming feature is primarily introduced into ATS for the purpose of
providing in the setting of manual memory management the kind of
convenience brought by pattern matching. In a situation where GC must be
reduced or even completely eliminated, dataviewtypes can often be chosen as
a replacement for datatypes.  I now present in this chapter some commonly
encountered dataviewtypes and their uses.

")
")
#langja("
#para("\

データ観型 (dataviewtype) はデータ型の線形バージョンとして考えることができます。
おおざっぱに言うと、データ観型はデータ型とデータ観との組み合わせです。
このプログラミングの機能は手動でメモリ管理をする状況下でパターンマッチのような利便性を提供することを主な目的として ATS に導入されています。
GC を削減したり完全に除去しなければならない状況下では、データ観型はしばしばデータ型を置き換えることになります。
この章ではいくつかの一般的に用いられるデータ観型とその使い方を紹介します。

")
")

<!-- ****** ****** -->

<sect1
id="linear_optional_values">
#langeng("
#title("Linear Optional Values")
")
#langja("
#title("線形オプショナル値")
")

#langeng("
#para("\

When an optional value is created, the value is most likely to be used
immediately and then discarded. If such a value is assigned a linear type,
then the memory allocated for storing it can be efficiently reclaimed.  The
dataviewtype #stacode("option_vt") for linear optional values is declared as
follows:

#sats2xhtml('\
//
datavtype
option_vt (a:t@ype+, bool) =
  | Some_vt (a, true) of a | None_vt (a, false) of ()
// end of [option_vt]
//
vtypedef Option_vt (a:t@ype) = [b:bool] option_vt(a, b)
//
')

Note that #keycode("datavtype") is just the short version of
#keycode("dataviewtype").  The introduced dataviewtype
#stacode("option_vt") is covariant in its first argument and there are two
data constructors #dyncode("Some_vt") and #dyncode("None_vt") associated
with it. In the following example, #dyncode("find_rightmost") tries to find
the rightmost element in a list that satisfies a given predicate:

#dats2xhtml('\
fun{a:t@ype}
find_rightmost
  {n:nat} .<n>.
(
  xs: list (a, n), P: (a) -<cloref1> bool
) : Option_vt (a) =
(
  case+ xs of
  | list_cons (x, xs) => let
      val opt = find_rightmost (xs, P)
    in
      case opt of
      | ~None_vt () => if P (x) then Some_vt (x) else None_vt ()
      | _ (*Some_vt*) => opt
    end // end of [list_cons]
  | list_nil () => None_vt ()
) (* end of [find_rightmost] *)
')

Note that the tilde symbol (#keycode("~")) in front of the pattern
#dyncode("None_vt()") indicates that the memory for the node that matches
the pattern is freed before the body of the matched clause is evaluated.
In this case, no memory is actually freed as #dyncode("None_vt") is mapped
to the null pointer.  I will soon give more detailed explanation about
freeing memory allocated for constructors associated with dataviewtypes.

")
")
#langja("
#para("\

オプショナル値が生成さると、その値はたいがいすぐに使われて破棄されます。
そのような値に線形型が割り当てられているなら、値を保管するために確保されたメモリを効率よく回収することができます。
線形オプショナル値を表わすデータ観型 #stacode("option_vt") は次のように宣言されます:

#atscode('\
datavtype
option_vt (a:t@ype+, bool) =
  | Some_vt (a, true) of a | None_vt (a, false) of ()
// end of [option_vt]

vtypedef Option_vt (a:t@ype) = [b:bool] option_vt (a, b)
')

#keycode("datavtype") は単に #keycode("dataviewtype") の短縮バージョンであることに注意してください。
導入されたデータ観型 #stacode("option_vt") は1番目の引数について共変です。
また関連した2つのデータコンストラクタ #dyncode("Some_vt") と #dyncode("None_vt") があります。
次の例では、#dyncode("find_rightmost") 
与えられた述語を満たすようなリスト中の最右辺の要素を見つけようとします:

#atscode('\
fun{a:t@ype}
find_rightmost{n:nat} .<n>.
(
  xs: list (a, n), P: (a) -<cloref1> bool
) : Option_vt (a) =
(
  case+ xs of
  | list_cons (x, xs) => let
      val opt = find_rightmost (xs, P)
    in
      case opt of
      | ~None_vt () => if P (x) then Some_vt (x) else None_vt ()
      | _ (*Some_vt*) => opt
    end // end of [list_cons]
  | list_nil () => None_vt ()
) (* end of [find_rightmost] *)
')

パターン #dyncode("None_vt()") の前にあるチルダ記号 (#keycode("~"))
は、そのパターンにマッチしたノードのためのメモリが、そのマッチ節の本体が評価される前に解放されることを表わすことに注意してください。
この例では、#dyncode("None_vt") は NULL ポインタにマップされるので、実際にはメモリの解放は起きません。
データ観型に関連するコンストラクタのために確保されたメモリを解放する方法については、詳細をすぐに解説します。

")
")

#langeng("
#para('\

As another example, the following function template
#dyncode("list_optcons") tries to construct a new list with its head
element extracted from a given optional value:

#dats2xhtml('\
fn{a:t@ype}
list_optcons
  {b:bool}{n:nat}
(
  opt: option_vt (a, b), xs: list (a, n)
) : list (a, n+bool2int(b)) =
  case+ opt of
  | ~Some_vt (x) => list_cons (x, xs) | ~None_vt () => xs
// end of [list_optcons]
')

The symbol #stacode("bool2int") stands for a built-in static function in
ATS that maps #dyncode("true") and #dyncode("false") to 1 and 0,
respectively. What is special here is that the first argument of
#dyncode("list_optcons"), which is linear, is consumed after a call to
#dyncode("list_optcons") returns and the memory it occupies is reclaimed.

')
")
#langja("
#para('\

別の例として、次の関数テンプレート #dyncode("list_optcons") は与えられたオプショナル値を展開した要素を先頭にした新しいリストをコンストラクトします:

#atscode('\
fn{a:t@ype}
list_optcons
  {b:bool}{n:nat}
(
  opt: option_vt (a, b), xs: list (a, n)
) : list (a, n+bool2int(b)) =
  case+ opt of
  | ~Some_vt (x) => list_cons (x, xs) | ~None_vt () => xs
// end of [list_optcons]
')

記号 #stacode("bool2int") は #dyncode("true") と #dyncode("false") をそれぞれ 1 と 0 に変換する ATS
におけるビルトインの静的な関数です。
ここで注目すべきなのは、#dyncode("list_optcons") の最初の引数が線形であり、#dyncode("list_optcons")
呼び出しが返ると消費され、それが占有していたメモリは回収されるということです。

')
")

</sect1>#comment("sect1/id=linear_optional_values")

<!-- ****** ****** -->

<sect1
id="linear_lists">
#langeng("
#title("Linear Lists")
")
#langja("
#title("線形リスト")
")

#langeng("
#para('\

A linear list is essentially the same as a singly-linked list depicted by
the dataview #stacode("slist_v"). However, memory allocation and
deallocation of list-nodes not handled previously are handled this time.
The following declaration introduces a linear datatype #stacode("list_vt"),
which forms a boxed type (of the sort #stacode("viewtype")) when applied to
a type and an integer:

#sats2xhtml('\
datavtype
list_vt (a:t@ype+, int) =
  | list_vt_nil (a, 0) of ()
  | {n:nat}
    list_vt_cons (a, n+1) of (a, list_vt (a, n))
// end of [list_vt]
')

Given a type T and an integer I, #stacode("list_vt(T, I)") is
for linear lists of length I in which each element is of the type T.

')
")
#langja("
#para('\

線形リストはデータ観 #stacode("slist_v") で表現された片方向リストと本質的に同じです。
けれども、以前の実装ではできなかったリストノードのメモリ確保と解放が可能になります。
次の宣言は線形データ型 #stacode("list_vt") を導入しています。
これは型と整数に適用されると、(#stacode("viewtype") である) ボックス型を作ります:

#atscode('\
datavtype
list_vt (a:t@ype+, int) =
  | list_vt_nil (a, 0) of ()
  | {n:nat}
    list_vt_cons (a, n+1) of (a, list_vt (a, n))
// end of [list_vt]
')

型 T と整数 I が与えられた時、#stacode("list_vt(T, I)") は、それぞれの要素が型 T である長さ I
の線形リストを表わします。

')
")

#langeng("
#para('\

Assume that a data constructor named #emphasis("foo") is associated with a
dataviewtype.  Then there is a corresponding viewtype construtor of the name
#emphasis("foo_unfold") that takes n+1 addresses to form a viewtype, where
n is the arity of #emphasis("foo"). For instance, there is a viewtype
constructor #stacode("list_vt_cons_unfold") that takes 3 address L0, L1 and
L2 to form a viewtype #stacode("list_vt_cons_unfold(L0, L1, L2)"). This
viewtype is for a list-node created by a call to #dyncode("list_vt_cons")
such that the node is located at L0 and the two arguments of
#dyncode("list_vt_cons") are located at L1 and L2 while the proofs for the
at-views associated with L1 and L2 are put in the store for currently
available proofs.

')
")
#langja("
#para('\

あるデータ観型に関連する #emphasis("foo") という名前のデータコンストラクタあると仮定しましょう。
すると、n が #emphasis("foo") のアリティのとき、n+1 個のアドレスを取り観型 (viewtype) を作るような、一致する
#emphasis("foo_unfold") という名前の観型コンストラクタがあります。
例えば、観型コンストラクタ #stacode("list_vt_cons_unfold") は3つのアドレス L0, L1, L2
を取り、観型 #stacode("list_vt_cons_unfold(L0, L1, L2)") を作ります。
この観型は、リストノードが L0 に配置されていて、#dyncode("list_vt_cons") の2つの引数が L1 と L2
に配置されているような、#dyncode("list_vt_cons") を呼び出して作られたリストノードを表わします。
このとき L1 と L2 に関連する駐観の証明は現在有効な証明として保管されます。

')
")

#langeng("
#para('\

The following function template #dyncode("length") computes the length of a
given linear list:

#dats2xhtml('\
fn{
a:t@ype
} length{n:nat}
  (xs: !list_vt (a, n)): int n = let
  fun loop
    {i,j:nat | i+j==n} .<i>.
    (xs: !list_vt (a, i), j: int j): int (n) =
    case+ xs of
    | list_vt_cons (_, xs1) => loop (xs1, j+1) | list_vt_nil () => j
  // end of [loop]
in
  loop (xs, 0)
end // end of [length]
')

The interface of #dyncode("length") indicates that
#dyncode("length&lt;T&gt;") returns an integer equal to I when applied to a
list of the type #dyncode("list_vt(T, I)"), where T and I are a type and an
integer, respectively. Note that the symbol #dyncode("!") in front of the
type of a function argument indicates that the argument is call-by-value
and it is preserved after a call to the function. The function
#dyncode("loop") inside the body of #dyncode("length") is tail-recursive.
Given a linear list and an integer, #dyncode("loop") returns the sum of the
length of the list and the integer. In the body of #dyncode("loop"), if
#dyncode("xs") matches the pattern #dyncode("list_vt_cons(_, xs1)"), then
the name #dyncode("xs1") is bound to the tail of #dyncode("xs"). Note that
#dyncode("xs1") is a value (instead of a variable), and it is not allowed
that #dyncode("xs1") be modified into another value (of a different type).

')
")
#langja("
#para('\

次の関数テンプレート #dyncode("length") は与えられた線形のリストの長さを計算します:

#atscode('\
fn{
a:t@ype
} length{n:nat}
  (xs: !list_vt (a, n)): int n = let
  fun loop
    {i,j:nat | i+j==n} .<i>.
    (xs: !list_vt (a, i), j: int j): int (n) =
    case+ xs of
    | list_vt_cons (_, xs1) => loop (xs1, j+1) | list_vt_nil () => j
  // end of [loop]
in
  loop (xs, 0)
end // end of [length]
')

#dyncode("length") インターフェイスは、型 #dyncode("list_vt(T, I)")
のリストに適用されると、#dyncode("length&lt;T&gt;") が I に等しい整数を返すことを示しています。
このとき T と I はそれぞれ型と整数です。
関数引数の型の前にある記号 #dyncode("!")
は、その引数が値渡しで関数呼び出しが完了した後も保持されることに注意してください。
#dyncode("length") の本体内の関数 #dyncode("loop") は末尾再帰です。
線形のリストと整数が与えられた時、#dyncode("loop") はそのリストの長さとその整数の和を返します。
#dyncode("loop") の本体において、もし #dyncode("xs") が パターン #dyncode("list_vt_cons(_, xs1)")
にマッチするなら、名前 #dyncode("xs1") は #dyncode("xs") の tail に束縛されます。
#dyncode("xs1") は (変数ではなく) 値であり、#dyncode("xs1")
を違う型の別の値に変更することはできないことに注意してください。

')
")

#langeng("
#para('\

Suppose that we do want to modify the content stored in a list-node.
For instance, we may want to double the value of each integer stores in a
linear integer list. The following code implements a function named
#dyncode("list_vt_2x") that does precisely this:

#dats2xhtml('\
fun
list_vt_2x{n:nat}
  (xs: !list_vt (int, n) >> _): void =
(
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = x := 2 * x
      val () = list_vt_2x (xs1)
      prval () = fold@ (xs)
    in
      // nothing
    end // end of [list_vt_cons]
  | list_vt_nil () => ()
) (* end of [list_vt_2x] *)
')

Given a type T, the notation (#stacode("!T &gt;&gt; _")) is a shorthand for
(#stacode("!T &gt;&gt; T")).  Note that the special symbol #keycode("@") in
front of the pattern #dyncode("list_vt_cons(x, xs1)") means
#emphasis("unfolding"). If #dyncode("xs") matches this pattern, then
#dyncode("x") and #dyncode("xs1") are bound to the pointers pointing to
some memory locations L1 and L2 where the head and tail of #dyncode("xs")
are stored, respectively, and the type of #dyncode("xs") changes into
#stacode("list_vt_cons_unfold(L0, L1, L2)") for L0 being the location of
the list-node referred to by #dyncode("xs").  In the body of the clause
guarded by the pattern #dyncode("list_vt_cons(x, xs1)"), #dyncode("x") and
#dyncode("xs1") are treated as variables (which are a form of
left-value). The special proof function #dyncode("fold@") is called on
#dyncode("xs") to fold it plus the proofs of at-views attached to L1 and L2
into a linear list.

')
")
#langja("
#para('\

リストノードに保管された中身を修正したくなったとしましょう。
例えば、線形の整数リストに保管されているそれぞれの整数の値を2倍したいかもしれません。
次のコードは、このようなことを行なう #dyncode("list_vt_2x") という名前の関数を実装しています:

#atscode('\
fun
list_vt_2x{n:nat}
  (xs: !list_vt (int, n) >> _): void =
(
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = x := 2 * x
      val () = list_vt_2x (xs1)
      prval () = fold@ (xs)
    in
      // nothing
    end // end of [list_vt_cons]
  | list_vt_nil () => ()
) (* end of [list_vt_2x] *)
')

型 T が与えられた時、(#stacode("!T &gt;&gt; _")) という記法は (#stacode("!T &gt;&gt; T")) の略です。
パターン #dyncode("list_vt_cons(x, xs1)") の前にある特殊記号 #keycode("@") は
#emphasis("unfolding") を意味することに注意してください。
もし #dyncode("xs") がこのパターンにマッチした場合、
#dyncode("x") と #dyncode("xs1") は、それぞれ #dyncode("xs") の head と tail が格納された場所 L1 と L2
を指すポインタに束縛されます。
そして #dyncode("xs") が参照するリストノードの位置を L0 とするために、#dyncode("xs") の型は
#stacode("list_vt_cons_unfold(L0, L1, L2)") に変化します。
パターン #dyncode("list_vt_cons(x, xs1)") によるガード節の本体において、#dyncode("x") と #dyncode("xs1")
は (左辺値の) 変数として扱われます。
特別な証明関数 #dyncode("fold@") は #dyncode("xs") に対して呼び出され、それを畳み込むと同時に L1 と L2 に付属した駐観の証明を線形リストにします。

')
")

#langeng("
#para('\

Let us now see an example where linear list-nodes are explicitly freed:

')
")
#langja("
#para('\

線形リストのノードが正確に解放される例を見てみましょう:

')
")

#dats2xhtml('\
fun{
a:t@ype
} list_vt_free
  {n:nat} .<n>.
  (xs: list_vt (a, n)): void =
(
  case+ xs of
  | ~list_vt_cons
      (x, xs1) => list_vt_free (xs1)
  | ~list_vt_nil ((*void*)) => ()
) (* end of [list_vt_free] *)
')

#langeng("
#para('\

Given a linear list, the function #dyncode("list_vt_free") frees all the
nodes in the list. Let us go over the body of #dyncode("list_vt_free")
carefully.  If #dyncode("xs") matches the pattern #dyncode("list_vt_cons(x,
xs1)"), then the names #dyncode("x") and #dyncode("xs1") are bound to the
head and tail of #dyncode("xs"), respectively; the special symbol
#keycode("~") in front of the pattern indicates that the list-node referred
to by #dyncode("xs") is freed immediately after #dyncode("xs") matches the
pattern.  If #dyncode("xs") matches the pattern #dyncode("list_vt_nil()"),
no bindings are generated; the special symbol #keycode("~") in front of the
pattern indicates that the list-node referred to by #dyncode("xs") is
freed; nothing in this case is actually freed at run-time as
#dyncode("list_vt_nil") is mapped to the null pointer.

')
")
#langja("
#para('\

線形リストが与えられた時、関数 #dyncode("list_vt_free") はそのリスト中の全てのノードを解放します。
#dyncode("list_vt_free") の本体を注意深く調べてみましょう。
#dyncode("xs") がパターン #dyncode("list_vt_cons(x, xs1)") にマッチするなら、
名前 #dyncode("x") と #dyncode("xs1") はそれぞれ #dyncode("xs") の head と tail に束縛されます;
パターンの前にある特殊記号 #keycode("~") は、#dyncode("xs") がパターンにマッチした後、#dyncode("xs")
で参照されるリストノードが即座に解放されることを意味しています。
もし #dyncode("xs") がパターン #dyncode("list_vt_nil()") にマッチするなら、束縛は生成されません;
パターンの前にある特殊記号 #keycode("~") は #dyncode("xs") で参照されるリストノードが解放されることを示しています;
この場合 #dyncode("list_vt_nil") は NULL ポインタにマップされているので、実際に実行時には何も解放されません。

')
")

#langeng("
#para('\

It is also possible to use the special function #dyncode("free@") to
explicitly free a node (also called a skeleton) left in a linear variable
after the variable matches a pattern formed with a constructor associated
with some dataviewtype. For instance, the following code gives another
implementation of #dyncode("list_vt_free"):

')
")
#langja("
#para('\

変数がデータ観型に関連するコンストラクタで作られたパターンにマッチした後に、線形変数はそのまま残して
(またはスケルトンとも呼ばれます)
ノードを明示的に解放するために特殊関数 #dyncode("free@") を使うことも可能です。
例えば、次のコードは #dyncode("list_vt_free") の別の実装です:

')
")

#dats2xhtml('\
fun{
a:t@ype
} list_vt_free
  {n:nat} .<n>. (xs: list_vt (a, n)): void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val xs1_ = xs1 // [xs1_] is the value stored in [xs1]
      val ((*void*)) = free@{a}{0}(xs) in list_vt_free (xs1_)
    end // end of [list_vt_cons]
  | @list_vt_nil () => free@{a} (xs)
// end of [list_vt_free]
')

#langeng("
#para('\

As it can be a bit tricky to use #dyncode("free@") in practice, I present
more details as follows. First, let us note that the constructors
#dyncode("list_vt_nil") and #dyncode("list_vt_cons") associated with
#stacode("list_vt") are assigned the following types:

')
")
#langja("
#para('\

実際の場面における #dyncode("free@") の少し巧妙な使い方として、次に詳しく解説します。
はじめに #stacode("list_vt") に関連するコンストラクタ #dyncode("list_vt_nil") と #dyncode("list_vt_cons") には次のような型が割り当てられています:

')
")

#atscode('\
list_vt_nil : // one quantifier
  {a:t@ype} () -> list_vt (a, 0)
list_vt_cons : // two quantifiers
  {a:t@ype}{n:nat} (a, list_vt (a, n)) -> list_vt (a, n+1)
')

#langeng("
#para('\

If #dyncode("free@") is applied to a node of the type
#dyncode("list_vt_nil()"), it needs one static argument, which is a type,
to instantiate the quantifier in the type of the constructor
#dyncode("list_vt_nil"). If #dyncode("free@") is applied to a node of the
type #stacode("list_vt_cons_unfold(L0, L1, L2)"), then it needs two static
arguments, which are a type and an integer, to instantiate the two
quantifiers in the type of the constructor #dyncode("list_vt_cons"). In the
case where the type of #dyncode("xs") is #stacode("list_vt_cons_unfold(L0,
L1, L2)"), typechecking the call #dyncode("free@{a}{0}(xs)") implicitly
consumes a proof of the at-view #stacode("a?@L1") and another proof of the
at-view #stacode("list_vt(a, 0)?@L2").  As there is no difference between
#stacode("list_vt(T, 0)?") and #stacode("list_vt(T, I)?") for any T and I,
the static argument 0 is chosen in the code. As a matter of fact, any
natural number can be used in place of 0 as the second static argument of
#dyncode("free@").

')
")
#langja("
#para('\

もし #dyncode("free@") が型 #dyncode("list_vt_nil()") ノードに適用されたら、コンストラクタ
#dyncode("list_vt_nil") の型に量化子をインスタンス化するために、型としての静的引数を1つ必要とします。
もし #dyncode("free@") が型 #stacode("list_vt_cons_unfold(L0, L1, L2)") ノードに適用されたら、コンストラクタ
#dyncode("list_vt_cons") の型に2つの量化子をインスタンス化するために、2つの型と整数の静的引数を必要とします。
#dyncode("xs") の型が #stacode("list_vt_cons_unfold(L0, L1, L2)") である場合、
#dyncode("free@{a}{0}(xs)") 呼び出しを型検査すると駐観 #stacode("a?@L1") と駐観 #stacode("list_vt(a, 0)?@L2") の証明を暗黙的に消費します。
どのような T と I においても、#stacode("list_vt(T, 0)?") と #stacode("list_vt(T, I)?")
の間に違いがないので、静的引数 0 をこのコードでは使っています。
実際のところ、どのような自然数も #dyncode("free@") の第二静的引数として0の代わりに使うことができます。

')
")

<sect2
id="linear-list-reversing">
#langeng("
#title("Linear List-Reversing")
")
#langja("
#title("線形リストの逆順")
")

#langeng("
#para('\

The following code implements a function #dyncode("reverse") that turns a
given linear list into its reverse:

#dats2xhtml('\
fn{
a:t@ype
} reverse{n:nat}
(
  xs: list_vt (a, n)
) : list_vt (a, n) = let
  fun revapp
    {i,j:nat | i+j==n} .<i>.
  (
    xs: list_vt (a, i), ys: list_vt (a, j)
  ) : list_vt (a, n) =
    case+ xs of
    | @list_vt_cons
        (_, xs1) => let
        val xs1_ = xs1
        val () = xs1 := ys
        prval () = fold@ (xs)
      in
        revapp (xs1_, xs)
      end // end of [list_vt_cons]
    | ~list_vt_nil ((*void*)) => ys
  // end of [revapp]
in
  revapp (xs, list_vt_nil)
end // end of [reverse]
')

The type assigned to #dyncode("reverse") indicates that the function
returns a linear list of the same length as the one it consumes.  Note that
the inner function #dyncode("revapp") is tail-recursive.  This
implementation of linear list-reversing directly corresponds to the one
presented previously that is based the dataview #stacode("slseg_v") (for
singly-linked list segments). Comparing the two implementations, we can see
that the one based on dataviewtype is significantly simplified at the level
of types. For instance, there is no explicit mentioning of pointers in the
types assigned to functions #dyncode("reverse") and #dyncode("revapp").

')
")
#langja("
#para('\

次のコードは、与えられた線形リストを逆順にする関数 #dyncode("reverse") を実装しています:

#atscode('\
fn{
a:t@ype
} reverse{n:nat}
(
  xs: list_vt (a, n)
) : list_vt (a, n) = let
  fun revapp
    {i,j:nat | i+j==n} .<i>.
  (
    xs: list_vt (a, i), ys: list_vt (a, j)
  ) : list_vt (a, n) =
    case+ xs of
    | @list_vt_cons
        (_, xs1) => let
        val xs1_ = xs1
        val () = xs1 := ys
        prval () = fold@ (xs)
      in
        revapp (xs1_, xs)
      end // end of [list_vt_cons]
    | ~list_vt_nil ((*void*)) => ys
  // end of [revapp]
in
  revapp (xs, list_vt_nil)
end // end of [reverse]
')

#dyncode("reverse") に割り当てられた型は、この関数が線形リストを消費してそれと同じ長さの線形リストを返すことを示しています。
内部の関数 #dyncode("revapp") は末尾再帰であることに注意してください。
線形リストの逆順のこの実装は、以前示したデータ観 #stacode("slseg_v") (これは片方向リストでした)
を使った実装に直接対応しています。
これら2つの実装を比較すると、データ観型を使った実装は型レベルで著しく単純化されています。
例えば、関数 #dyncode("reverse") と #dyncode("revapp") に割り当てられた型において、ポインタに関して明示的な言及をしていません。

')
")

</sect2>#comment("sect2/id=linear-list-reversing")

<sect2
id="linear-list-appending">
#langeng("
#title("Linear List-Appending")
")
#langja("
#title("線形リストの連結")
")

#langeng("
#para('\

The following code implements a function #dyncode("append") that
concatenates two given linear lists into one:

#dats2xhtml('\
fn{
a:t@ype
} append{m,n:nat}
(
  xs: list_vt (a, m)
, ys: list_vt (a, n)
) : list_vt (a, m+n) = let
  fun loop {m,n:nat} .<m>. // [loop] is tail-recursive
  (
    xs: &list_vt (a, m) >> list_vt (a, m+n), ys: list_vt (a, n)
  ) : void =
    case+ xs of
    | @list_vt_cons
        (_, xs1) => let
        val () = loop (xs1, ys) in fold@ (xs)
      end // end of [list_vt_cons]
    | ~list_vt_nil ((*void*)) => xs := ys
  // end of [loop]
  var xs: List_vt (a) = xs // creating a left-value for [xs]
  val () = loop (xs, ys)
in
  xs
end // end of [append]
')

As the call #dyncode("fold@(xs)") in the body of the function
#dyncode("loop") is erased after typechecking, #dyncode("loop") is a
tail-recursive function.  Therefore, #dyncode("append") can be called on
lists of any length without the concern of possible stack overflow. The
type for the first argument of #dyncode("loop") begins with the symbol
#dyncode("&amp;"), which indicates that this argument is
call-by-reference. The type of #dyncode("loop") simply means that its first
argument is changed from a list of length #stacode("m") into a list of
length #stacode("m+n") while its second argument is consumed.

')
")
#langja("
#para('\

次のコードは、与えられた2つの線形リストを1つに連結する関数 #dyncode("append") を実装しています:

#atscode('\
fn{
a:t@ype
} append{m,n:nat}
(
  xs: list_vt (a, m)
, ys: list_vt (a, n)
) : list_vt (a, m+n) = let
  fun loop {m,n:nat} .<m>. // [loop] is tail-recursive
  (
    xs: &list_vt (a, m) >> list_vt (a, m+n), ys: list_vt (a, n)
  ) : void =
    case+ xs of
    | @list_vt_cons
        (_, xs1) => let
        val () = loop (xs1, ys) in fold@ (xs)
      end // end of [list_vt_cons]
    | ~list_vt_nil ((*void*)) => xs := ys
  // end of [loop]
  var xs: List_vt (a) = xs // creating a left-value for [xs]
  val () = loop (xs, ys)
in
  xs
end // end of [append]
')

関数 #dyncode("loop") の本体にある #dyncode("fold@(xs)") 呼び出しは型検査後に消去されるので、#dyncode("loop")
は末尾再帰関数です。
したがって、スタックオーバーフローの可能性を気にせず、どのような長さのリストに対しても #dyncode("append")
を呼び出すことができます。
#dyncode("loop") の最初の引数の型は記号 #dyncode("&amp;") ではじまっています。
これはこの引数が参照渡しであることを示しています。
#dyncode("loop") の型は、1番目の引数が長さ #stacode("m") のリストから長さ #stacode("m+n")
のリストに変化することを単に意味しています。
この時、2番目の引数は消費されます。

')
")

#langeng("
#para('\

This implementation of list append essentially corresponds to the
one presented previously that is based on the dataview #dyncode("slseg_v").
Comparing these two, we can easily see that the above one is much simpler
and cleaner, demonstrating concretely some advantage of dataviewtypes over
dataviews.

')
")
#langja("
#para('\

リスト連結のこの実装は、以前紹介したデータ観 #dyncode("slseg_v") を用いた実装と本質的に一致しています。
これら2つの比較すると、上記の実装がはるかに単純できれいで、データ観に対するデータ観型の利点を具体的に立証していることがわかるでしょう。

')
")

#langeng("
#para('\

This is also a good place for me to mention a closely related issue
involving (functional) list construction and tail-recursion. Following is a
typical implementation of functioal list concatenation:

#dats2xhtml('\
fun{
a:t@ype
} append1{m,n:nat}
(
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) =
  case+ xs of
  | list_cons (x, xs) => list_cons (x, append1 (xs, ys))
  | list_nil () => ys
// end of [append1]
')

Clearly, #dyncode("append1") is not tail-recursive, which means that it may
cause stack overflow at run-time if its first argument is very long (e.g.,
containing 1 million elements). There is, however, a direct and type-safe
way in ATS to implement functional list concatenation in a tail-recursive
manner, thus eliminating the concern of potential stack overflow. For
instance, the following implementation of #dyncode("append2") returns the
concatenation of two given functional lists while being tail-recursive:

#dats2xhtml('\
fun{
a:t@ype
} append2{m,n:nat}
(
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) = let
//
fun loop
  {m,n:nat} .<m>.
(
  xs: list (a, m), ys: list (a, n)
, res: &(List a)? >> list (a, m+n)
) : void =
(
  case+ xs of
  | list_cons
      (x, xs) => let
      val () = 
      res := list_cons{a}{0}(x, _)
      val+ list_cons (_, res1) = res
      val () = loop (xs, ys, res1)
      prval ((*void*)) = fold@ (res)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => (res := ys)
) (* end of [loop] *)
//
var res: List(a)
val () = loop (xs, ys, res)
//
in
  res
end // end of [append2]
')

During typechecking, the expression #dyncode("list_cons{a}{0}(x, _)") is
assigned the (linear) type #stacode("list_cons(L0, L1, L2)") for some
addresses L0, L1 and L2 while a proof of the at-view #stacode("a@L1") and
another proof of the at-view #stacode("list(a, 0)?@L2") are put into the
store for currently available proofs. Note that the special symbol
#keycode("_") simply indicates that the tail of the newly constructed list
is uninitialized. A partially initialized list of the type
#stacode("list_cons(L0, L1, L2)") is guaranteed to match the pattern
#dyncode("list_cons(_, res1)"), yielding a binding between #dyncode("res1")
and the pointer pointing to L2 where the (possibly uninitialized) tail of
the list is stored. When #dyncode("fold@") is called on a variable of the
type #stacode("list_cons(L0, L1, L2)"), it changes the type of the variable
to #stacode("list(T, N+1)") by consuming a proof of the at-view
#stacode("T@L1") and another proof of the at-view #stacode("list(T,
N)@L2"), where T and N are a type and an integer, respectively.

')
")
#langja("
#para('\

これはまた、関数的なリスト連結と末尾再帰に関連する問題について言及する良い機会です。
次は関数的なリスト連結の典型的な実装です:

#atscode('\
fun{
a:t@ype
} append1{m,n:nat}
(
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) =
  case+ xs of
  | list_cons (x, xs) => list_cons (x, append1 (xs, ys))
  | list_nil () => ys
// end of [append1]
')

明確に #dyncode("append1") は末尾再帰ではありません。
つまり、もし1番目の引数がとても長かった (例: 百万個の要素を含むような)
場合には実行時にスタックオーバーフローを引き起こす可能性があります。
けれども、関数的なリスト連結を末尾再帰的に実装するために、ATS では直接的かつ化安全な方法があります。
スタックオーバーフローの可能性を取り除くことができます。
例えば、
次のような #dyncode("append2") の実装は与えられた関数的な2つのリストを、末尾再帰的に連結して返します:

#atscode('\
fun{
a:t@ype
} append2{m,n:nat}
(
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) = let
//
fun loop
  {m,n:nat} .<m>.
(
  xs: list (a, m), ys: list (a, n)
, res: &(List a)? >> list (a, m+n)
) : void =
(
  case+ xs of
  | list_cons
      (x, xs) => let
      val () = 
      res := list_cons{a}{0}(x, _)
      val+ list_cons (_, res1) = res
      val () = loop (xs, ys, res1)
      prval ((*void*)) = fold@ (res)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => (res := ys)
) (* end of [loop] *)
//
var res: List(a)
val () = loop (xs, ys, res)
//
in
  res
end // end of [append2]
')

型検査の間では、アドレス L0, L1, L2 について、式 #dyncode("list_cons{a}{0}(x, _)") には線形型
#stacode("list_cons(L0, L1, L2)") が割り当てられています。
このとき、駐観 #stacode("a@L1") と駐観 #stacode("list(a, 0)?@L2") の証明が現在有効な証明として保存されます。
特殊記号 #keycode("_") は単に、新しくコンストラクトされたリストの tail
が未初期化であることを示すことに注意してください。
型 #stacode("list_cons(L0, L1, L2)") の部分的に初期化されたリストはパターン #dyncode("list_cons(_, res1)")
にマッチすることが保証されます。
この時、#dyncode("res1") と当該リストの (未初期化の可能性がある) tail を格納した L2
を指すポインタの間に束縛ができます。
T と N がそれぞれ型と整数であるとき、型 #stacode("list_cons(L0, L1, L2)") の変数に #dyncode("fold@")
が呼び出されると、それは #stacode("list(T, N+1)") 型に変化します。
この時、at-view #stacode("T@L1") と at-view #stacode("list(T, N)@L2") の証明が消費されます。

')
")

</sect2>#comment("sect2/id=linear-list-appending")

<sect2
id="linear-list-summary">
#langeng("
#title("Summary")
")
#langja("
#title("要約")
")

#langeng("
#para('\

With dataviewtypes, we can largely retain the convenience of pattern
matching associated with datatypes while supporting explicit memory
management.  Compared to dataviews, dataviewtypes are less
general. However, if a dataviewtype can be employed to solve a problem,
then the solution is often significantly simpler and cleaner than an
alternative dataview-based one.

')
")
#langja("
#para('\

データ型に関連付けれられているパターンマッチの利便性を、データ観型を用いて明示的なメモリ管理をサポートする際にも享受することができました。
データ観と比較するとデータ観型は一般的ではありません。
けれども、もしデータ観型を用いて問題を解決できれば、
その解決策はデータ観を用いた時よりしばしばきわめて単純できれいになります。

')
")

</sect2>#comment("sect2/id=linear-list-summary")

</sect1>#comment("sect1/id=linear_lists")

<!-- ****** ****** -->

<sect1
id="example_mergeSort_lin">
#langeng("
#title("Example: Merge-Sort on Linear Lists")
")
#langja("
#title("例: 線形リストのマージソート")
")

#langeng("
#para("\

When merge-sort is employed to sort an array of elements, it requires
additional memory proportionate to the size of the array in order to move
the elements around, which is considered a significant weakness of
merge-sort. However, merge-sort does not have this requirement when it
operates on a linear list.  I present as follows an implementation of
merge-sort on linear lists that can readily rival its counterpart in C in
terms of both time-efficiency and memory-efficiency. The invariants
captured in this implementation and the easiness to capture them should
provide strong evidence that attests to ATS being a programming language
capable of enforcing great precision in practical programming.

")
")
#langja("
#para("\

配列の要素をソートするためにマージソートをすると、要素を移動させるために配列のサイズに比例した追加のメモリが必要になります。
これはマージソートの重大な欠点と考えられます。
けれども、線形リストに対するマージソートにはこのような要求はありません。
C言語の相当する実装に時間効率と空間効率の両面で匹敵できるような、線形リストのマージソートを次に示します。
この実装にて捕捉された不変条件とその捕捉の容易さは、現実のプログラミングにおいて ATS
が高い正確さを強制できるプログラミング言語であることを実証する大きな証拠です。

")
")

#langeng("
#para('\

Let us first introduce a type definition and an interface for a function
template that compares elements in lists to be sorted:

#sats2xhtml('\
//
typedef cmp (a:t@ype) = (&a, &a) -> int
//
fun{a:t@ype}
compare (x: &a, y: &a, cmp: cmp(a)): int
//
')

The interface for merge-sort is given as follows:

#sats2xhtml('\
fun{
a:t@ype
} mergeSort{n:nat}
  (xs: list_vt (a, n), cmp: cmp a): list_vt (a, n)
// end of [mergeSort]
')

The first argument of #dyncode("mergeSort") is a linear list (to be sorted)
and the second one a function for comparing the elements in the linear
list.  Clearly, the interface of #dyncode("mergeSort") indicates that
#dyncode("mergeSort") consumes its first argument and then returns a linear
list that is of the same length as its first argument. As is to become clear,
the returned linear list is constructed with the nodes of the consumed
one. In particular, the implementation of #dyncode("mergeSort") given as
follows does not involve any memory allocation or deallocation.

')
")
#langja("
#para('\

はじめに、ソートするリストの要素を比較する関数テンプレートの型定義とインターフェイスを導入しましょう:

#atscode('\
//
typedef cmp (a:t@ype) = (&a, &a) -> int
//
fun{a:t@ype} compare (x: &a, y: &a, cmp: cmp (a)): int
//
')

マージソートのインターフェイスは次のように与えられます:

#atscode('\
fun{
a:t@ype
} mergeSort{n:nat}
  (xs: list_vt (a, n), cmp: cmp a): list_vt (a, n)
// end of [mergeSort]
')

#dyncode("mergeSort") の1番目の引数は (ソートする)
線形リストで、2番目の引数は線形リストの要素を比較するための関数です。
明確に、#dyncode("mergeSort") のインターフェイスは #dyncode("mergeSort")
が1番目の引数を消費してから、1番目の引数と同じ長さの線形リストを返すことを示しています。
明確になったように、返される線形リストは消費されたリストのノードでコンストラクトされたことになります。
特に、次に与えられた #dyncode("mergeSort") の実装はどのようなメモリの確保/解放も必要としません。

')
")

#langeng("
#para('\

The function template for merging two sorted lists into one is given as follows:

#dats2xhtml('\
fun{
a:t@ype
} merge{m,n:nat} .<m+n>.
(
  xs: list_vt (a, m), ys: list_vt (a, n)
, res: &List_vt(a)? >> list_vt (a, m+n)
, cmp: cmp a
) : void =
  case+ xs of
  | @list_vt_cons (x, xs1) => (
    case+ ys of
    | @list_vt_cons (y, ys1) => let
        val sgn = compare<a> (x, y, cmp)
      in
        if sgn <= 0 then let // stable sorting
          val () = res := xs
          val xs1_ = xs1
          prval () = fold@ (ys)
          val () = merge<a> (xs1_, ys, xs1, cmp)
        in
          fold@ (res)
        end else let
          val () = res := ys
          val ys1_ = ys1
          prval () = fold@ (xs)
          val () = merge<a> (xs, ys1_, ys1, cmp)
        in
          fold@ (res)
        end // end of [if]
      end (* end of [list_vt_cons] *)
    | ~list_vt_nil () => (fold@ (xs); res := xs)
    ) // end of [list_vt_cons]
  | ~list_vt_nil () => (res := ys)
// end of [merge]
')

Unlike the one given in a previous functional implementation, this
implementation of #dyncode("merge") is tail-recursive and thus is guaranteed
to be translated into a loop in C by the ATS compiler. This means that the
concern of #dyncode("merge") being unable to handle very long lists (e.g.,
containing 1 million elements) due to potential stack overflow is
eliminated.

')
")
#langja("
#para('\

2つのソート済みリストを1つにマージする関数テンプレートは次のように与えられます:

#atscode('\
fun{
a:t@ype
} merge{m,n:nat} .<m+n>.
(
  xs: list_vt (a, m), ys: list_vt (a, n)
, res: &List_vt(a)? >> list_vt (a, m+n)
, cmp: cmp a
) : void =
  case+ xs of
  | @list_vt_cons (x, xs1) => (
    case+ ys of
    | @list_vt_cons (y, ys1) => let
        val sgn = compare<a> (x, y, cmp)
      in
        if sgn <= 0 then let // stable sorting
          val () = res := xs
          val xs1_ = xs1
          prval () = fold@ (ys)
          val () = merge<a> (xs1_, ys, xs1, cmp)
        in
          fold@ (res)
        end else let
          val () = res := ys
          val ys1_ = ys1
          prval () = fold@ (xs)
          val () = merge<a> (xs, ys1_, ys1, cmp)
        in
          fold@ (res)
        end // end of [if]
      end (* end of [list_vt_cons] *)
    | ~list_vt_nil () => (fold@ (xs); res := xs)
    ) // end of [list_vt_cons]
  | ~list_vt_nil () => (res := ys)
// end of [merge]
')

以前の紹介した関数実装と異なり、#dyncode("merge") のこの実装は末尾再帰です。
そのため ATS コンパイラはC言語のループに変換します。
つまり、スタックオーバフローの可能性のために (例: 百万個の要素を含むような)
とても長いリストを扱えないような心配はこの #dyncode("merge") にはありません。

')
")

#langeng("
#para('\

The next function template is for splitting a given linear lists into two:

#dats2xhtml('\
fun{
a:t@ype
} split{n,k:nat | k <= n} .<n-k>.
(
  xs: &list_vt (a, n) >> list_vt (a, n-k), nk: int (n-k)
) : list_vt (a, k) =
  if nk > 0 then let
    val+@list_vt_cons(_, xs1) = xs
    val res = split<a> (xs1, nk-1); prval () = fold@(xs)
  in
    res
  end else let
    val res = xs; val () = xs := list_vt_nil () in res
  end // end of [if]
// end of [split]
')

Note that the implementation of #dyncode("split") is also tail-recursive.

')
")
#langja("
#para('\

次の関数テンプレートは与えられた線形リストを2つに分割します:

#atscode('\
fun{
a:t@ype
} split{n,k:nat | k <= n} .<n-k>.
(
  xs: &list_vt (a, n) >> list_vt (a, n-k), nk: int (n-k)
) : list_vt (a, k) =
  if nk > 0 then let
    val+@list_vt_cons(_, xs1) = xs
    val res = split<a> (xs1, nk-1); prval () = fold@(xs)
  in
    res
  end else let
    val res = xs; val () = xs := list_vt_nil () in res
  end // end of [if]
// end of [split]
')

#dyncode("split") の実装もまた末尾再帰であることに注意してください。

')
")

#langeng("
#para('\

The following function template #dyncode("msort") takes a linear list, its
length and a comparsion function, and it returns a sorted version of the
given linear list:

#dats2xhtml('\
fun{
a:t@ype
} msort{n:nat} .<n>.
(
  xs: list_vt (a, n), n: int n, cmp: cmp(a)
) : list_vt (a, n) =
  if n >= 2 then let
    val n2 = half(n)
    val n3 = n - n2
    var xs = xs // lvalue for [xs]
    val ys = split<a> (xs(*cbr*), n3)
    val xs = msort<a> (xs, n3, cmp)
    val ys = msort<a> (ys, n2, cmp)
    var res: List_vt (a) // uninitialized
    val () = merge<a> (xs, ys, res(*cbr*), cmp)
  in
    res
  end else xs
// end of [msort]
')

The second argument of #dyncode("msort") is passed so that the length of
the list being sorted does not have to be computed directly by traversing
the list when each recursive call to #dyncode("msort") is made.

')
")
#langja("
#para('\

次の関数テンプレート #dyncode("msort")
は線形リストとその長さ、比較関数を取り、そして与えられた線形リストをソートしたものを返します:

#atscode('\
fun{
a:t@ype
} msort{n:nat} .<n>.
(
  xs: list_vt (a, n), n: int n, cmp: cmp(a)
) : list_vt (a, n) =
  if n >= 2 then let
    val n2 = half(n)
    val n3 = n - n2
    var xs = xs // lvalue for [xs]
    val ys = split<a> (xs(*cbr*), n3)
    val xs = msort<a> (xs, n3, cmp)
    val ys = msort<a> (ys, n2, cmp)
    var res: List_vt (a) // uninitialized
    val () = merge<a> (xs, ys, res(*cbr*), cmp)
  in
    res
  end else xs
// end of [msort]
')

#dyncode("msort") を再帰呼び出しする際、ソートされるリストの長さをそのリストを辿って直接算出する必要がないように、#dyncode("msort") の2番目の引数が渡されます。

')
")

#langeng("
#para('\

Finally, #dyncode("mergeSort") can be implemented with a call to
#dyncode("msort"):

#dats2xhtml('\
implement{a}
mergeSort (xs, cmp) = msort<a> (xs, length (xs), cmp)
')

By inspecting the implementation of #dyncode("split") and
#dyncode("merge"), we can readiy see that #dyncode("mergeSort") performs
stable sorting, that is, it preserves the order of equal elements during
sorting.

')
")
#langja("
#para('\

最後に、#dyncode("mergeSort") は #dyncode("msort") 呼び出しを使って実装できます:

#atscode('\
implement{a}
mergeSort (xs, cmp) = msort<a> (xs, length (xs), cmp)
')

#dyncode("split") と #dyncode("merge") の実装を調べてみると、#dyncode("mergeSort")
が安定ソートになっていることがすぐにわかります。
つまり、ソートしている間に、等しい要素群の順序は保存されています。

')
")

#langeng("
#para('\

Please find #mycodelink("CHAP_DATAVTYPE/mergeSort.dats", "on-line") the
entirety of the code presented in this section plus some additional code
for testing.

')
")
#langja("
#para('\

この章で紹介したコード全体と追加のテストコードは
#mycodelink("CHAP_DATAVTYPE/mergeSort.dats", "オンライン")
から入手できます。

')
")

</sect1>#comment("sect1/id=example_mergeSort_lin")

<!-- ****** ****** -->

<sect1
id="example_insertionSort_lin">
#langeng("
#title("Example: Insertion Sort on Linear Lists")
")
#langja("
#title("例: 線形リストの挿入ソート")
")

#langeng("
#para('\

I present a standard implementation of insertion sort on linear lists in
this section.  The interface for insertion sort is given as follows:

#sats2xhtml('\
fun{
a:t@ype
} insertionSort{n:nat}
  (xs: list_vt (a, n), cmp: cmp a): list_vt (a, n)
// end of [insertionSort]
')

Like #dyncode("mergeSort"), #dyncode("insertionSort") is implemented in a
manner that makes no use of memory allocation or deallocation.  Given a
linear list, #dyncode("insertionSort") essentially shuffles the nodes in
the list to form a sorted list.

')
")
#langja("
#para('\

この章では線形リストの挿入ソートの一般的な実装を紹介します。
挿入ソートのインターフェイスは次のように与えられます:

#atscode('\
fun{
a:t@ype
} insertionSort{n:nat}
  (xs: list_vt (a, n), cmp: cmp a): list_vt (a, n)
// end of [insertionSort]
')

#dyncode("mergeSort") のように、#dyncode("insertionSort") の実装はメモリの確保/解放を行ないません。
線形リストが与えられた時、本質的に #dyncode("insertionSort")
はそのリストのノードを入れ換えてソートされたリストを作ります。

')
")

#langeng("
#para('\

The following code implements a function #dyncode("insord") that inserts a
given list-node into a sorted linear list to form another sorted linear list:

#dats2xhtml('\
fun{
a:t@ype
} insord
  {l0,l1,l2:addr}{n:nat}
(
  pf1: a @ l1
, pf2: list_vt (a, 0)? @ l2
| xs0: &list_vt (a, n) >> list_vt (a, n+1)
, nx0: list_vt_cons_unfold (l0, l1, l2), p1: ptr (l1), p2: ptr (l2)
, cmp: cmp (a)
) : void =
(
  case+ xs0 of
  | @list_vt_cons
      (x0, xs1) => let
      val sgn = compare<a> (x0, !p1, cmp)
    in
      if sgn <= 0 // HX: for stableness: [<=] instead of [<]
        then let
          val () = insord<a> (pf1, pf2 | xs1, nx0, p1, p2, cmp)
          prval () = fold@ (xs0)
        in
          // nothing
        end // end of [then]
        else let
          prval () = fold@ (xs0)
          val () = (!p2 := xs0; xs0 := nx0)
          prval () = fold@ (xs0)
        in
          // nothing
        end // end of [else]
      // end of [if]
    end // end of [list_vt_cons]
  | ~list_vt_nil () =>
    {
      val () = xs0 := nx0
      val () = !p2 := list_vt_nil ()
      prval () = fold@ (xs0)
    }
) (* end of [insord] *)
')

The implementation of #dyncode("insord") is tail-recursive.  The type
assigned to #dyncode("insord") indicates that the argument xs0 of
#dyncode("insord") is call-by-reference. If xs0 stores a list of length n
when #dyncode("insord") is called, then it stores a list of length n+1 when
#dyncode("insord") returns. The arguments nx0, p1 and p2 are call-by-value,
and they should be bound to a list-node and the first and second fields in
the list-node, respectively, when a call to #dyncode("insord")
initiates. The proof arguments pf1 and pf2 are needed so that the pointers
bound to p1 and p2 can be accessed and updated.

')
")
#langja("
#para('\

次のコードは関数 #dyncode("insord") を実装しています。
この関数は与えられたリストノードをソート済みの線形リストに挿入して、別のソート済み線形リストを作ります:

#atscode('\
fun{
a:t@ype
} insord
  {l0,l1,l2:addr}{n:nat}
(
  pf1: a @ l1
, pf2: list_vt (a, 0)? @ l2
| xs0: &list_vt (a, n) >> list_vt (a, n+1)
, nx0: list_vt_cons_unfold (l0, l1, l2), p1: ptr (l1), p2: ptr (l2)
, cmp: cmp (a)
) : void =
(
  case+ xs0 of
  | @list_vt_cons
      (x0, xs1) => let
      val sgn = compare<a> (x0, !p1, cmp)
    in
      if sgn <= 0 // HX: for stableness: [<=] instead of [<]
        then let
          val () = insord<a> (pf1, pf2 | xs1, nx0, p1, p2, cmp)
          prval () = fold@ (xs0)
        in
          // nothing
        end // end of [then]
        else let
          prval () = fold@ (xs0)
          val () = (!p2 := xs0; xs0 := nx0)
          prval () = fold@ (xs0)
        in
          // nothing
        end // end of [else]
      // end of [if]
    end // end of [list_vt_cons]
  | ~list_vt_nil () =>
    {
      val () = xs0 := nx0
      val () = !p2 := list_vt_nil ()
      prval () = fold@ (xs0)
    }
) (* end of [insord] *)
')

#dyncode("insord") の実装は末尾再帰です。
#dyncode("insord") に割り当てられた型は #dyncode("insord") の引数 xs0 が参照渡しであることを示しています。
もし #dyncode("insord") が呼び出された時に xs0 が長さ n のリストを保持していたら、
#dyncode("insord") が返る時には xs0 は長さ n+1 のリストを保持していることになります。
引数 nx0, p1, p2 は値渡しで、#dyncode("insord") が呼び出される時それらはそれぞれ
リストノード, リストノードの1番目のフィールド, 2番目のフィールド に束縛されています。
p1 と p2 を束縛するポインタにアクセスしたり更新したりするために、証明引数 pf1 と pf2 が必要です。

')
")

#langeng("
#para('\

The function template #dyncode("insertionSort") can now be readily
implemented based #dyncode("insord"):

#dats2xhtml('\
implement{a}
insertionSort
  (xs, cmp) = let
//
fun loop{m,n:nat}
(
  xs: list_vt (a, m)
, ys: &list_vt (a, n) >> list_vt (a, m+n)
, cmp: cmp (a)
) : void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val xs1_ = xs1
      val ((*void*)) =
        insord<a> (view@x, view@xs1 | ys, xs, addr@x, addr@xs1, cmp)
      // end of [va]
    in
      loop (xs1_, ys, cmp)
    end // end of [list_vt_cons]
  | ~list_vt_nil ((*void*)) => ()
//
var ys = list_vt_nil{a}()
val () = loop (xs, ys, cmp)
//
in
  ys
end // end of [insertionSort]
')

Clearly, this implementation of #dyncode("insertionSort") is
tail-recursive.  While insertion sort is of O(n^2)-time complexity, it is
often more efficient than merge-sort or quick-sort when sorting very short
lists.  For instance, we may implement #dyncode("msort") (which is called
by #dyncode("mergeSort")) as follows by taking advantage of the efficiency
of #dyncode("insertionSort") on short lists:

#dats2xhtml('\
fun{
a:t@ype
} msort{n:nat} .<n>.
(
  xs: list_vt (a, n)
, n: int n, cmp: cmp(a)
) : list_vt (a, n) = let
//
// cutoff is selected to be 10
//
in
  if n > 10 then let
    val n2 = half(n)
    val n3 = n - n2
    var xs = xs // lvalue for [xs]
    val ys = split<a> (xs, n3)
    val xs = msort<a> (xs, n3, cmp)
    val ys = msort<a> (ys, n2, cmp)
    var res: List_vt (a) // uninitialized
    val () = merge<a> (xs, ys, res(*cbr*), cmp)
  in
    res
  end else insertionSort<a> (xs, cmp)
end // end of [msort]
')

Note that the stableness of #dyncode("mergeSort") is maintained as
#dyncode("insertionSort") also performs stable sorting.

')
")
#langja("
#para('\

関数テンプレート #dyncode("insertionSort") は #dyncode("insord") を用いてすぐに実装できます:

#atscode('\
implement{a}
insertionSort
  (xs, cmp) = let
//
fun loop{m,n:nat}
(
  xs: list_vt (a, m)
, ys: &list_vt (a, n) >> list_vt (a, m+n)
, cmp: cmp (a)
) : void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val xs1_ = xs1
      val ((*void*)) =
        insord<a> (view@x, view@xs1 | ys, xs, addr@x, addr@xs1, cmp)
      // end of [va]
    in
      loop (xs1_, ys, cmp)
    end // end of [list_vt_cons]
  | ~list_vt_nil ((*void*)) => ()
//
var ys = list_vt_nil{a}()
val () = loop (xs, ys, cmp)
//
in
  ys
end // end of [insertionSort]
')

明確に、#dyncode("insertionSort") のこの実装は末尾再帰です。
挿入ソートの時間的計算量は O(n^2)
ですが、ソートするリストがとても短かい場合にはマージソートやクイックソートよりもしばしばより効率的です。
例えば、短かいリストについて #dyncode("insertionSort") の効率が有利になるような
(#dyncode("mergeSort") が呼び出す) #dyncode("msort") を次のように実装できます:

#atscode('\
fun{
a:t@ype
} msort{n:nat} .<n>.
(
  xs: list_vt (a, n)
, n: int n, cmp: cmp(a)
) : list_vt (a, n) = let
//
// cutoff is selected to be 10
//
in
  if n > 10 then let
    val n2 = half(n)
    val n3 = n - n2
    var xs = xs // lvalue for [xs]
    val ys = split<a> (xs, n3)
    val xs = msort<a> (xs, n3, cmp)
    val ys = msort<a> (ys, n2, cmp)
    var res: List_vt (a) // uninitialized
    val () = merge<a> (xs, ys, res(*cbr*), cmp)
  in
    res
  end else insertionSort<a> (xs, cmp)
end // end of [msort]
')

#dyncode("mergeSort") と同様に、#dyncode("insertionSort") も安定ソートであることに注意してください。

')
")

#langeng("
#para('\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DATAVTYPE/insertionSort.dats", "on-line").

')
")
#langja("
#para('\

この章で紹介したコード全体と追加のテストコードは
#mycodelink("CHAP_DATAVTYPE/insertionSort.dats", "オンライン")
から入手できます。

')
")

</sect1>#comment("sect1/id=example_insertionSort_lin")

<!-- ****** ****** -->

<sect1
id="example_quickSort_lin">
#langeng("
#title("Example: Quick-Sort on Linear Lists")
")
#langja("
#title("例: 線形リストのクイックソート")
")

#langeng("
#para('\

In this section, I give an implementation of quick-sort on linear
lists. While list-based quick-sort may not be a preferred sorting method in
practice, its implementation is nonetheless interesting.
The interface for quick-sort is given as follows:

#sats2xhtml('\
//
fun{a:t@ype}
quickSort{n:nat}
  (xs: list_vt (a, n), cmp: cmp a): list_vt (a, n)
//
')

Like the implementation of #dyncode("mergeSort") and
#dyncode("insertionSort"), the implementation of #dyncode("quickSort")
given as follows makes no use of memory allocation and deallocation.

')
")
#langja("
#para('\

この章では、線形リストのクイックソートの実装を紹介します。
リストを用いたクイックソートは実際には望ましいソート方法ではありませんが、にもかかわらずその実装は興味深いものです。
クイックソートのインターフェイスは次のように与えられます:

#atscode('\
fun{a:t@ype}
quickSort{n:nat} (xs: list_vt (a, n), cmp: cmp a): list_vt (a, n)
')

#dyncode("mergeSort") と #dyncode("insertionSort") の実装のように、
次のように与えられた #dyncode("quickSort") の実装はメモリの確保/解放を行ないません。

')
")

#langeng("
#para('\

The following code implements a function #dyncode("takeout_node_at") that
takes out a node from a linear list at a given position:

#dats2xhtml('\
fun{a:t@ype}
takeout_node_at
  {n:int}{k:nat | k < n}
(
  xs: &list_vt (a, n) >> list_vt (a, n-1), k: int(k)
) : list_vt_cons_pstruct (a, ptr?) =
(
//
if k > 0 then let
  val+@list_vt_cons (x, xs1) = xs
  val res = takeout_node_at<a> (xs1, k-1)
  prval () = fold@ (xs)
in
  res
end else let
  val+@list_vt_cons (x, xs1) = xs
  val nx = xs
  val () = xs := xs1
in
  $UNSAFE.castvwtp0 ((view@x, view@xs1 | nx)) // HX: this is a safe cast
end // end of [if]
//
) (* end of [takeout_node_at] *)
')

Assume that a data constructor named #emphasis("foo") is associated with a
dataviewtype.  Then there is a corresponding viewtype construtor of the
name #emphasis("foo_pstruct") that takes n types to form a viewtype, where
n is the arity of #emphasis("foo"). For instance, there is a viewtype
constructor #stacode("list_vt_cons_pstruct") that takes 2 types T1 and T2
to form a viewtype #stacode("list_vt_cons_pstruct(T1, T2)"). This viewtype
is for a list-node created by a call to #dyncode("list_vt_cons") such that
the two arguments of #dyncode("list_vt_cons") are of types T1 and T2.
Essentially, #stacode("list_vt_cons_pstruct(T1, T2)") stands for
#stacode("list_vt_cons_unfold(L0, L1, L2)") for some addresses L0, L1 and
L2 plus two views #stacode("T1@L1") and #stacode("T2@L2").

')
")
#langja("
#para('\

次のコードは関数 #dyncode("takeout_node_at") を実装しています。
この関数は線形リストから与えられた位置のノードを取り出します:

#atscode('\
fun{a:t@ype}
takeout_node_at
  {n:int}{k:nat | k < n}
(
  xs: &list_vt (a, n) >> list_vt (a, n-1), k: int(k)
) : list_vt_cons_pstruct (a, ptr?) =
(
//
if k > 0 then let
  val+@list_vt_cons (x, xs1) = xs
  val res = takeout_node_at<a> (xs1, k-1)
  prval () = fold@ (xs)
in
  res
end else let
  val+@list_vt_cons (x, xs1) = xs
  val nx = xs
  val () = xs := xs1
in
  $UNSAFE.castvwtp0 ((view@x, view@xs1 | nx)) // HX: this is a safe cast
end // end of [if]
//
) (* end of [takeout_node_at] *)
')

データ観型に関連する #emphasis("foo") という名前のデータコンストラクタを仮定します。
すると n が #emphasis("foo") のアリティの時、n 個の型を取って観型を作るような対応する
#emphasis("foo_pstruct") という名前の観型コンストラクタが存在します。
例えば、2つの型 T1 と T2 を取って観型 #stacode("list_vt_cons_pstruct(T1, T2)") を作るような観型コンストラクタ #stacode("list_vt_cons_pstruct") が存在することになります。
この観型は、#dyncode("list_vt_cons") の2つの引数の型が T1 と T2 であるような、#dyncode("list_vt_cons")
呼び出しによって生成されるリストノードを表わします。
アドレス L0, L1, L2 と2つの観 #stacode("T1@L1"), #stacode("T2@L2")
について、#stacode("list_vt_cons_pstruct(T1, T2)") は #stacode("list_vt_cons_unfold(L0, L1, L2)")
を本質的に表わしています。

')
")

#langeng("
#para('\

A key step in quick-sort lies in partitioning a linear list based on a
given pivot. This step is fulfilled by the following code that implements a
function template named #dyncode("partition"):

#dats2xhtml('\
fun{
a:t@ype
} partition{n,r1,r2:nat}
(
  xs: list_vt (a, n), pvt: &a
, r1: int(r1), res1: list_vt (a, r1), res2: list_vt (a, r2)
, cmp: cmp (a)
) : [n1,n2:nat | n1+n2==n+r1+r2]
  (int(n1), list_vt (a, n1), list_vt (a, n2)) =
(
  case+ xs of
  | @list_vt_cons
      (x, xs_tail) => let
      val xs_tail_ = xs_tail
      val sgn = compare<a> (x, pvt, cmp)
    in
      if sgn <= 0 then let
        val r1 = r1 + 1
        val () = xs_tail := res1
        prval () = fold@ (xs)
      in
        partition<a> (xs_tail_, pvt, r1, xs, res2, cmp)
      end else let
        val () = xs_tail := res2
        prval () = fold@ (xs)
      in
        partition<a> (xs_tail_, pvt, r1, res1, xs, cmp)
      end // end of [if]
    end (* end of [list_vt_cons] *)
  | ~list_vt_nil ((*void*)) => (r1, res1, res2)
) (* end of [partition] *)
')

The implementation of #dyncode("partition") is tail-recursive.  Given a
linear list and a pivot, #dyncode("partition") returns a tuple (r1, res1,
res2) such that res1 contains every element in the list that is less than
or equal to the pivot, res2 contains the rest, and r1 is the length of
res1. The way in which the nodes of the given linear list are moved into
res1 and res2 is quite an interesting aspect of this implementation.

')
")
#langja("
#para('\

クイックソートの鍵となるステップは、与えられたピボットを元に線形リストを分割することです。
このステップは、#dyncode("partition") という名前の関数テンプレートを実装している次のコードで実行されます:

#atscode('\
fun{
a:t@ype
} partition{n,r1,r2:nat}
(
  xs: list_vt (a, n), pvt: &a
, r1: int(r1), res1: list_vt (a, r1), res2: list_vt (a, r2)
, cmp: cmp (a)
) : [n1,n2:nat | n1+n2==n+r1+r2]
  (int(n1), list_vt (a, n1), list_vt (a, n2)) =
(
  case+ xs of
  | @list_vt_cons
      (x, xs_tail) => let
      val xs_tail_ = xs_tail
      val sgn = compare<a> (x, pvt, cmp)
    in
      if sgn <= 0 then let
        val r1 = r1 + 1
        val () = xs_tail := res1
        prval () = fold@ (xs)
      in
        partition<a> (xs_tail_, pvt, r1, xs, res2, cmp)
      end else let
        val () = xs_tail := res2
        prval () = fold@ (xs)
      in
        partition<a> (xs_tail_, pvt, r1, res1, xs, cmp)
      end // end of [if]
    end (* end of [list_vt_cons] *)
  | ~list_vt_nil ((*void*)) => (r1, res1, res2)
) (* end of [partition] *)
')

#dyncode("partition") の実装は末尾再帰です。
線形リストとピボットが与えられた時、#dyncode("partition") はタプル (r1, res1, res2) を返します。
このとき res1 はリスト中でピボット以下の全ての要素を含み、res2 はその残りを含み、r1 は res1 の長さになります。
与えらえた線形リストのノードを res1 と res2 に移動させる方法は、この実装の大変興味深い側面です。

')
")

#langeng("
#para('\

By making use of #dyncode("takeout_node_at") and #dyncode("partition"),
we can readily implement #dyncode("quickSort") as follows:

#dats2xhtml('\
implement
{a}(*tmp*)
quickSort
  (xs, cmp) = let
//
fun sort{n:nat}
(
  xs: list_vt (a, n), n: int n
) : list_vt (a, n) =
(
  if n > 10 then let
    val n2 = half (n)
    var xs = xs
    val nx = takeout_node_at<a> (xs, n2)
    val+list_vt_cons (pvt, nx_next) = nx
    val (n1, xs1, xs2) =
    partition<a> (xs, pvt, 0, list_vt_nil, list_vt_nil, cmp)
    val xs1 = sort (xs1, n1)
    val xs2 = sort (xs2, n - 1 - n1)
    val () = nx_next := xs2
    prval () = fold@ (nx)
  in
    list_vt_append (xs1, nx)
  end else insertionSort<a> (xs, cmp)
) (* end of [sort] *)
//
in
  sort (xs, list_vt_length (xs))
end // end of [quickSort]
')

Note that the pivot for each round is taken from the middle of the list
being sorted, which can be time-consuming as taking out a node from the
middle of a list is O(n)-time. This issue can be addressed by always
choosing the first element to be the pivot. However, doing so can
often lead to degenerated O(n^2)-time performance of quick-sort in practice.

')
")
#langja("
#para('\

#dyncode("takeout_node_at") と #dyncode("partition") を使って、次のような #dyncode("quickSort") をすぐに実装できます:

#atscode('\
implement
{a}(*tmp*)
quickSort
  (xs, cmp) = let
//
fun sort{n:nat}
(
  xs: list_vt (a, n), n: int n
) : list_vt (a, n) =
(
  if n > 10 then let
    val n2 = half (n)
    var xs = xs
    val nx = takeout_node_at<a> (xs, n2)
    val+list_vt_cons (pvt, nx_next) = nx
    val (n1, xs1, xs2) =
    partition<a> (xs, pvt, 0, list_vt_nil, list_vt_nil, cmp)
    val xs1 = sort (xs1, n1)
    val xs2 = sort (xs2, n - 1 - n1)
    val () = nx_next := xs2
    prval () = fold@ (nx)
  in
    list_vt_append (xs1, nx)
  end else insertionSort<a> (xs, cmp)
) (* end of [sort] *)
//
in
  sort (xs, list_vt_length (xs))
end // end of [quickSort]
')

それぞれの分割におけるピボットはソートされるリストの真ん中に取っていることに注意してください。
リストの真ん中からノードを取り出す時間的計算量は O(n) です。
この問題は最初の要素をピボットとしていつも選ぶことによって解決できます。
けれどもそうすると、実際のクイックソートの効率は結果としてしばしば O(n^2) に悪化してしまいます。

')
")

#langeng("
#para('\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DATAVTYPE/quickSort.dats", "on-line").

')
")
#langja("
#para('\

この章のコード全体と追加のテストコードは
#mycodelink("CHAP_DATAVTYPE/quickSort.dats", "オンライン")
から入手できます。

')
")

</sect1>#comment("sect1/id=example_quickSort_lin")

<!-- ****** ****** -->

<sect1
id="linear_binary_search_trees">
#langeng("
#title("Linear Binary Search Trees")
")
#langja("
#title("線形2分探索木")
")

#langeng("
#para("\

A binary search tree with respect to a given ordering is a binary tree such
that the value stored in each node inside the tree is greater than or equal
to those stored in the left child of the node and less than or equal to
those stored in the right child of the node.  Binary search trees are a
common data structure for implementing finite maps.

")
")
#langja("
#para("\

与えられた順序に対する2分探索木は二分木です。
この木の中のそれぞれのノードに保管されている値は、そのノードの左の子以上でかつ右の子以下になっています。
2分探索木は連想配列を実装するのに一般的なデータ構造です。

")
")

#langeng("
#para("\

A family of binary
trees are said to be balanced if there is a fixed constant C (for the
entire family) such that the ratio between the length of a longest path and
the length of a shortest path is bounded by C for every tree in the
family. For instance, common examples of balanced binary trees include AVL
trees and red-black trees. Finite maps based on balanced binary search
trees support guaranteed log-time insertion and deletion operations, that
is, the time to complete such an operation is O(log(n)) in the worst case,
where n is the size of the map.

")
")
#langja("
#para("\

二分木の最長と最短の高さの比がどの木においても定数 C の範囲におさまるとき、この二分木は平衡木であると呼ばれます。
例えば、平衡2分探索木の一般的な例としてはAVL木や赤黒木があります。
平衡2分探索木を用いた連想配列は log 時間で挿入/削除操作ができることを保証します。
すなわち、n が連想配列のサイズであるとき、そのような操作を完了するのにかかる時間は最悪でも O(log(n))
になります。

")
")

#langeng("
#para('\

In this section, I am to implement several basic operations on linear
binary search trees, further illustrating some use of dataviewtypes. Let us
first declare as follows a dataviewtype #stacode("bstree_vt") for linear
binary (search) trees:

#sats2xhtml('\
datavtype
bstree_vt
(
  a:t@ype+, int
) = // bstree_vt
  | bstree_vt_nil (a, 0) of ()
  | {n1,n2:nat}
    bstree_vt_cons (a, n1+n2+1) of (bstree_vt(a, n1), a, bstree_vt(a, n2))
// end of [bstree_vt]
')

')
")
#langja("
#para('\

この章では、線形2分探索木に対するいくつかの基本的な操作を実装します。
さらにその後、データ観型を使った実装を紹介します。
はじめに、線形2分探索木のために次のデータ観型 #stacode("bstree_vt") を宣言しましょう:

#atscode('\
datavtype
bstree_vt (a:t@ype+, int) =
  | bstree_vt_nil (a, 0) of ()
  | {n1,n2:nat}
    bstree_vt_cons (a, n1+n2+1) of (bstree_vt (a, n1), a, bstree_vt (a, n2))
// end of [bstree_vt]
')

')
")

#langeng("
#para('\

Note that the integer index of #stacode("bstree_vt") captures the size
information of a binary (search) tree.  There are two constructors
#dyncode("bstree_vt_cons") and #dyncode("bstree_vt_nil") associated with
#stacode("bstree_vt"). It should be pointed out that the tree created by
#dyncode("bstree_vt_nil") is empty and thus not a leaf, which on the other
hand is a node whose left and right children are both empty.  As a simple
example, the following function template #dyncode("size") computes the size
of a given tree:

#dats2xhtml('\
fun{
a:t@ype
} size{n:nat} .<n>.
(
  t: !bstree_vt (a, n)
) : int (n) =
  case+ t of
  | bstree_vt_nil () => 0
  | bstree_vt_cons
     (tl, _, tr) => 1 + size (tl) + size (tr)
// end of [size]
')

')#comment("para")
")
#langja("
#para('\

#stacode("bstree_vt") の整数インデックスは、2分探索木のサイズ情報を捕捉していることに注意してください。
#stacode("bstree_vt") に関連する2つのコンストラクタ #dyncode("bstree_vt_cons") と #dyncode("bstree_vt_nil")
があります。
#dyncode("bstree_vt_nil") によって生成された木は空で葉を持たず、他方ではノードは左と右の子が両方とも空であることは指摘すべきでしょう。
簡単な例として、次の関数テンプレート #dyncode("size") は与えられた木のサイズを計算します:

#atscode('\
fun{
a:t@ype
} size{n:nat} .<n>.
(
  t: !bstree_vt (a, n)
) : int (n) =
  case+ t of
  | bstree_vt_nil () => 0
  | bstree_vt_cons
     (tl, _, tr) => 1 + size (tl) + size (tr)
// end of [size]
')

')#comment("para")
")

#langeng("
#para('\

Assume that we have a binary search tree with repect to some ordering.  If
a predicate P on the elements stored in the tree possesses the property
that P(x1) implies P(x2) whenever x1 is less than x2 (according to the
ordering), then we can locate the least element in the tree that satisfies
the predicate P by employing so-called binary search as is demonstrated in
the following implementation of #dyncode("search"):

#dats2xhtml('\
fun{
a:t@ype
} search
  {n:nat} .<n>.
(
  t: !bstree_vt (a, n), P: (&a) -<cloref> bool
) : Option_vt (a) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) =>
      if P (x) then let
        val res = search (tl, P)
        val res = (
          case+ res of
          | ~None_vt () => Some_vt (x) | _ => res
        ) : Option_vt (a)
      in
        fold@ (t); res
      end else let
        val res = search (tr, P) in fold@ (t); res
      end // end of [if]
  | @bstree_vt_nil () => (fold@ (t); None_vt ())
// end of [search]
')

Clearly, if the argument #dyncode("t") of #dyncode("search") ranges over a
family of balanced trees, then the time-complexity of #dyncode("search") is
O(log(n)) (assuming that #dyncode("P") is O(1)).

')
")
#langja("
#para('\

なんらかの順序による2分探索木を持っていると仮定します。
もし木に保管されている要素について x1 が x2 より (順序によると) 小さいなら P(x1) が P(x2)
を含むような性質を持つ述語 P があるとすると、次の #dyncode("search")
の実装によって示されるような2分探索によって呼び出される述語 P を満たす木の最小の要素の場所を見つけることができます:

#atscode('\
fun{
a:t@ype
} search
  {n:nat} .<n>.
(
  t: !bstree_vt (a, n), P: (&a) -<cloref> bool
) : Option_vt (a) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) =>
      if P (x) then let
        val res = search (tl, P)
        val res = (
          case+ res of
          | ~None_vt () => Some_vt (x) | _ => res
        ) : Option_vt (a)
      in
        fold@ (t); res
      end else let
        val res = search (tr, P) in fold@ (t); res
      end // end of [if]
  | @bstree_vt_nil () => (fold@ (t); None_vt ())
// end of [search]
')

もし #dyncode("search") の引数 #dyncode("t") が平衡木の一種であるなら、#dyncode("P") の時間的計算量が O(1)
であると仮定すると #dyncode("search") の計算量は O(log(n)) であることは明確です。

')
")

#langeng("
#para('\

Let us next see some code implementing an operation that inserts a given
element into a binary search tree:

#dats2xhtml('\
fun{
a:t@ype
} insert{n:nat} .<n>.
(
  t: bstree_vt (a, n), x0: &a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) => let
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn <= 0 then let
        val () = tl := insert (tl, x0, cmp)
      in
        fold@ (t); t
      end else let
        val () = tr := insert (tr, x0, cmp)
      in
        fold@ (t); t
      end (* end of [if] *)
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =>
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insert]
')

')
")
#langja("
#para('\

次に、与えられた要素を2分探索木に挿入する操作を実装してみましょう:

#atscode('\
fun{
a:t@ype
} insert{n:nat} .<n>.
(
  t: bstree_vt (a, n), x0: &a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) => let
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn <= 0 then let
        val () = tl := insert (tl, x0, cmp)
      in
        fold@ (t); t
      end else let
        val () = tr := insert (tr, x0, cmp)
      in
        fold@ (t); t
      end (* end of [if] *)
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =>
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insert]
')

')
")

#langeng("
#para('\

When inserting an element, the function template #dyncode("insert") extends
the given tree with a new leaf node containing the element, and this form
of insertion is often referred to as leaf-insertion.  There is another form
of insertion often referred to as root-insertion, which always puts at the
root position the new node containing the inserted element. The following
function template #dyncode("insertRT") is implemented to perform a standard
root-insertion operation:

#dats2xhtml('\
fun{
a:t@ype
} insertRT{n:nat} .<n>.
(
  t: bstree_vt (a, n), x0: &a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) => let
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn <= 0 then let
        val tl_ = insertRT (tl, x0, cmp)
        val+@bstree_vt_cons (_, tll, tlr) = tl_
        val () = tl := tlr
        prval () = fold@ (t)
        val () = tlr := t
      in
        fold@ (tl_); tl_
      end else let
        val tr_ = insertRT (tr, x0, cmp)
        val+@bstree_vt_cons (trl, _, trr) = tr_
        val () = tr := trl
        prval () = fold@ (t)
        val () = trl := t
      in
        fold@ (tr_); tr_
      end
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =>
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insertRT]
')

The code immediately following the first recursive call to
#dyncode("insertRT") performs a right tree rotation. Let us use T(tl, x,
tr) for a tree such that its root node contains the element x and its left
and right children are tl and tr, respectively. Then a right rotation turns
T(T(tll, xl, tlr), x, tr) into T(tll, xl, T(tlr, x, tr)).  The code
immediately following the second recursive call to #dyncode("insertRT")
performs a left tree rotation, which turns T(tl, x, T(trl, xr, trr)) into
T(T(tl, x, tlr), xr, trr).

')
")
#langja("
#para('\

要素を挿入する時、関数テンプレート #dyncode("insert") はその要素を含む新しい葉で与えられた木を拡張します。
このような挿入方法はしばしば leaf-insertion と呼ばれます。
別の挿入方法として root-insertion
としばしば呼ばれる方法があり、これは挿入された要素を含む新しいノードをルートに置きます。
次の関数テンプレート #dyncode("insertRT") は一般的な root-insertion 操作を実装しています:

#atscode('\
fun{
a:t@ype
} insertRT{n:nat} .<n>.
(
  t: bstree_vt (a, n), x0: &a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) => let
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn <= 0 then let
        val tl_ = insertRT (tl, x0, cmp)
        val+@bstree_vt_cons (_, tll, tlr) = tl_
        val () = tl := tlr
        prval () = fold@ (t)
        val () = tlr := t
      in
        fold@ (tl_); tl_
      end else let
        val tr_ = insertRT (tr, x0, cmp)
        val+@bstree_vt_cons (trl, _, trr) = tr_
        val () = tr := trl
        prval () = fold@ (t)
        val () = trl := t
      in
        fold@ (tr_); tr_
      end
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =>
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insertRT]
')

1番目の再帰呼び出し #dyncode("insertRT") の直後のコードは木の右回転を行ないます。
ルートノードが要素 x とその左と右の子としてそれぞれ tl と tr を持つような木として T(tl, x, tr)
を用いることにしましょう。
すると T(T(tll, xl, tlr), x, tr) は右回転をすると T(tll, xl, T(tlr, x, tr)) になります。
2番目の再帰呼び出し #dyncode("insertRT") の直後のコードは木の左回転を行ないます。
すると T(tl, x, T(trl, xr, trr)) は T(T(tl, x, tlr), xr, trr) になります。

')
")

#langeng("
#para('\

To further illustrate tree rotations, I present as follows
two function templates #dyncode("lrotate") and #dyncode("rrotate"), which
implement the left and right tree rotations, respectively:

#dats2xhtml('\
fn{
a:t@ype
} lrotate
  {l,l_tl,l_x,l_tr:addr} 
  {nl,nr:int | nl >= 0; nr > 0}
(
  pf_tl: bstree_vt (a, nl) @ l_tl
, pf_x: a @ l_x
, pf_tr: bstree_vt (a, nr) @ l_tr
| t: bstree_vt_cons_unfold (l, l_tl, l_x, l_tr)
, p_tl: ptr l_tl
, p_tr: ptr l_tr
) : bstree_vt (a, 1+nl+nr) = let
  val tr = !p_tr
  val+@bstree_vt_cons (trl, _, trr) = tr
  val () = !p_tr := trl
  prval () = fold@ (t); val () = trl := t
in
  fold@ (tr); tr
end // end of [lrotate]

fn{
a:t@ype
} rrotate
  {l,l_tl,l_x,l_tr:addr}
  {nl,nr:int | nl > 0; nr >= 0}
(
  pf_tl: bstree_vt (a, nl) @ l_tl
, pf_x: a @ l_x
, pf_tr: bstree_vt (a, nr) @ l_tr
| t: bstree_vt_cons_unfold (l, l_tl, l_x, l_tr)
, p_tl: ptr l_tl
, p_tr: ptr l_tr
) : bstree_vt (a, 1+nl+nr) = let
  val tl = !p_tl
  val+@bstree_vt_cons (tll, x, tlr) = tl
  val () = !p_tl := tlr
  prval () = fold@ (t); val () = tlr := t
in
  fold@ (tl); tl
end // end of [rrotate]
')

Given 4 addresses L0, L1, L2 and L3, the type
#stacode("bstree_vt_cons_unfold(L0, L1, L2, l3)") is for a tree node
created by a call to #dyncode("bstree_vt_cons") such that the node is
located at L0 and the three arguments of #dyncode("bstree_vt_cons") are
located at L1, L2 and L3, and the proofs for the at-views associated with
L1, L2 and L3 are put in the store for currently available proofs.

')
")
#langja("
#para('\

さらに木の操作を説明するために、次の2つの関数テンプレート #dyncode("lrotate") と #dyncode("rrotate") を示します。
これらはそれぞれ木の左回転と右回転を実装しています:

#atscode('\
fn{
a:t@ype
} lrotate
  {l,l_tl,l_x,l_tr:addr} 
  {nl,nr:int | nl >= 0; nr > 0}
(
  pf_tl: bstree_vt (a, nl) @ l_tl
, pf_x: a @ l_x
, pf_tr: bstree_vt (a, nr) @ l_tr
| t: bstree_vt_cons_unfold (l, l_tl, l_x, l_tr)
, p_tl: ptr l_tl
, p_tr: ptr l_tr
) : bstree_vt (a, 1+nl+nr) = let
  val tr = !p_tr
  val+@bstree_vt_cons (trl, _, trr) = tr
  val () = !p_tr := trl
  prval () = fold@ (t); val () = trl := t
in
  fold@ (tr); tr
end // end of [lrotate]

fn{
a:t@ype
} rrotate
  {l,l_tl,l_x,l_tr:addr}
  {nl,nr:int | nl > 0; nr >= 0}
(
  pf_tl: bstree_vt (a, nl) @ l_tl
, pf_x: a @ l_x
, pf_tr: bstree_vt (a, nr) @ l_tr
| t: bstree_vt_cons_unfold (l, l_tl, l_x, l_tr)
, p_tl: ptr l_tl
, p_tr: ptr l_tr
) : bstree_vt (a, 1+nl+nr) = let
  val tl = !p_tl
  val+@bstree_vt_cons (tll, x, tlr) = tl
  val () = !p_tl := tlr
  prval () = fold@ (t); val () = tlr := t
in
  fold@ (tl); tl
end // end of [rrotate]
')

4つのアドレス L0, L1, L2, L3 が与えられた時、型 #stacode("bstree_vt_cons_unfold(L0, L1, L2, l3)")
は #dyncode("bstree_vt_cons") 呼び出しによって生成された木のノードを表わします。
このとき、そのノードは L0 に配置され、#dyncode("bstree_vt_cons") の3つの引数は L1, L2, L3 に配置されます。
そして L1, L2, L3 に関連する駐観の証明が現在有効な証明として保管されます。

')
")

#langeng("
#para('\

The function template #dyncode("insertRT") for root-insertion can now be
implemented as follows by making direct use of #dyncode("lrotate") and
#dyncode("rrotate"):

#atscode('\
fun{
a:t@ype
} insertRT {n:nat} .<n>.
(
  t: bstree_vt (a, n), x0: &a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) => let
      prval pf_x = view@x
      prval pf_tl = view@tl
      prval pf_tr = view@tr
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn <= 0 then let
        val () = tl := insertRT<a> (tl, x0, cmp)
      in
        rrotate<a> (pf_tl, pf_x, pf_tr | t, addr@tl, addr@tr)
      end else let
        val () = tr := insertRT<a> (tr, x0, cmp)
      in
        lrotate<a> (pf_tl, pf_x, pf_tr | t, addr@tl, addr@tr)
      end (* end of [if] *)
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =>
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insertRT]
')

')
")
#langja("
#para('\

これで、root-insertion を行なう関数テンプレート #dyncode("insertRT") は
#dyncode("lrotate") と #dyncode("rrotate") を直接使って次のように実装できます:

#dats2xhtml('\
fun{
a:t@ype
} insertRT {n:nat} .<n>.
(
  t: bstree_vt (a, n), x0: &a, cmp: cmp(a)
) : bstree_vt (a, n+1) =
  case+ t of
  | @bstree_vt_cons
      (tl, x, tr) => let
      prval pf_x = view@x
      prval pf_tl = view@tl
      prval pf_tr = view@tr
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn <= 0 then let
        val () = tl := insertRT<a> (tl, x0, cmp)
      in
        rrotate<a> (pf_tl, pf_x, pf_tr | t, addr@tl, addr@tr)
      end else let
        val () = tr := insertRT<a> (tr, x0, cmp)
      in
        lrotate<a> (pf_tl, pf_x, pf_tr | t, addr@tl, addr@tr)
      end (* end of [if] *)
    end // end of [bstree_vt_cons]
  | ~bstree_vt_nil () =>
      bstree_vt_cons (bstree_vt_nil, x0, bstree_vt_nil)
    // end of [bstree_vt_nil]
// end of [insertRT]
')

')
")

#langeng("
#para('\

I would like to point out that neither #dyncode("insert") nor
#dyncode("insertRT") is tail-recursive. While it is straightforward to give
the former a tail-recursive implementation, there is no direct way to do
the same to the latter. In order to implement root-insertion in a
tail-recursive manner, we are in need of binary search trees with parental
pointers (so as to allow each node to gain direct access to its parent),
which can be done with dataviews but not with dataviewtypes.

')
")
#langja("
#para('\

#dyncode("insert") も #dyncode("insertRT") も末尾再帰ではないことを指摘したいと思います。
前者を末尾再帰実装にすることはできますが、後者について同じことをする直接的な方法はありません。
root-insertion を末尾再帰的に実装するためには、親ポインタのある二分木が必要になります
(すなわちそれぞれのノードからその親に直接アクセスできるということです)。
これはデータ観で実現できますが、データ観型を使って実現することはできません。

')
")

#langeng("
#para("\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DATAVTYPE/bstree_vt.dats", "on-line").

")
")
#langja("
#para("\

この章のコード全体と追加のテストコードは
#mycodelink("CHAP_DATAVTYPE/bstree_vt.dats", "オンライン")
から入手できます。

")
")

</sect1>#comment("sect1/id=linear_binary_search_trees")

<!-- ****** ****** -->

<sect1
id="transition_from_datatypes_to_dataviewtypes">
#langeng("
#title("Transition from Datatypes to Dataviewtypes")
")
#langja("
#title("データ型からデータ観型への翻訳")
")

#langeng("
#para('\

Many programmers are likely to find it a rather involved task to write code
manipulating values of dataviewtypes. When handling a complex data
structure, I myself often try to first use a datatype to model the data
structure and implement some functionalities of the data structure based
the datatype. I then change the datatype into a corresponding dataviewtype
and modify the implementation accordingly to make it work with the
dataviewtype. I now present as follows an implementation of linear
red-black trees that is directly based on a previous
<xref linkend="example_fun_red-black_trees"/>,
illustrating concretely a kind of gradual transition from datatypes to
dataviewtypes that can greatly reduce the level of difficulty one may
otherwise encounter in an attempt to program with dataviewtypes directly.

')
")
#langja("
#para('\

多くのプログラマは、データ観型の値を操作するコードを書くことを幾分複雑に感じると思います。
込み入ったデータ構造を扱う時、しばしば私はデータ型をはじめに使おうとすることがあります。
そのデータ構造をモデリングして、データ型を用いてそのデータ構造のいくつかの機能を実装してみるのです。
それからそのデータ型を対応するデータ観型に変換し、データ観型として動作するようにその実装を修正します。
ここでは、以前の <xref linkend="example_fun_red-black_trees"/> を元にした線形赤黒木の実装を次に示します。
これはデータ型からデータ観型への漸進的な翻訳を具体的に説明しています。
データ観型を直接用いてプログラミングしようとする際の難易度を大きく減少させることができるのです。

')
")

#langeng("
#para('\

The following declaration of dataviewtype #stacode("rbtree") is identical
to the previous declaration of datatype #stacode("rbtree") except the
keyword #keycode("datavtype") being now used instead of the keyword
#keycode("datatype"):

#sats2xhtml('\
\#define BLK 0; \#define RED 1
sortdef clr = {c:int | 0 <= c; c <= 1}

datavtype rbtree
(
  a: t@ype+, int(*c*), int(*bh*), int(*v*)
) = // element type, color, black height, violations
  | rbtree_nil (a, BLK, 0, 0) of ((*void*))
  | {c,cl,cr:clr}{bh:nat}{v:int}
    {c==BLK && v==0 || c == RED && v==cl+cr}
    rbtree_cons (a, c, bh+1-c, v) of (int c, rbtree0 (a, cl, bh), a, rbtree0 (a, cr, bh))
// end of [rbtree]

where rbtree0 (a:t@ype, c:int, bh:int) = rbtree (a, c, bh, 0)
')

')
")
#langja("
#para('\

次のデータ観型 #stacode("rbtree") 宣言は以前のデータ型 #stacode("rbtree") 宣言とほぼ一致しています。
違うのはキーワード #keycode("datatype") の代わりに、キーワード #keycode("datavtype") を使っている点です:

#atscode('\
\#define BLK 0; \#define RED 1
sortdef clr = {c:int | 0 <= c; c <= 1}

datavtype rbtree
(
  a: t@ype+, int(*c*), int(*bh*), int(*v*)
) = // element type, color, black height, violations
  | rbtree_nil (a, BLK, 0, 0) of ((*void*))
  | {c,cl,cr:clr}{bh:nat}{v:int}
    {c==BLK && v==0 || c == RED && v==cl+cr}
    rbtree_cons (a, c, bh+1-c, v) of (int c, rbtree0 (a, cl, bh), a, rbtree0 (a, cr, bh))
// end of [rbtree]

where rbtree0 (a:t@ype, c:int, bh:int) = rbtree (a, c, bh, 0)
')

')
")

#langeng("
#para('\

At the first sight, the following function template #dyncode("insfix_l") is
greatly more involved that a previous version of the same name (for
manipulating functional red-black trees):

#dats2xhtml('\
fn{
a:t@ype
} insfix_l // right rotation
  {cl,cr:clr}
  {bh:nat}{v:nat}
  {l,l_c,l_tl,l_x,l_tr:addr}
(
  pf_c: int(BLK) @ l_c
, pf_tl: rbtree (a, cl, bh, v) @ l_tl
, pf_x: a @ l_x
, pf_tr: rbtree (a, cr, bh, 0) @ l_tr
| t: rbtree_cons_unfold (l, l_c, l_tl, l_x, l_tr)
, p_tl: ptr (l_tl)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK
  \#define R RED
  \#define nil rbtree_nil
  \#define cons rbtree_cons
in
  case+ !p_tl of
  | @cons (cl as R, tll as @cons (cll as R, _, _, _), _, tlr) => let
//
      val () = cll := B
      prval () = fold@ (tll)
//
      val tl = !p_tl
      val () = !p_tl := tlr
      prval () = fold@ (t)
      val () = tlr := t
//
    in
      fold@ (tl); tl
    end // end of [cons (R, cons (R, ...), ...)]
  | @cons (cl as R, tll, _, tlr as @cons (clr as R, tlrl, _, tlrr)) => let
//
      val tl = !p_tl
      val () = !p_tl := tlrr
      prval () = fold@ (t)
      val () = tlrr := t
//
      val tlr_ = tlr
      val () = tlr := tlrl
      val () = cl := B
      prval () = fold@ (tl)
      val () = tlrl := tl
//
    in
      fold@ (tlr_); tlr_
    end // end of [cons (R, ..., cons (R, ...))]
  | _ (*rest-of-cases*) =>> (fold@ (t); t)
end // end of [insfix_l]
')

However, I would like to point out that the interface for the above
#dyncode("insfix_l") is a #emphasis("direct") translation of the interface for
the previous #dyncode("insfix_l"). In other words, the previously captured
relation between a tree being rotated and the one obtained from applying
#dyncode("insfix_l") to it also holds in the setting of linear red-black trees.
The very same statement can be made about the following function template
#dyncode("insfix_r"), which is precisely a mirror image of #dyncode("insfix_l"):

#dats2xhtml('\
fn{
a:t@ype
} insfix_r // left rotation
  {cl,cr:clr}
  {bh:nat}{v:nat}
  {l,l_c,l_tl,l_x,l_tr:addr} (
  pf_c: int(BLK) @ l_c
, pf_tl: rbtree (a, cl, bh, 0) @ l_tl
, pf_x: a @ l_x
, pf_tr: rbtree (a, cr, bh, v) @ l_tr
| t: rbtree_cons_unfold (l, l_c, l_tl, l_x, l_tr)
, p_tr: ptr (l_tr)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK
  \#define R RED
  \#define nil rbtree_nil
  \#define cons rbtree_cons
in
  case+ !p_tr of
  | @cons (cr as R, trl, _, trr as @cons (crr as R, _, _, _)) => let
//
      val () = crr := B
      prval () = fold@ (trr)
//
      val tr = !p_tr
      val () = !p_tr := trl
      prval () = fold@ (t)
      val () = trl := t
//
    in
      fold@ (tr); tr
    end // end of [cons (R, ..., cons (R, ...))]
  | @cons (cr as R, trl as @cons (crr as R, trll, _, trlr), _, trr) => let
//
      val tr = !p_tr
      val () = !p_tr := trll
      prval () = fold@ (t)
      val () = trll := t
//
      val trl_ = trl
      val () = trl := trlr
      val () = cr := B
      prval () = fold@ (tr)
      val () = trlr := tr
//
    in
      fold@ (trl_); trl_
    end // end of [cons (R, cons (R, ...), ...)]
  | _ (*rest-of-cases*) =>> (fold@ (t); t)
end // end of [insfix_r]
')

')
")
#langja("
#para('\

ひと目見たところ、次の関数テンプレート #dyncode("insfix_l") は (関数的な赤黒木の)
同じ名前の関数よりもはるかに複雑です:

#atscode('\
fn{
a:t@ype
} insfix_l // right rotation
  {cl,cr:clr}
  {bh:nat}{v:nat}
  {l,l_c,l_tl,l_x,l_tr:addr}
(
  pf_c: int(BLK) @ l_c
, pf_tl: rbtree (a, cl, bh, v) @ l_tl
, pf_x: a @ l_x
, pf_tr: rbtree (a, cr, bh, 0) @ l_tr
| t: rbtree_cons_unfold (l, l_c, l_tl, l_x, l_tr)
, p_tl: ptr (l_tl)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK
  \#define R RED
  \#define nil rbtree_nil
  \#define cons rbtree_cons
in
  case+ !p_tl of
  | @cons (cl as R, tll as @cons (cll as R, _, _, _), _, tlr) => let
//
      val () = cll := B
      prval () = fold@ (tll)
//
      val tl = !p_tl
      val () = !p_tl := tlr
      prval () = fold@ (t)
      val () = tlr := t
//
    in
      fold@ (tl); tl
    end // end of [cons (R, cons (R, ...), ...)]
  | @cons (cl as R, tll, _, tlr as @cons (clr as R, tlrl, _, tlrr)) => let
//
      val tl = !p_tl
      val () = !p_tl := tlrr
      prval () = fold@ (t)
      val () = tlrr := t
//
      val tlr_ = tlr
      val () = tlr := tlrl
      val () = cl := B
      prval () = fold@ (tl)
      val () = tlrl := tl
//
    in
      fold@ (tlr_); tlr_
    end // end of [cons (R, ..., cons (R, ...))]
  | _ (*rest-of-cases*) =>> (fold@ (t); t)
end // end of [insfix_l]
')

けれども、上記の #dyncode("insfix_l") のインターフェイスは以前示した #dyncode("infix_l") のインターフェイスを
#emphasis("直接") 翻訳したものだと指摘したいのです。
別の言い方をすると、以前の実装は回転される木と #dyncode("infix_l")
をそれに適用して得られる木との関係を捕捉していました。
これはまた線形赤黒木でも維持されています。
次の関数テンプレート #dyncode("insfix_r") のようによく似た文を作ることができます。
これは #dyncode("insfix_l") の正確な鏡像になっています:

#atscode('\
fn{
a:t@ype
} insfix_r // left rotation
  {cl,cr:clr}
  {bh:nat}{v:nat}
  {l,l_c,l_tl,l_x,l_tr:addr} (
  pf_c: int(BLK) @ l_c
, pf_tl: rbtree (a, cl, bh, 0) @ l_tl
, pf_x: a @ l_x
, pf_tr: rbtree (a, cr, bh, v) @ l_tr
| t: rbtree_cons_unfold (l, l_c, l_tl, l_x, l_tr)
, p_tr: ptr (l_tr)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK
  \#define R RED
  \#define nil rbtree_nil
  \#define cons rbtree_cons
in
  case+ !p_tr of
  | @cons (cr as R, trl, _, trr as @cons (crr as R, _, _, _)) => let
//
      val () = crr := B
      prval () = fold@ (trr)
//
      val tr = !p_tr
      val () = !p_tr := trl
      prval () = fold@ (t)
      val () = trl := t
//
    in
      fold@ (tr); tr
    end // end of [cons (R, ..., cons (R, ...))]
  | @cons (cr as R, trl as @cons (crr as R, trll, _, trlr), _, trr) => let
//
      val tr = !p_tr
      val () = !p_tr := trll
      prval () = fold@ (t)
      val () = trll := t
//
      val trl_ = trl
      val () = trl := trlr
      val () = cr := B
      prval () = fold@ (tr)
      val () = trlr := tr
//
    in
      fold@ (trl_); trl_
    end // end of [cons (R, cons (R, ...), ...)]
  | _ (*rest-of-cases*) =>> (fold@ (t); t)
end // end of [insfix_r]
')

')
")

#langeng("
#para('\

As can be expected, the following function template
#dyncode("rbtree_insert") is essentially a direct translation of the one of
the same name for inserting an element into a functional red-black tree:

#dats2xhtml('\
extern
fun{a:t@ype}
rbtree_insert
  {c:clr}{bh:nat}
(
  t: rbtree0 (a, c, bh), x0: &a, cmp: cmp a
) : [bh1:nat] rbtree0 (a, BLK, bh1)

implement{a}
rbtree_insert
  (t, x0, cmp) = let
//
\#define B BLK
\#define R RED
\#define nil rbtree_nil
\#define cons rbtree_cons
//
fun ins
  {c:clr}{bh:nat} .<bh,c>.
(
  t: rbtree0 (a, c, bh), x0: &a
) : [cl:clr; v:nat | v <= c] rbtree (a, cl, bh, v) =
(
  case+ t of
  | @cons (
      c, tl, x, tr
    ) => let
      prval pf_c = view@c
      prval pf_tl = view@tl
      prval pf_x = view@x
      prval pf_tr = view@tr
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn < 0 then let
        val [cl:int,v:int] tl_ = ins (tl, x0)
        val () = tl := tl_
      in
        if (c = B)
        then (
          insfix_l<a>
            (pf_c, pf_tl, pf_x, pf_tr | t, addr@tl)
          // end of [insfix_l]
        ) else let
          val () = c := R in fold@{a}{..}{..}{cl}(t); t
        end // end of [if]
      end else if sgn > 0 then let
        val [cr:int,v:int] tr_ = ins (tr, x0)
        val () = tr := tr_
      in
        if (c = B)
        then (
          insfix_r<a>
            (pf_c, pf_tl, pf_x, pf_tr | t, addr@tr)
          // end of [insfix_r]
        ) else let
          val () = c := R in fold@{a}{..}{..}{cr}(t); t
        end // end of [if]
      end else (fold@{a}{..}{..}{0} (t); t)
    end // end of [cons]
  | ~nil () => cons{a}{..}{..}{0}(R, nil, x0, nil)
) (* end of [ins] *)
//
val t = ins (t, x0)
//
in
//
case+ t of @cons(c as R, _, _, _) => (c := B; fold@ (t); t) | _ =>> t
//
end // end of [rbtree_insert]
')

')
")
#langja("
#para('\

予想されることですが、本質的に次の関数テンプレート #dyncode("rbtree_insert")
は、関数的な赤黒木に要素を挿入する同じ名前の実装の直接的な翻訳です:

#atscode('\
extern
fun{a:t@ype}
rbtree_insert
  {c:clr}{bh:nat}
(
  t: rbtree0 (a, c, bh), x0: &a, cmp: cmp a
) : [bh1:nat] rbtree0 (a, BLK, bh1)

implement{a}
rbtree_insert
  (t, x0, cmp) = let
//
\#define B BLK
\#define R RED
\#define nil rbtree_nil
\#define cons rbtree_cons
//
fun ins
  {c:clr}{bh:nat} .<bh,c>.
(
  t: rbtree0 (a, c, bh), x0: &a
) : [cl:clr; v:nat | v <= c] rbtree (a, cl, bh, v) =
(
  case+ t of
  | @cons (
      c, tl, x, tr
    ) => let
      prval pf_c = view@c
      prval pf_tl = view@tl
      prval pf_x = view@x
      prval pf_tr = view@tr
      val sgn = compare<a> (x0, x, cmp)
    in
      if sgn < 0 then let
        val [cl:int,v:int] tl_ = ins (tl, x0)
        val () = tl := tl_
      in
        if (c = B)
        then (
          insfix_l<a>
            (pf_c, pf_tl, pf_x, pf_tr | t, addr@tl)
          // end of [insfix_l]
        ) else let
          val () = c := R in fold@{a}{..}{..}{cl}(t); t
        end // end of [if]
      end else if sgn > 0 then let
        val [cr:int,v:int] tr_ = ins (tr, x0)
        val () = tr := tr_
      in
        if (c = B)
        then (
          insfix_r<a>
            (pf_c, pf_tl, pf_x, pf_tr | t, addr@tr)
          // end of [insfix_r]
        ) else let
          val () = c := R in fold@{a}{..}{..}{cr}(t); t
        end // end of [if]
      end else (fold@{a}{..}{..}{0} (t); t)
    end // end of [cons]
  | ~nil () => cons{a}{..}{..}{0}(R, nil, x0, nil)
) (* end of [ins] *)
//
val t = ins (t, x0)
//
in
//
case+ t of @cons(c as R, _, _, _) => (c := B; fold@ (t); t) | _ =>> t
//
end // end of [rbtree_insert]
')

')
")

#langeng("
#para('\

I literally implemented the above #dyncode("rbtree_insert") by making a
copy of the previous implementation of #dyncode("rbtree_insert") for
functional red-black trees and then properly modifying it to make it pass
typechecking. Although this process of copying-and-modifying is difficult
to be described formally, it is fairly straightforward to follow in
practice as it is almost entirely guided by the error messages issued
during typechecking.

')
")
#langja("
#para('\

私は文字通り以前の関数的な赤黒木の #dyncode("rbtree_insert")
実装をコピーし、それから型検査を通るように適切に修正して、上記の #dyncode("rbtree_insert") を実装しました。
このコピーして修正する作業は外見的には難しく見えますが、型検査して起きるエラーメッセージに従えばそのほとんどはかなり単純です。

')
")

#langeng("
#para("\

Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DATAVTYPE/rbtree.dats", "on-line").
A challenging as well as rewarding exercise is for the reader to implement
an operation that deletes an element from a given linear red-black tree.

")
")
#langja("
#para("\

この章のコード全体と追加のテストコードは
#mycodelink("CHAP_DATAVTYPE/rbtree.dats", "オンライン")
から入手できます。
与えられた線形赤黒木から要素を削除する操作を実装することは、読者にとってやりがいのある練習問題でしょう。

")
")

</sect1>#comment("sect1/id=transition_from_datatypes_to_dataviewtypes")

<!-- ****** ****** -->

</chapter><!--id="dataviewtypes"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
