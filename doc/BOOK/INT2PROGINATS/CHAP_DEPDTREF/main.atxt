%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="datatype_refinement">
#langeng("
#title("Datatype Refinement")
")
#langja("
#title("データ型の改良")
")

#langeng("
#para("\

The datatype mechanism in ATS is adopted from ML directly, and it is really
a signatory feature in functional programming. However, the datatypes we
have seen so far are not very precise when employed to classify values. For
instance, given a type T, the type #stacode("list0(T)") is for values
representing both empty and non-empty lists consisting of elements of the
type T. Therefore, empty and non-empty lists cannot be distinguished at the
level of types. This limitation severely diminishes the effectiveness of
datatypes of ML-style in capturing program invariants. In ATS, datatypes of
ML-style can be refined into dependent datatypes of DML-style, where DML
refers to the programming language Dependent ML, the immediate precursor of
ATS. With such refinement, datatypes can classify values with greatly
enhanced precision.\

")#comment("para")
")
#langja("
#para("\

ATS におけるデータ型のメカニズムは ML から直接輸入しています。
関数型プログラミングにおいてこの機能はお墨付きです。
けれども、これまで見てきたデータ型は値を分類するに十分に正確というわけでもありません。
例えば型 T が与えられた時、型 T の要素から成る空のリストと空でないリストを表わす値は両方とも型 #stacode("list0(T)") です。
したがって、空のリストと空でないリストは型レベルで区別がつきません。
プログラムの不変条件を捕捉する ML スタイルのデータ型の有効性が、この制限によってしばしば減少してしまいます。
ATS では、ML スタイルのデータ型は DML スタイルの依存データ型に改良することができます。
この DML とは ATS の祖先であるプログラミング言語 Dependent ML のことです。
このような改良によって、データ型は値をより正確に分類できます。\

")#comment("para")
")

#langeng("
#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_DEPDTREF/", "on-line").

")
")
#langja("
#para("\

この章で紹介するコードと追加のテストコードは
#mycodelink("CHAP_DEPDTREF/", "オンライン")
から入手できます。

")
")

<!-- ****** ****** -->

<sect1
id="dependent_datatypes">
#langeng("
#title("Dependent Datatypes")
")
#langja("
#title("依存データ型")
")

#langeng("
#para("\

The syntax for declaring dependent datatypes is mostly similar to the
syntax for declaring non-dependent datatypes: For instance, the dependent
datatype #stacode("list") in ATS is declared as follows:

#sats2xhtml("\
datatype
list(t@ype+, int) =
  | {a:t@ype} list_nil(a, 0) of () // [of ()] is optional
  | {a:t@ype} {n:nat} list_cons(a, n+1) of (a, list(a, n))
")

More precisely, #stacode("list") is declared as a type constructor of the
sort #emphasis("(t@ype, int) -> type"), which means that #stacode("list")
takes an unboxed type and a static integer to form a boxed type. The
keyword #keycode("t@ype+") indicates that #stacode("list") is covariant at
its first parameter (of the sort #emphasis("t@ype")), that is,
#stacode("list(T1, I)") is considered a subtype of #stacode("list(T2, I)")
if T1 is a subtype of T2.  There is also the keyword #keycode("t@ype-") for
indicating the declared type constructor being contravariant at a
parameter, but it is rarely used in practice. Also, keywords like
#keycode("type+") and #keycode("type-") are interpreted similarly.\

")#comment("para")
")
#langja("
#para("\

依存データ型を宣言する構文は非依存データ型を宣言する構文とほとんど同じです。
例えば、ATS の依存データ型 #stacode("list") は次のように宣言されています:

#sats2xhtml("\
datatype
list(t@ype+, int) =
  | {a:t@ype} list_nil(a, 0) of () // [of ()] is optional
  | {a:t@ype} {n:nat} list_cons(a, n+1) of (a, list(a, n))
")

より正確には、#stacode("list") は種 #emphasis("(t@ype, int) -> type")
の型コンストラクタとして宣言されています。
これは #stacode("list") はアンボックス化型と静的な整数を取りボックス化型を作ることを意味しています。
キーワード #keycode("t@ype+") は、
#stacode("list") が種 #emphasis("t@ype") である最初のパラメータについて共変 (covariant)
であることを示しています。
つまり T1 が T2 のサブタイプであるなら、#stacode("list(T1, I)") は #stacode("list(T2, I)")
のサブタイプであるということになります。
また、宣言された型コンストラクタがパラメータについて反変 (contravariant) であることを示すキーワード
#keycode("t@ype-") も存在しますが、実際にはあまり使われません。
また #keycode("type+") や #keycode("type-") のようなキーワードも同等に解釈されます。\

")#comment("para")
")

#langeng("
#para("\

There two data (or value) constructors #dyncode("list_nil") and
#dyncode("list_cons") associated with #stacode("list"), which are declared to be
of the following types:

#atscode("\
list_nil : {a:t@ype} () -> list(a, 0)
list_cons : {a:t@ype}{n:nat} (a, list(a, n)) -> list(a, n+1)
")

Given a type T and a static integer I, the type #stacode("list(T, I)") is
for values representing lists of length I in which each element is of the
type T. Hence, the types of #dyncode("list_nil") and #dyncode("list_cons")
mean that #dyncode("list_nil") forms a list of length 0 and
#dyncode("list_cons") forms a list of length n+1 if applied to an element
and a list of length n.  Note that it is also possible to declare
#stacode("list") as follows in a more concise style:

#sats2xhtml("\
datatype
list (a:t@ype+, int) =
  | list_nil(a, 0) of () // [of ()] is optional
  | {n:nat} list_cons(a, n+1) of (a, list(a, n))
")

The use of #stacode("a:t@ype+") (instead of #keycode("t@ype+")) introduces
implicitly a universal quantifier over #stacode("a") for the type assigned
to each data constructor associated with the declared type constructor
#stacode("list").\

")#comment("para")
")
#langja("
#para("\

#stacode("list") に関連して、2つのデータコンストラクタ (や値コンストラクタ)
#dyncode("list_nil") と #dyncode("list_cons") があります。
これらは次の型で宣言されています:

#atscode("\
list_nil : {a:t@ype} () -> list(a, 0)
list_cons : {a:t@ype}{n:nat} (a, list(a, n)) -> list(a, n+1)
")

型 T と静的な整数 I が与えられた時、
要素の型が T で長さが I のリストを表現する値は型 #stacode("list(T, I)") です。
ゆえに、型 #dyncode("list_nil") は長さ 0 のリストを、
型 #dyncode("list_cons") は要素と長さ n のリストに適用すると長さ n+1 のリストを作ることを意味しています。
次のようなより簡潔なスタイルで #stacode("list") を宣言することもできることに注意してください:

#sats2xhtml("\
datatype
list (a:t@ype+, int) =
  | list_nil(a, 0) of () // [of ()] is optional
  | {n:nat} list_cons(a, n+1) of (a, list(a, n))
")

#keycode("t@ype+") の代わりに #stacode("a:t@ype+") を使うことで #stacode("a")
の上に全称量化を暗黙的に導入します。
この #stacode("a") は宣言された型コンストラクタ #stacode("list")
に関連するデータコンストラクタに割り当てられた型です。\

")#comment("para")
")

#langeng("
#para("\

As an example of programming with dependent datatypes, the following code
implements a function template for computing the length of a given list:

#dats2xhtml("\
fun{
a:t@ype
} list_length
  {n:nat} .<n>.
  // .<n>. is a termination metric
  (xs: list (a, n)): int (n) = case+ xs of
  | list_nil((*void*)) => 0
  | list_cons(_(*x*), xs1) => 1 + list_length<a>(xs1)
// end of [list_length]
")

The type assigned to the function #dyncode("list_length") indicates that
the function takes a list of length n for any natural number n and returns
an integer of value n. In addition, the function is verified to be
terminating. Therefore, #dyncode("list_length") is guaranteed to implement the
function that computes the length of a given list. I now briefly explain
how typechecking can be performed on the definition of
#dyncode("list_length"). Let us first see that the the following clause
typechecks:

#atscode("\
  | list_cons (_, xs1) => 1 + list_length (xs1)
")

What we need to verify is that the expression on the righthand side of the
symbol #keycode("=>") can be assigned the type #stacode("int(n)") under the
assumption that #dyncode("xs") matches the pattern on the lefthand side of
the symbol #keycode("=>").  Let us assume that #dyncode("xs1") is of the
type #stacode("list(a, n1)") for some natural number #stacode("n1"), and
this assumption implies that the pattern #dyncode("list_cons(_, xs1)") is
of the type #stacode("list(a, n1+1)").  Clearly, matching #dyncode("xs")
against the pattern #dyncode("list_cons(_, xs1)") generates a condition
#stacode("n=n1+1").  It is also clear that #dyncode("list_length(xs1)") is
of the type #stacode("int(n1)") and thus #dyncode("1 + list_length(xs1)")
is of the type #stacode("int(1+n1)"). As the condition #stacode("n=n1+1")
implies #stacode("n=1+n1"), #dyncode("1 + list_length(xs1)") can be given
the type #stacode("int(n)"). So this clause typechecks.  Note that matching
#dyncode("xs") against the pattern #dyncode("list_nil()") generates the
assumption #stacode("n=0"), which implies that #stacode("0") is of the type
#stacode("int(n)"). Therefore, the following clause typechecks:
")
")
#langja("
#para("\

依存データ型を用いたプログラミングの例として、次のコードは与えられたリストの長さを算出する関数テンプレートを実装しています:

#dats2xhtml("\
fun{
a:t@ype
} list_length
  {n:nat} .<n>.
  // .<n>. is a termination metric
  (xs: list (a, n)): int (n) = case+ xs of
  | list_nil () => 0
  | list_cons (_, xs1) => 1 + list_length (xs1)
// end of [list_length]
")

関数 #dyncode("list_length") の型は自然数 n 長さのリストを取り、整数の値 n を返すことを示しています。
加えて、この関数は停止することが検査されています。
したがって、#dyncode("list_length")
が与えられたリストの長さを計算する関数を実装していることが保証されています。
#dyncode("list_length") の定義に対する型検査がどのように行なわれるのか簡単に説明してみます。
はじめに次の節の型検査を見てみましょう:

#atscode("\
  | list_cons (_, xs1) => 1 + list_length (xs1)
")

私達が検査しなければならないのは、#dyncode("xs") 記号 #keycode("=>")
の左側にあるパターンにマッチすると仮定して、記号 #keycode("=>")
の右側にある式に型 #stacode("int(n)") を割り当てることができるかどうかです。
自然数  #stacode("n1") について #dyncode("xs1") の型が #stacode("list(a, n1)") だと仮定してみましょう。
この仮定はパターン #dyncode("list_cons(_, xs1)") は型 #stacode("list(a, n1+1)") であることを意味します。
#dyncode("xs") がパターン #dyncode("list_cons(_, xs1)") にマッチすることから、#stacode("n=n1+1") は明確です。
#dyncode("list_length(xs1)") の型が #stacode("int(n1)") であり、したがって  #dyncode("1 + list_length(xs1)")
の型が #stacode("int(1+n1)") であることもまた明確です。
#stacode("n=n1+1") であれば #stacode("n=1+n1") であるので、
#dyncode("1 + list_length(xs1)") には型 #stacode("int(n)") が与えられることになります。
この節の型検査はこのようになりました。
パターン #dyncode("list_nil()") に #dyncode("xs") がマッチする場合、#stacode("n=0")
を仮定できることに注意してください。
この仮定は #stacode("0") が型 #stacode("int(n)") であることを示しています。
したがって、次の節が型検査できました:
")
")

#atscode("\
  | list_nil((*void*)) => 0
")

#langeng("
#para("\

Given that the two clauses typecheck properly, the case-expression
containing them can be assigned the type #stacode("int(n)"). Therefore, the
definition of #dyncode("list_length") typechecks.\

")#comment("para")
")
#langja("
#para("\

与えられた2つの節の型検査がおわれば、それらを含む case 式には型 #stacode("int(n)") を割り当てることができます。
したがって #dyncode("list_length") の定義が型検査できました。\

")#comment("para")
")

#langeng("
#para('\

As the recursive call in the body of the above defined function
#dyncode("list_length") is not a tail-call, the function may not be able to
handle a long list (e.g., one that contains 1 million elements).  The
following code gives another implementation for computing the length of a
given list:

')
")
#langja("
#para('\

上記で定義されている関数 #dyncode("list_length") の本体での再帰呼出は末尾呼出ではないため、この関数は
(例えば100万個の要素を持つような) 長いリストを扱うことができません。
次のコードは与えられたリストの長さを計算する別の実装です:

')
")

#dats2xhtml('\
fun{
a:t@ype
} list_length{n:nat} .<>.
  (xs: list (a, n)): int (n) = let
  // loop: {i,j:nat} (list (a, i), int (j)) -> int (i+j)
  fun loop {i,j:nat} .<i>.
    // .<i>. is a termination metric
    (xs: list (a, i), j: int j): int (i+j) = case+ xs of
    | list_cons (_, xs1) => loop (xs1, j+1) | list_nil () => j
  // end of [loop]
in
  loop (xs, 0)
end // end of [list_length]
')

#langeng("
#para('\

This time, #dyncode("list_length") is based on a tail-recursive function
#dyncode("loop") and thus can handle lists of any length in constant stack
space. Note that the type assigned to #dyncode("loop") indicates that
#dyncode("loop") takes a list of length i and an integer of value j for some
natural numbers i and j and returns an integer of value i+j. Also,
#dyncode("loop") is verified to be terminating.

')#comment("para")
")
#langja("
#para('\

このとき #dyncode("list_length") は末尾再帰関数 #dyncode("loop") を使っています。
そのためどのような長さのリストも一定のスタック量で扱うことができます。
#dyncode("loop") の型は、自然数 i と j について #dyncode("loop") が長さ i のリストと値 j の整数を取り、値
i+j の整数を返すことを示していることに注意してください。
また #dyncode("loop") が停止することは検査済みです。

')#comment("para")
")

#langeng("
#para('\

There is also a dependent datatype #stacode("option") in ATS for forming
optional values:

')
")
#langja("
#para('\

ATS ではオプション値を成す依存データ型 #stacode("option") もまた存在します:

')
")

#sats2xhtml('\
datatype
option(a:t@ype+, bool) =
  | Some (a, true) of a | None (a, false) of ()
// end of [option]
')

#langeng("
#para('\

As an example, the following function template #dyncode("list_last") tries to
find the last element in a given list:

')
")
#langja("
#para('\

例として、
次の関数テンプレート #dyncode("list_last") は与えられたリストの最後の要素を探します:

')
")

#dats2xhtml('\
fun{
a:t@ype
} list_last
  {n:nat} .<>.
(
  xs: list (a, n)
) : option (a, n > 0) = let
//
fun loop
  {n:pos} .<n>.
(
  xs: list (a, n)
) : a = let
  val+ list_cons (_, xs1) = xs
in
  case+ xs1 of
  | list_cons _ => loop (xs1)
  | list_nil () => let
      val+ list_cons (x, _) = xs in x
    end // end of [list_nil]
end // end of [loop]
//
in
  case+ xs of
  | list_cons _ => Some (loop (xs)) | list_nil () => None ()
end // end of [list_last]
')

#langeng("
#para('\

The inner function #dyncode("loop") is evidently tail-recursive and it is
verified to be terminating.

')
")
#langja("
#para('\

内部の関数 #dyncode("loop") は明らかに末尾再帰であり、停止することは検査済みです。

')
")

#langeng("
#para('\

After a programmer becomes familar with #stacode("list") and
#stacode("option"), there is little incentive for him or her to use
#stacode("list0") and #stacode("option0") anymore. Internally, values of
#stacode("list") and #stacode("list0") have exactly the same representation and
there are cast functions of zero run-time cost in ATS for translating
between values of #stacode("list") and #stacode("list0").  The same applies
to values of #stacode("option") and #stacode("option0") as well.

')
")
#langja("
#para('\

プログラマは #stacode("list") と #stacode("option") に慣れ親しんだ後
#stacode("list0") と #stacode("option0") を使う動機はほとんどないでしょう。
内部では、#stacode("list") と #stacode("list0") の値は全く同じ表現を持ちます。
さらに #stacode("list") と #stacode("list0") の値を相互変換するキャスト関数が ATS にはあります。
#stacode("option") と #stacode("option0") の値についても同様です。

')
")

</sect1><!--id="dependent_datatypes"-->

<!-- ****** ****** *-->

<sect1
id="example_function_templates_on_lists_redux">
#langeng("
#title("Example: Function Templates on Lists (Redux)")
")
#langja("
#title("例: リストに対する関数テンプレート (再)")
")

#langeng("
#para("\

I have presented previously implementation of some commonly used function
templates on lists formed with the constructors #dyncode("list0_nil") and
#dyncode("list0_cons"). This time, I present as follows implementation of
the corresponding function templates on lists formed with the constructors
#dyncode("list_nil") and #dyncode("list_cons"), which make it possible to
assign more accurate types to these templates.

")
")
#langja("
#para("\

コンストラクタ #dyncode("list0_nil") と #dyncode("list0_cons")
で作られるリストに対する関数テンプレートを使った一般的な実装を以前紹介しました。
ここでは、コンストラクタ #dyncode("list_nil") と #dyncode("list_cons")
で作られるリストに対する関数テンプレートを次のように実装します。
この実装によってこれらのテンプレートにより正確な型を割り当てることができます。

")
")

#langeng("
#para("\
Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DEPDTREF/listfuns.dats", "on-line").
")
")
#langja("
#para("\
この章のコード全体とテストのための追加コードは
#mycodelink("CHAP_DEPDTREF/listfuns.dats", "オンライン")
から入手できます。
")
")

<sect2 id="list_append">
#langeng("
#title("Appending: #dyncode("list_append")")
")
#langja("
#title("連結: #dyncode("list_append")")
")

#langeng("
#para("\

Given two lists xs and ys of the types #stacode("list(T, I1)") and
#stacode("list(T, I2)") for some type T and integers I1 and I2,
#dyncode("list_append(xs, ys)") returns a list of the type
#stacode("list(T,I1+I2)") that is the concatenation of xs and ys:

#dats2xhtml("\
fun{
a:t@ype
} list_append
  {m,n:nat} .<m>.
(
  xs: list (a, m), ys: list(a, n)
) : list (a, m+n) =
(
  case+ xs of
  | list_nil() => ys
  | list_cons(x, xs) => list_cons(x, list_append<a>(xs, ys))
) (* end of [list_append] *)
")

Clearly, this implementation of #dyncode("list_append") is not
tail-recursive.\

")#comment("para")
")
#langja("
#para("\

型 T と整数 I1 と I2 があり、2つのリスト xs と ys が型 #stacode("list(T, I1)") と #stacode("list(T, I2)")
で与えられた時、#dyncode("list_append(xs, ys)") は xs と ys を連結した型 #stacode("list(T,I1+I2)")
のリストを返します:

#dats2xhtml("\
fun{
a:t@ype
} list_append
  {m,n:nat} .<m>.
(
  xs: list (a, m), ys: list(a, n)
) : list (a, m+n) =
(
  case+ xs of
  | list_nil() => ys
  | list_cons(x, xs) => list_cons(x, list_append<a>(xs, ys))
) (* end of [list_append] *)
")

#dyncode("list_append") のこの実装が末尾再帰でないことは明確です。\

")#comment("para")
")

</sect2><!--id="list_append"-->

<sect2 id="list_reverse_append">
#langeng("
#title("Reverse Appending: #dyncode("list_reverse_append")")
")
#langja("
#title("逆順連結: #dyncode("list_reverse_append")")
")

#langeng("
#para("\

Given two lists xs and ys of the type #stacode("list(T, I1)") and
#stacode("list(T, I2)") for some type T and integers I1 and I2,
#dyncode("list_reverse_append(xs, ys)") returns a list of the type
#stacode("list(T, I1+I2)") that is the concatenation of the reverse of xs
and ys:

#dats2xhtml("\
fun{
a:t@ype
} list_reverse_append
  {m,n:nat} .<m>.
(
  xs: list(a, m)
, ys: list(a, n)
) : list(a, m+n) =
(
  case+ xs of
  | list_nil () => ys
  | list_cons (x, xs) =>
      list_reverse_append<a>(xs, list_cons(x, ys))
) (* end of [list_reverse_append] *)
")

Clearly, this implementation of #dyncode("list_reverse_append") is
tail-recursive.\

")#comment("para")
")
#langja("
#para("\

型 T と整数 I1 と I2 があり、2つのリスト xs と ys が型 #stacode("list(T, I1)") と #stacode("list(T, I2)")
で与えられた時、#dyncode("list_reverse_append(xs, ys)") は xs と ys を逆順にして連結した型
#stacode("list(T, I1+I2)") のリストを返します:

#dats2xhtml("\
fun{
a:t@ype
} list_reverse_append
  {m,n:nat} .<m>.
(
  xs: list(a, m)
, ys: list(a, n)
) : list(a, m+n) =
(
  case+ xs of
  | list_nil () => ys
  | list_cons (x, xs) =>
      list_reverse_append<a>(xs, list_cons(x, ys))
) (* end of [list_reverse_append] *)
")

#dyncode("list_reverse_append") のこの実装が末尾再帰であることは明確です。\

")#comment("para")
")

</sect2><!--id="list_reverse_append"-->

<sect2 id="list_reverse">
#langeng("
#title("Reversing: #dyncode("list_reverse")")
")
#langja("
#title("逆順: #dyncode("list_reverse")")
")

#langeng("
#para("\

Given a list xs, #dyncode("list_reverse(xs)") returns the reverse of xs,
which is of the same length as xs:

#dats2xhtml("\
fun{a:t@ype}
list_reverse{n:nat} .<>. // defined non-recursively
  (xs: list(a, n)): list(a, n) = list_reverse_append<a>(xs, list_nil())
// end of [list_reverse]
")
")#comment("para")
")
#langja("
#para("\

リスト xs が与えられた時、#dyncode("list_reverse(xs)") は xs の逆順を返します。
この返値は xs と同じ長さになります:

#dats2xhtml("\
fun{a:t@ype}
list_reverse{n:nat} .<>. // defined non-recursively
  (xs: list (a, n)): list (a, n) = list_reverse_append (xs, list_nil)
// end of [list_reverse]
")
")#comment("para")
")

</sect2><!--id="list_reverse"-->

<sect2 id="list_map">
#langeng("
#title("Mapping: #dyncode("list_map")")
")
#langja("
#title("マップ: #dyncode("list_map")")
")

#langeng("
#para("\

Given a list xs of the type #stacode("list(T1, I)") for some type T1 and
integer I and a closure function f of the type #stacode("T1 -&lt;cloref1&gt; T2")
for some T2, #dyncode("list_map(xs)") returns a list ys of the type #stacode("list(T2, I)"):

#dats2xhtml("\
fun{
a:t@ype}
{b:t@ype
} list_map
  {n:nat} .<n>.
(
  xs: list (a, n), f: a -<cloref1> b
) : list (b, n) =
(
  case+ xs of
  | list_nil() => list_nil()
  | list_cons(x, xs) => list_cons(f x, list_map<a>(xs, f))
) (* end of [list_map] *)
")

Each element y in ys equals f(x), where x is the corresponding element in
xs.  Clearly, this implementation of #dyncode("list_map") is not
tail-recursive.\

")#comment("para")
")
#langja("
#para("\

型 T1, T2 と整数 I があり、型 #stacode("list(T1, I)") のリスト xs
と型 #stacode("T1 -&lt;cloref1&gt; T2") のクロージャ関数 f が与えられた時、#dyncode("list_map(xs)")
は型 #stacode("list(T2, I)") のリスト ys を返します:

#dats2xhtml("\
fun{
a:t@ype}
{b:t@ype
} list_map
  {n:nat} .<n>.
(
  xs: list (a, n), f: a -<cloref1> b
) : list (b, n) =
(
  case+ xs of
  | list_nil() => list_nil()
  | list_cons(x, xs) => list_cons(f x, list_map<a>(xs, f))
) (* end of [list_map] *)
")

ys のそれぞれの要素 y は、xs の対応する要素を x とすれば f(x) に等しいことになります。
#dyncode("list_map") のこの実装が末尾再帰でないことは明確です。\

")#comment("para")
")

</sect2><!--id="list_map"-->

<sect2 id="list_zip">
#langeng("
#title("Zipping: #dyncode("list_zip")")
")
#langja("
#title("zip関数: #dyncode("list_zip")")
")

#langeng("
#para("\

Given two lists xs and ys of the types #stacode("list(T1, I)") and
#stacode("list(T2, I)") for some types T1 and T2 and integer I, respectively,
#dyncode("list_zip(xs, ys)") returns a list zs of the type #stacode("list((T1,T2), I)").

#dats2xhtml("\
fun{
a,b:t@ype
} list_zip
  {n:nat} .<n>.
(
  xs: list (a, n), ys: list (b, n)
) : list ((a, b), n) =
(
  case+ (xs, ys) of
  | (
      list_nil()
    , list_nil()
    ) => list_nil((*void*))
  | (
      list_cons (x, xs)
    , list_cons (y, ys)
    ) => list_cons((x, y), list_zip<a,b>(xs, ys))
) (* end of [list_zip] *)
")

Each element z in zs equals the pair (x, y), where x and y are the
corresponding elements in xs and ys, respectively.  Clearly, this
implementation of #dyncode("list_zip") is not tail-recursive.\

")#comment("para")
")
#langja("
#para("\

型 T1, T2 と整数 I があり、型 #stacode("list(T1, I)") と #stacode("list(T2, I)") のリスト xs と ys
がそれぞれ与えられた時、#dyncode("list_zip(xs, ys)") は型 #stacode("list((T1,T2), I)")
のリスト zs を返します。

#dats2xhtml("\
fun{
a,b:t@ype
} list_zip
  {n:nat} .<n>.
(
  xs: list (a, n), ys: list (b, n)
) : list ((a, b), n) =
(
  case+ (xs, ys) of
  | (
      list_nil()
    , list_nil()
    ) => list_nil((*void*))
  | (
      list_cons (x, xs)
    , list_cons (y, ys)
    ) => list_cons((x, y), list_zip<a,b>(xs, ys))
) (* end of [list_zip] *)
")

zs のそれぞれの要素 z は、xs と ys の対応する要素をそれぞれ x と y とすれば、ペア (x, y)
に等しいことになります。#dyncode("list_zip") のこの実装が末尾再帰でないことは明確です。\

")#comment("para")
")

</sect2><!--id="list_zip"-->

<sect2 id="list_zipwith">
#langeng("
#title("Zipping with: #dyncode("list_zipwith")")
")
#langja("
#title("zip with関数: #dyncode("list_zipwith")")
")

#langeng("
#para("\

Given two lists xs and ys of the types #stacode("list(T1, I)") and
#stacode("list(T2, I)") for some types T1 and T2 and integer I,
respectively, and a closure function f of the type #stacode("(T1, T2)
-&lt;cloref1&gt; T3") for some type T3, #dyncode("list_zipwith(xs, ys, f)")
returns a list zs of the type #stacode("list(T3, I)"):

#dats2xhtml("\
fun{
a,b:t@ype
}{c:t@ype
} list_zipwith
  {n:nat} .<n>.
(
  xs: list (a, n)
, ys: list (b, n)
, f: (a, b) -<cloref1> c
) : list (c, n) =
(
  case+ (xs, ys) of
  | (
      list_nil()
    , list_nil()
    ) => list_nil((*void*))
  | (
      list_cons(x, xs)
    , list_cons(y, ys)
    ) =>
      list_cons(f(x, y), list_zipwith<a,b><c>(xs, ys, f))
     // end of (list_cons, list_cons)
) (* end of [list_zipwith] *)
")

Each element z in zs equals f(x, y), where x and y are the corresponding
elements in xs and ys, respectively.  Clearly, this implementation of
#dyncode("list_zipwith") is not tail-recursive.
")#comment("para")
")
#langja("
#para("\

型 T1, T2, T3 と整数 I があり、2つのリスト xs と ys がそれぞれ型 #stacode("list(T1, I)") と
#stacode("list(T2, I)") で、クロージャ関数 f が型 #stacode("(T1, T2) -&lt;cloref1&gt; T3")
で与えられた時、#dyncode("list_zipwith(xs, ys, f)") は型 #stacode("list(T3, I)") のリスト zs を返します:

#dats2xhtml("\
fun{
a,b:t@ype
}{c:t@ype
} list_zipwith
  {n:nat} .<n>.
(
  xs: list (a, n)
, ys: list (b, n)
, f: (a, b) -<cloref1> c
) : list (c, n) =
(
  case+ (xs, ys) of
  | (
      list_nil()
    , list_nil()
    ) => list_nil((*void*))
  | (
      list_cons(x, xs)
    , list_cons(y, ys)
    ) =>
      list_cons(f(x, y), list_zipwith<a,b><c>(xs, ys, f))
     // end of (list_cons, list_cons)
) (* end of [list_zipwith] *)
")

zs のそれぞれの要素 z は、xs と ys の対応する要素をそれぞれ x と y とすれば、f(x, y) に等しいことになります。
#dyncode("list_zipwith") のこの実装が末尾再帰でないことは明確です。
")#comment("para")
")

</sect2><!--id="list_zipping_with"-->

</sect1><!--id="example_function_templates_on_lists_redux"-->

<!-- ****** ****** -->

<sect1 id="example_mergesort_redux">
#langeng("
#title("Example: Mergesort on Lists (Redux)")
")
#langja("
#title("例: リストのマージソート (再)")
")

#langeng("
#para('\

I have previously presented an <xref linkend="example_mergesort"/>
that are formed with the constructors #dyncode("list0_nil") and
#dyncode("list0_cons").  In this section, I give an implementation of
mergesort on lists formed with the constructors #dyncode("list_nil") and
#dyncode("list_cons"). This implementation is based on the same algorithm
as the previous one but it assigns a type to the implemented sorting
function that guarantees the function to be length-preserving, that is, the
function always returns a list of the same length as the list it sorts.

')#comment("para")
")
#langja("
#para('\

以前の章 <xref linkend="example_mergesort"/>
でコンストラクタ #dyncode("list0_nil") と #dyncode("list0_cons") を使ってリストのマージソートを実装しました。
この章では コンストラクタ #dyncode("list_nil") と #dyncode("list_cons")
を使ってリストのマージソートを実装します。
この実装は以前の章と同じアルゴリズムを用いています。
しかし、長さを保持するよう関数を保証するために、実装したソート関数に型を割り当てます。
つまり、この関数はソートする前のリストと同じ長さのリストを常に返します。

')#comment("para")
")

#langeng("
#para("\
The following defined function #dyncode("merge") combines two
ordered list (according to a given ordering) into a single ordered list:

#dats2xhtml("\
//
typedef lte (a:t@ype) = (a, a) -> bool
//
fun{
a:t@ype
} merge
  {m,n:nat} .<m+n>.
(
  xs0: list (a, m), ys0: list (a, n), lte: lte a
) : list (a, m+n) =
  case+ xs0 of
  | list_nil() => ys0
  | list_cons(x, xs1) =>
    (
    case+ ys0 of
    | list_nil() => xs0
    | list_cons(y, ys1) =>
        if x \\\\lte y
          then list_cons (x, merge (xs1, ys0, lte))
          else list_cons (y, merge (xs0, ys1, lte))
        // end of [if]
    ) // end of [list_cons]
// end of [merge]
//
")

Clearly, the type assigned to #dyncode("merge") indicates that the function
returns a list whose length equals the sum of the lengths of the two input
lists. Note that a termination metric is present for verifying that
#dyncode("merge") is a terminating function.\

")#comment("para")
")
#langja("
#para("\
次に定義する関数 #dyncode("merge") は2つの整列済みリストを連結して1つの整列済みリストにします:

#dats2xhtml("\
//
typedef lte (a:t@ype) = (a, a) -> bool
//
fun{
a:t@ype
} merge
  {m,n:nat} .<m+n>.
(
  xs0: list (a, m), ys0: list (a, n), lte: lte a
) : list (a, m+n) =
  case+ xs0 of
  | list_nil() => ys0
  | list_cons(x, xs1) =>
    (
    case+ ys0 of
    | list_nil() => xs0
    | list_cons(y, ys1) =>
        if x \\\\lte y
          then list_cons (x, merge (xs1, ys0, lte))
          else list_cons (y, merge (xs0, ys1, lte))
        // end of [if]
    ) // end of [list_cons]
// end of [merge]
//
")

#dyncode("merge") に割り当てられている型は、入力された2つのリストの長さの和と等しい長さのリストをこの関数が返すことを明確に示しています。
停止性メトリクスが #dyncode("merge") が停止する関数であることを検査していることに注意してください。\

")#comment("para")
")

#langeng("
#para("\

The following defined function #dyncode("mergesort") mergesorts a
list according to a given ordering:

#dats2xhtml("\
fun{
a:t@ype
} mergesort{n:nat}
(
  xs: list (a, n), lte: lte a
) : list (a, n) = let
//
  fun msort
    {n:nat} .<n,n>.
  (
    xs: list (a, n), n: int n, lte: lte a
  ) : list (a, n) =
    if n >= 2
      then split (xs, n, lte, half(n), list_nil) else xs
    // end of [if]
  // end of [msort]
  and split
    {n:int | n >= 2}{i:nat | i <= n/2} .<n,i>.
  (
    xs: list (a, n-n/2+i)
  , n: int n, lte: lte a, i: int i, xsf: list (a, n/2-i)
  ) : list (a, n) =
    if i > 0 then let
      val+ list_cons (x, xs) = xs
    in
      split (xs, n, lte, i-1, list_cons (x, xsf))
    end else let
      val n2 = half(n)
      val xsf = list_reverse<a> (xsf) // make sorting stable!
      val xsf = list_of_list_vt (xsf) // linear list -> nonlinear list
      val xsf = msort (xsf, n2, lte) and xs = msort (xs, n-n2, lte)
    in
      merge (xsf, xs, lte)
    end // end of [if]
  // end of [split]
//
in
  msort(xs, list_length<a>(xs), lte)
end // end of [mergesort]
")

The type assigned to #dyncode("mergesort") indicates that
#dyncode("mergesort") returns a list of the same length as its input list.
The two inner functions #dyncode("msort") and #dyncode("split") are
defined mutually recursively, and the termination metrics for them are
pairs of natural numbers that are compared according to the standard
lexicographic ordering on integer sequences. The type assigned to
#dyncode("msort") clearly indicates that its integer argument is required
to be the length of its list argument, and a mismatch between the two
surely results in a type-error.  The type assigned to #dyncode("split") is
particularly informative, depicting a relation between the arguments and
the return value of the function that can be of great help for someone
trying to understand the code.  The function #dyncode("list_reverse")
returns a linear list that is the reverse of its input, and the cast
function #dyncode("list_of_list_vt") turns a linear list into a nonlinear
one (while incuring no cost at run-time). I will explain what linear lists
are elsewhere.\

")#comment("para")
")
#langja("
#para("\

次に定義する関数 #dyncode("mergesort") は与えられた順序付けでリストをマージソートします:

#dats2xhtml("\
fun{
a:t@ype
} mergesort{n:nat}
(
  xs: list (a, n), lte: lte a
) : list (a, n) = let
//
  fun msort
    {n:nat} .<n,n>.
  (
    xs: list (a, n), n: int n, lte: lte a
  ) : list (a, n) =
    if n >= 2
      then split (xs, n, lte, half(n), list_nil) else xs
    // end of [if]
  // end of [msort]
  and split
    {n:int | n >= 2}{i:nat | i <= n/2} .<n,i>.
  (
    xs: list (a, n-n/2+i)
  , n: int n, lte: lte a, i: int i, xsf: list (a, n/2-i)
  ) : list (a, n) =
    if i > 0 then let
      val+ list_cons (x, xs) = xs
    in
      split (xs, n, lte, i-1, list_cons (x, xsf))
    end else let
      val n2 = half(n)
      val xsf = list_reverse<a> (xsf) // make sorting stable!
      val xsf = list_of_list_vt (xsf) // linear list -> nonlinear list
      val xsf = msort (xsf, n2, lte) and xs = msort (xs, n-n2, lte)
    in
      merge (xsf, xs, lte)
    end // end of [if]
  // end of [split]
//
in
  msort(xs, list_length<a>(xs), lte)
end // end of [mergesort]
")

#dyncode("mergesort") に割り当てられた型は
#dyncode("mergesort") が入力されたリストと同じ長さのリストを返すことを示しています。
2つの内部関数 #dyncode("msort") と #dyncode("split") は相互再帰的に定義されています。
そしてそれらの停止性メトリクスは自然数のペアで、整数列は標準の辞書順で比較されます。
#dyncode("msort") に割り当てられた型は、リスト引数の長さのために整数引数が必要であることを示しています。
これら2つの整数が一致しないと型エラーを引き
起こします。
#dyncode("split") に割り当てられた型は特に有益です。
この関数の引数と返値の間の関係を表わしていて、コードを理解しようとする人の助けになるでしょう。
関数 #dyncode("list_reverse") は入力を逆順にした線形リストを返します。
キャスト関数 #dyncode("list_of_list_vt") は線形リストを非線形のリストに変換します。
この変換では実行時のコストは発生しません。
線形リストついては別の章で解説します。\

")#comment("para")
")

#langeng("
#para("\
Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAP_DEPDTREF/mergesort.dats", "on-line").
")
")
#langja("
#para("\
この章のコード全体と追加のテストコードは
#mycodelink("CHAP_DEPDTREF/mergesort.dats", "オンライン")
から入手できます。
")
")

</sect1><!--id="example_mergesort_redux"-->

<!-- ****** ****** -->

<sect1
id="sequentiality_of_pattern_matching"
>
#langeng("
#title("Sequentiality of Pattern Matching")
")
#langja("
#title("パターンマッチの連続性")
")

#langeng("
#para("\

In ATS, pattern matching is performed sequentially at run-time. In other
words, a clause is selected only if a given value matches the pattern
guard associated with this clause but the value fails to match the pattern
associated with any clause ahead of it. Naturally, one may expect that the
following implementation of #dyncode("list_zipwith") also typechecks:

#dats2xhtml("\
fun{
a,b:t@ype
}{c:t@ype
} list_zipwith
  {n:nat}
(
  xs: list(a, n)
, ys: list(b, n)
, f: (a, b) -<cloref1> c
) : list(c, n) = (
//
case+ (xs, ys) of
| (
    list_cons(x, xs)
  , list_cons(y, ys)) =>
  (
    list_cons(f(x, y), list_zipwith<a,b><c>(xs, ys, f))
  )
| (_, _) => list_nil((*void*))
//
) (* end of [list_zipwith] *)
")

This, however, is not the case. In ATS, typechecking clauses is done
nondeterministically (rather than sequentially). In this example, the
second clause fails to typecheck as it is done without the assumption of
the given pair #dyncode("(xs, ys)") failing to match the pattern
guard associated with the first clause.  The second clause can be modified
slightly as follows to pass typechecking:

#atscode("\
  | (_, _) =>> list_nil((*void*))
")

The use of the symbol #keycode("=>>") (in place of #keycode("=>"))
indicates to the typechecker that this clause needs to be typechecked under
the sequentiality assumption that the given value matching it does not
match the pattern guards associated with any previous clauses. Therefore,
when the modified second clause is typechecked, it can be assumed that the
pair #dyncode("(xs, ys)") matching the pattern #dyncode("(_, _)") must
match one of the following three patterns:

<itemizedlist>

<listitem>
#para("
#dyncode("(list_cons _, list_nil ())")
")
</listitem>

<listitem>
#para("
#dyncode("(list_nil (), list_cons _)")
")
</listitem>

<listitem>
#para("
#dyncode("(list_nil (), list_nil ())")
")
</listitem>

</itemizedlist>

Given that #dyncode("xs") and #dyncode("ys") are of the same length,
the typechecker can readily infer that #dyncode("(xs, ys)") cannot match
either of the first two patterns. After these two patterns are ruled out,
typechecking is essentially done as if the second clause was written as follows:

#atscode("\
  | (list_nil(), list_nil()) => list_nil((*void*))
")

")#comment("para")
")
#langja("
#para("\

ATS では、パターンマッチは実行時において連続して評価されます。
別の言い方をすると、節が選択されるのは与えられた値がその節に関連するパターンガードにマッチし、しかも値がその前にあるどの節のパターンにもマッチしない場合にだけです。
当然、#dyncode("list_zipwith") 次の実装も型検査できると期待するでしょう:

#dats2xhtml("\
fun{
a,b:t@ype
}{c:t@ype
} list_zipwith
  {n:nat}
(
  xs: list(a, n)
, ys: list(b, n)
, f: (a, b) -<cloref1> c
) : list(c, n) = (
//
case+ (xs, ys) of
| (
    list_cons(x, xs)
  , list_cons(y, ys)) =>
  (
    list_cons(f(x, y), list_zipwith<a,b><c>(xs, ys, f))
  )
| (_, _) => list_nil((*void*))
//
) (* end of [list_zipwith] *)
")

けれども、この場合は型検査に失敗します。
ATS では、節の型検査は(連続的と言うよりむしろ)非決定的です。
この例では、2番目の節が型検査に失敗します。
与えられたペア #dyncode("(xs1, xs2)") が最初の節のパターンガードへのマッチに失敗することが仮定されていないからです。
次のように少し修正することで2番目の節は型検査を通ります:

#atscode("\
  | (_, _) =>> list_nil ()
")

記号 #keycode("=>") の代わりに #keycode("=>>") を使うと、その前のいずれの節のパターンガードにもマッチしなかったという連続的な仮定において、この節が型検査されるべきであると、型検査器に指示します。
したがって、修正された2番目の節が型検査されると、パターン #dyncode("(_, _)") にマッチするペア
#dyncode("(xs1, xs2)") は次の2つのパターンのにマッチするはずだということが仮定できます:

<itemizedlist>

<listitem>
#para("
#dyncode("(list_cons (_, _), list_nil ())")
")
</listitem>

<listitem>
#para("
#dyncode("(list_nil (), list_cons (_, _))")
")
</listitem>

<listitem>
#para("
#dyncode("(list_nil (), list_nil ())")
")
</listitem>

</itemizedlist>

同じ長さの #dyncode("xs1") と #dyncode("xs2") が与えられた時、
型検査器は #dyncode("(xs1, xs2)") は最初の2パターンにマッチしないとたやすく推論できます。
これら2パターンが除外されたら、2番目の節が次のように書かれていることになり、
型検査は本質的に終わったとことになります:

#atscode("\
  | (list_nil (), list_nil ()) => list_nil ()
")

")#comment("para")
")

#langeng("
#para("\

One may be wondering why typechecking clauses is not required to be
done sequentially by default. The simple reason is that this requirement,
if fully enforced, can have a great negative impact on the efficiency of
typechecking. Therefore, it is a reasonable design to provide the
programmer with an explict means to occasionally make use of the
sequentiality assumption needed for typechecking a particular clause.
")
")
#langja("
#para("\

なぜ節の型検査がデフォルトで連続的に行なわれないのか気にするかもしれません。
その単純な理由は、全体に適用すると型検査の効率に大きなマイナスの影響があるからです。
したがって、特定の節の型検査に連続的な仮定を時々使うための明確な手段をプログラマに提供するのは、妥当なデザインなのです。
")
")

</sect1><!--id="sequentiality_of_pattern_matching"-->

<!-- ****** ****** -->

<sect1
id="example_fun_red-black_trees"
xreflabel="implementation of functional red-black trees"
>
#langeng("
#title("Example: Functional Red-Black Trees")
")
#langja("
#title("例: 関数的な赤黒木")
")

#langeng("
#para('\

A red-black tree is defined as a binary tree such that each node in it is
colored red or black and every path from the root to a leaf has the same
number of black nodes while containing no occurrences of two red nodes in a
row.  Clearly, the length of a longest path in each red-black tree is
bounded by 2 times the length of a shortest path in it. Therefore,
red-black trees are a family of balanced trees. The number of black nodes
occurring on each path in a red-black tree is often referred to as the
#emphasis("black height") of the tree.

')
")
#langja("
#para('\

赤黒木は、それぞれのノードが赤もしくは黒であり、根からそれぞれの葉までのパスが同じ数の黒ノードを持ち、1つの列に赤ノードが2つ連続しないような二分木として定義されます。
明確に、赤黒木の最も長いパスの長さはその木の最も短かいパスの長さの2倍が限界です。
したがって、赤黒木は平衡木の一種です。
赤黒木のそれぞれのパス黒ノードの数はしばしばその木の #emphasis("黒高さ (black height)") と呼ばれます。

')
")

#langeng("
#para('\

Formally, a datatype precisely for red-black trees can be declared in ATS
as follows:

')
")
#langja("
#para('\

形式的に、赤黒木のデータ型は ATS では次のように宣言できます:

')
")

#sats2xhtml('\
//
\#define BLK 0
\#define RED 1
sortdef clr = {c:nat | c <= 1}
//
datatype rbtree
  (a:t@ype+, int(*clr*), int(*bh*)) =
  | rbtree_nil (a, BLK, 0)
  | {c,cl,cr:clr | cl <= 1-c; cr <= 1-c} {bh:nat}
    rbtree_cons (a, c, bh+1-c) of (int c, rbtree (a, cl, bh), a, rbtree (a, cr, bh))
// end of [rbtree]
//
')

#langeng("
#para('\

The color of a tree is the color of its root node or is black if the tree
is empty.  Given a type T, a color C (represented by a integer) and an
integer BH, the type #stacode("rbtree(T, C, BH)") is for red-black trees
carrying elements of the type T that is of the color C and the black height
BH.

')
")
#langja("
#para('\

木の色は、その木が空であれば根ノードの色は黒になります。
型 T と整数で表わされる色  C と整数 BH が与えられた時、型 #stacode("rbtree(T, C, BH)")
は色 C で黒高さ BH で型 T の要素を持つような赤黒木を表わします。

')
")

#langeng("
#para('\

When implementing various operations (such as insertion and deletion) on a
red-black tree, we often need to first construct intermediate trees that
contain color violations caused by a red node being followed by another red
node and then employ tree rotations to fix such violations. This need makes
the above datatype #stacode("rbtree") too rigid as it cannot be assigned to
any intermediate trees containing color violations. To address this issue,
we can declare #stacode("rbtree") as follows:

')
")
#langja("
#para('\

赤黒木に対する (挿入や削除のような) 様々な操作を実装する際、
はじめに赤ノードの連続を許すような色の違反を含む中間生成の木をコンストラクトする必要がしばしばあります。
それからそのような違反を修正するために木を回転させるのです。
このためには上記のデータ型 #stacode("rbtree") は厳格すぎます。
色が違反するようなどんな中間生成した木にも型を割り当てられないのです。
この問題に対処するために、次のような #stacode("rbtree") を宣言しましょう:

')
")

#sats2xhtml('\
//
datatype rbtree
(
  a:t@ype+
, int // color
, int // black height
, int // violations
) = // rbtree
  | rbtree_nil (a, BLK, 0, 0) of ()
  | {c,cl,cr:clr}{bh:nat}{v:int}
      {c==BLK && v==0 || c == RED && v==cl+cr}
    rbtree_cons (a, c, bh+1-c, v) of
    (
      int c, rbtree0 (a, cl, bh), a, rbtree0(a, cr, bh)
    ) (* end of [rbtree_cons] *)
// end of [rbtree]
//
where rbtree0(a:t@ype, c:int, bh:int) = rbtree(a, c, bh, 0)
//
')

#langeng("
#para('\

We count each occurrence of two red nodes in a row as one color violation.
Given a type T, a color C (represented by a integer), an integer BH and an
integer V, the type #stacode("rbtree(T, C, BH, V)") is for trees carrying
elements of the type T that is of the color C and the black height BH and
contains exactly V color violations. Therefore, the type
#stacode("rbtree(T, C, BH, 0)") is for valid red-black trees (containing no
color violations).

')
")
#langja("
#para('\

1つの列における2つの赤ノードの発生を1つの色違反として数えましょう。
型 T と整数として表わされる色 C と整数 BH, V が与えられた時、型 #stacode("rbtree(T, C, BH, V)")
は型 T の要素を持ち、色 C で、黒高さ BH で、きっかり V 回の色違反を含む木を表わします。
したがって、型 #stacode("rbtree(T, C, BH, 0)") は色違反のない有効な赤黒木です。

')
")

#langeng("
#para('\

Given a tree containing at most one color violation, an element and another
tree containing no violations, the following operation constructs a valid
red-black tree:

')
")
#langja("
#para('\

1以上の色違反を含む木と1つの要素、別の色違反を含まない木が与えられた時、
次の操作は有効な赤黒木をコンストラクトします:

')
")

#dats2xhtml('\
fn{
a:t@ype
} insfix_l // right rotation for fixing left insertion
  {cl,cr:clr} {bh:nat} {v:nat} (
  tl: rbtree (a, cl, bh, v), x0: a, tr: rbtree (a, cr, bh, 0)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK; \#define R RED; \#define cons rbtree_cons
in
  case+ (tl, x0, tr) of
  | (cons (R, cons (R, a, x, b), y, c), z, d) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // shallow rot
  | (cons (R, a, x, cons (R, b, y, c)), z, d) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // deep rotation
  | (a, x, b) =>> cons (B, a, x, b)
end // end of [insfix_l]
')

#langeng("
#para('\

By simply reading the interface of #dyncode("insfix_l"), we can see that the
two tree arguments are required to be of the same black height bh for some
natural number bh and the returned tree is of the black height bh+1.

')
")
#langja("
#para('\

#dyncode("insfix_l") のインターフェイスを読んでみることで、引数である2つの木は自然数の黒高さ bh
が同じで、なおかつ返値の木の黒高さが bh+1 でなくてはいけないことが分かります。

')
")

#langeng("
#para('\

The following operation #dyncode("insfix_r") is just the mirror image of
#dyncode("insfix_l"):

')
")
#langja("
#para('\

次の操作 #dyncode("insfix_r") は #dyncode("insfix_l") の単純な鏡像です:

')
")

#dats2xhtml('\
fn{
a:t@ype
} insfix_r // left rotation for fixing right insertion
  {cl,cr:clr} {bh:nat} {v:nat} (
  tl: rbtree (a, cl, bh, 0), x0: a, tr: rbtree (a, cr, bh, v)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK; \#define R RED; \#define cons rbtree_cons
in
  case+ (tl, x0, tr) of
  | (a, x, cons (R, b, y, cons (R, c, z, d))) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // shallow rot
  | (a, x, cons (R, cons (R, b, y, c), z, d)) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // deep rotation
  | (a, x, b) =>> cons (B, a, x, b)
end // end of [insfix_r]
')

#langeng("
#para('\

The preparation for implementing insertion on a red-black tree is all done
by now, and we are ready to see an implementation of insertion guaranteeing
that the tree obtained from inserting an element into a given red-black
tree is always a valid red-black tree itself. This guarantee is precisely
captured in the following interface for insertion:

')
")
#langja("
#para('\

これで赤黒木への挿入を実装する準備が整いました。
与えられた赤黒木に要素を挿入した木は常に有効な赤黒木であることを保証するような、挿入の実装を確認する準備はできています。
この保証は次の挿入インターフェイスで正確に捕捉されています:

')
")

#dats2xhtml('\
extern
fun{
a:t@ype
} rbtree_insert
  {c:clr} {bh:nat}
(
  t: rbtree0 (a, c, bh), x0: a, cmp: cmp a
) : [bh1:nat] rbtree0 (a, BLK, bh1)
')

#langeng("
#para('\

Interestingly, this interface also implies that the tree returned by a call
to #dyncode("rbtree_insert") is always black. The code presented below
gives an implementation of #dyncode("rbtree_insert"):

')#comment("para")
")
#langja("
#para('\

興味深いことに、このインターフェイスは #dyncode("rbtree_insert")
を呼び出して得られる木が常に黒であることも示しています。
以下のコードは #dyncode("rbtree_insert") の実装です:

')#comment("para")
")

#dats2xhtml('\
implement{a}
rbtree_insert
  (t, x0, cmp) = let
//
\#define B BLK
\#define R RED
\#define nil rbtree_nil
\#define cons rbtree_cons
//
fun ins
  {c:clr}{bh:nat} .<bh,c>.
(
  t: rbtree0 (a, c, bh), x0: a
) :
[
  cl:clr;v:nat | v <= c
] rbtree (a, cl, bh, v) =
(
  case+ t of
  | nil ((*void*)) =>
      cons{..}{..}{..}{0} (R, nil, x0, nil)
  | cons (c, tl, x, tr) => let
      val sgn = compare (x0, x, cmp)
    in
      if sgn < 0 then let
        val [cl,v:int] tl = ins (tl, x0)
      in
        if c = B then insfix_l (tl, x, tr)
          else cons{..}{..}{..}{cl} (R, tl, x, tr)
        // end of [if]
      end else if sgn > 0 then let
        val [cr,v:int] tr = ins (tr, x0)
      in
        if c = B then insfix_r (tl, x, tr)
          else cons{..}{..}{..}{cr} (R, tl, x, tr)
        // end of [if]
      end else t // end of [if]
    end // end of [cons]
) (* end of [ins] *)
//
val t = ins (t, x0)
//
in
  case+ t of cons (R, tl, x, tr) => cons (B, tl, x, tr) | _ =>> t
end // end of [rbtree_insert]
')

#langeng("
#para('\

Note that the type assigned to the inner function #dyncode("ins") is so
informative that it literally gives an formal explanation about the way in
which insertion works on a red-black tree. Many a programmer implements
red-black trees by simply following an algorithm written in some format of
pseudo code while having little understanding about the innerworkings of
the algorithm. For instance, if the above inner function #dyncode("ins") is
implemented in C, few programmers are likely to see that the function
always maintain the black height of a given red-black tree after insertion
but may introduce one color violation if the root of the tree is red. On
the other hand, knowing this invariant is essential to gaining a thorough
understanding of the insertion algorithm on red-black trees.

')
")
#langja("
#para('\

内部関数 #dyncode("ins")
に割り当てれらた型が、赤黒木にへの挿入方法について形式的な説明を事実上与えていることに注意してください。
このアルゴリズムの内部構造についてほとんど理解していない疑似コードとして書かれたアルゴリズムを単に頼って、多くのプログラマは赤黒木を実装します。
例えば、上記の内部関数 #dyncode("ins") がC言語で実装されたとしたら、
その関数が常に与えられた赤黒木の黒高さを管理できているか、判断できるプログラマはほとんどいないでしょう。
そして木の値が赤になった場合、色違反のある木を作ってしまうかもしれません。
一方、この不変条件は赤黒木の挿入アルゴリズムとしてよく知られたものと本質的に同じです。

')
")

#langeng("
#para('\

The insertion operation implemented above does not insert an element if it
is already in the given red-black tree. It may be desirable to require that
the operation inform the caller if such a case occurs. For instance, an
exception can be raised for this purpose. An alternative is to give
#dyncode("rbtree_insert") a call-by-reference argument so that a flag can be
returned in it to indicate whether the element to be inserted is actually
inserted. I will explain elsewhere what call-by-reference is and how it is
supported in ATS.

')
")
#langja("
#para('\

もし既に与えられた赤黒木に要素が含まれていたら、上記で実装した挿入操作はその要素を挿入しません。
もしそのような場合、呼び出し元に知らせた方が望ましいかもしれません。
例えば、この目的のために例外を発生させることもできます。
代案として、#dyncode("rbtree_insert") に参照渡し (call-by-reference) 引数を与えて、挿入しようとした要素が実際に挿入されたのか示すフラグを返す方法があります。
別の章で参照渡しの意味と、ATS でそれがどのようにサポートされているのか解説します。

')
")

#langeng("
#para('\

Often deleting an element from a binary search tree is significantly more
difficult to implement than inserting one.  This is especially so in the
case of a red-black tree.  I refer the interested reader to the libats
library of ATS for some code implementing a deletion operation on red-black
trees that can guarantee based on types each tree returned by the operation
being a valid red-black tree (containing no color violations).

')
")
#langja("
#para('\

しばしば2分探索木の要素の削除を実装するのは挿入よりもきわめて難しいことがあります。
これは赤黒木において特に顕著です。
興味のある読者には、型を使って返値の木が有効な赤黒木であることを保証する赤黒木の削除操作の実装コードとして、
ATS の libats ライブラリをおすすめします。

')
")

#langeng("
#para("\

Please find the entire code in this section plus some additional code for
testing #mycodelink("CHAP_DEPDTREF/rbtree.dats", "on-line").

")
")
#langja("
#para("\

この章のコード全体と追加のテストコードは
#mycodelink("CHAP_DEPDTREF/rbtree.dats", "オンライン")
から入手できます。

")
")

</sect1><!--id="example_fun_red-black_trees"-->

</chapter><!--id="datatype_refinement"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
