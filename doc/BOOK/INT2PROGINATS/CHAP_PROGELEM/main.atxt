%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="elements_of_programming">
#langeng("
#title("Elements of Programming")
")
#langja("
#title("プログラミングの構成要素")
")

#langeng("
#para("\
The core of ATS is a call-by-value functional programming language. I will
explain the meaning of #emphasis("call-by-value") in a moment. As
for functional programming, there is really no precise definition.  The
most important aspect of functional programming that I want to explore is
the notion of binding, which relates names to expressions.\
")
")
#langja("
#para("\
ATSのコアは即時評価(call-by-value)の関数型言語です。
この章ではしばらく #emphasis("call-by-value") の意味について説明します。
関数型プログラミングとしては厳密な定義がないためです。
これから探検する関数型プログラミングの最も重要な側面は束縛の概念です。
それは名前と式の関係を表わしています。 \
")
")

<sect1 id="expressions_and_values">
#langeng("
#title("Expressions and Values")
")
#langja("
#title("式と値")
")

#langeng("
#para("\

ATS is both syntax-rich and feature-rich, and its grammar is probably more
complex than most existing programming languages. In ATS, there are a large
variety of forms of expressions, which I will introduce gradually.\
")
")
#langja("
#para("\

ATSは豊かな構文と高機能を両立しています。
そしてその文法は多くの既存のプログラミング言語よりも、おそらく複雑です。
ATSには多様な形の式があります。
それらを少しずつ説明します。\
")
")

#langeng("
#para("\

Let us first start with some integer arithmetic expressions (IAEs):
#dyncode("1"), #dyncode("~2"), #dyncode("1+2"), #dyncode("1+2*3-4"),
#dyncode("(1+2)/(3-4)"), etc. Note that the negative sign is represented by
the tilde symbol (#dyncode("~")) in ATS.  There is also support for
floating point numbers, and some floating point constants are given here:
#dyncode("1.0"), #dyncode("~2.0"), #dyncode("3."), #dyncode("0.12345"),
#dyncode("2.71828"), #dyncode("31416E-4"), etc. Note that #dyncode("3.")
and #dyncode("31416E-4") are the same as #dyncode("3.0") and
#dyncode("3.1416"), respectively. What I really want to emphasize at this
point is that #dyncode("1") and #dyncode("1.0") are two distinct numbers in
ATS: the former is an integer while the latter is a floating point number
(of double precision).\
")
")
#langja("
#para("\

まず整数の算術式(IAE)からはじめましょう:
#dyncode("1"), #dyncode("~2"), #dyncode("1+2"), #dyncode("1+2*3-4"),
#dyncode("(1+2)/(3-4)"), などです。
マイナス記号はATSでは波形符号 (#dyncode("~")) で表わすことに注意してください。
また浮動小数点数もサポートしています。
浮動小数点数の定数をいくつか挙げてみましょう:
#dyncode("1.0"), #dyncode("~2.0"), #dyncode("3."), #dyncode("0.12345"),
#dyncode("2.71828"), #dyncode("31416E-4"), などです。
#dyncode("3.") と #dyncode("31416E-4") は
#dyncode("3.0") と #dyncode("3.1416") にそれぞれ等価であることに注意してください。
ここで強調したいことは、ATSにおいて #dyncode("1") と #dyncode("1.0")
とは全く別の数だということです。
前者は整数であるのに対して、後者は(倍精度の)浮動小数点数なのです。 \
")
")

#langeng("
#para("\

また真理値の定数もあり: #dyncode("true") と #dyncode("false") です。
真理値の式は次のような形です: #dyncode("1 >= 0"),
#dyncode("not(2-1 >= 2)"), #dyncode("(1 < 2) andalso (2 < 3)"),
#dyncode("(~1 > 1) orelse (~1 <= 1)") などです。

There are also boolean constants: #dyncode("true") and #dyncode("false").
We can form boolean expressions such as #dyncode("1 >= 0"),
#dyncode("not(2-1 >= 2)"), #dyncode("(1 < 2) andalso (2 < 3)") and
#dyncode("(~1 > 1) orelse (~1 <= 1)"), where #dyncode("not"),
#dyncode("andalso") and #dyncode("orelse") stand for negation, conjunction
and disjunction, respectively. For programmers familiar with C-like syntax,
I point out that operators #dyncode("&&") and #dyncode("||") are synonyms
for #dyncode("andalso") and #dyncode("orelse"), respectively.  \

")
")
#langja("
#para("\

また真理値の定数もあり、それは: #dyncode("true") と #dyncode("false") です。
真理値の式は次のような形です: #dyncode("1 >= 0"),
#dyncode("not(2-1 >= 2)"), #dyncode("(1 < 2) andalso (2 < 3)"),
#dyncode("(~1 > 1) orelse (~1 <= 1)") などです。
これらの式では
#dyncode("not"), #dyncode("andalso"), #dyncode("orelse")
はそれぞれ 否定, 論理積, 論理和 を表わします。
C言語の文法に馴染んだプログラマには
演算子 #dyncode("&&") と #dyncode("||") はそれぞれ
#dyncode("andalso") と #dyncode("orelse") が同じ意味であると言えばわかるでしょう。 \

")
")

#langeng("
#para('\

Other commonly used constant values include characters and strings.  For
instance, following are some character constants: #dyncode("'a'"),
#dyncode("'B'"), #dyncode("'\\\\n'") (newline), #dyncode("'\\\\t'") (tab),
#dyncode("'\\\\('") (left parenthesis), #dyncode("')'") (right
parenthesis), #dyncode("'\\\\{'") (left curly brace), #dyncode("'}'")
(right curly brace), etc; following are some string constants:
#dyncode('"My name is Zoe"'), #dyncode('"Don\'t call me \\\\"Cloe\\\\""'),
#dyncode('"this is a newline:\\\\n"'), etc.\

')
")
#langja("
#para('\

一般に使われる定数には他に文字と文字列があります。
例えば次に示すのは文字の定数です:
#dyncode("'a'"), #dyncode("'B'"), #dyncode("'\\\\n'") (改行), #dyncode("'\\\\t'") (タブ),
#dyncode("'\\\\('") (左丸括弧), #dyncode("')'") (右丸括弧),
#dyncode("'\\\\{'") (左波括弧), #dyncode("'}'") (右波括弧) などです。
さらに次に示すのは文字列の定数です:
#dyncode('"My name is Zoe"'), #dyncode('"Don\'t call me \\\\"Cloe\\\\""'),
#dyncode('"this is a newline:\\\\n"') などです。 \

')
")

#langeng("
#para("\

Given a (function) name, say, foo, and an expression exp, the expression
foo(exp) is a function application or function call. The parentheses in
foo(exp) may be dropped if no ambiguity is created by doing so. For
instance, #dyncode('print("Hello")') is a function application, which can
also be written as #dyncode('print "Hello"').  If foo is a nullary
function, then a function application foo() can be formed.  If foo is a
binary function, then a function application foo(exp1, exp2) can be formed
for expressions exp1 and exp2. Functions of more arguments can be treated
accordingly.\

")
")
#langja("
#para("\

関数名fooと式expが与えられた時、式 foo(exp) は関数適用または関数呼び出しです。
あいまいさがない場合には foo(exp) の小括弧ははずすことができます。
例えば #dyncode('print("Hello")') は関数適用であり、
また #dyncode('print "Hello"') と書くこともできます。

もしfooが引数のない関数であった場合、 foo() という関数適用を取れます。
もしfooが2引数の関数でありexp1とexp2が式であった場合、 foo(exp1, exp2) という関数適用を取れます。
より多くの引数を取る関数についてはわかると思います。\

")
")

#langeng("
#para("\

Note that we cannot write #dyncode("+(1,2)") as the name #dyncode("+") has
already been given the infix status requiring that it be treated as an
infix operator.  However, we can write #dyncode("op+(1,2)"), where
#dyncode("op") is a keyword in ATS that can be used to temporarily suspend
the infix status of any name immediately following it. I will explain in
detail the issue of fixity (prefix, infix and postfix) elsewhere.\

")
")
#langja("
#para("\

#dyncode("+(1,2)") とは書けないことに注意してください。
#dyncode("+") という名前は中置演算子として既に定義されてしまっています。
けれども #dyncode("op+(1,2)") と書くことはできます。
ATSにおいて #dyncode("op") はキーワードで、後ろに続く名前の中置記法設定を一時的に無効化します。
結合性(前置, 中置, 後置)についての詳細は別の章で説明します。 \

")
")

#langeng("
#para("\

Values are essentially expressions of certain special forms, which cannot
be reduced or simplified further. For instance, integer constants such as
#dyncode("1") and #dyncode("~2") are values, but the integer expression
#dyncode("1+2") is not a value, which can be reduced to the value
#dyncode("3").  Evaluation refers to the computational process that reduces
a given expression into a value. However, certain expressions such as
#dyncode("1/0") cannot be reduced to a value, and evaluating such an
expression must abort at some point. I will gradually present more
information on evaluation.\

")
")
#langja("
#para("\

値は、これ以上単純化できない特殊な形の式でです。
例えば #dyncode("1") や #dyncode("~2") のような整数の定数は値です。
しかし整数の式 #dyncode("1+2") は値ではありません。
なぜなら値 #dyncode("3") に単純化できるからです。
評価とは与えられた式を値になるまで単純化する計算過程です。
けれども #dyncode("1/0") のような式は単純化して値にすることができません。
このような式の評価はどこかで中断されなければなりません。
評価については後でゆっくり説明します。 \

")
")

</sect1><!--id="expressions_and_values"-->

#comment(" ****** ****** ")

<sect1 id="names_and_bindings">
#langeng("
#title("Names and Bindings")
")
#langja("
#title("名前と束縛")
")

#langeng("
#para("\

A crucial aspect of a programming language is the mechanism it provides for
binding names, which are themselves expressions, to expressions. For
instance, a declaration is introduced by the following syntax that declares
a binding between the name #dyncode("x"), which is also referred to as a
variable, and the expression #dyncode("1+2"):\

")
")
#langja("
#para("\

プログラミング言語の決定的な側面は名前を式に束縛するためのしくみです。
さらにその名前自身が式になります。

例えば次の構文で表わされるのは、
式 #dyncode("1+2") を名前 #dyncode("x") に束縛すする宣言です。
また #dyncode("x") も値として参照されます。\

")
")

<informalexample><programlisting>
val x = 1 + 2
</programlisting></informalexample>

#langeng("
#para("\

Note that #dyncode("val") is a keyword in ATS, and the declaration is
classified as a val-declaration. Conceptually, what happens at run-time in
a call-by-value language such as ATS is that the expression #dyncode("1+2")
is first evaluated to the value #dyncode("3"), and then the binding between
#dyncode("x") and #dyncode("1+2") is #emphasis("finalized") into a binding
between #dyncode("x") and #dyncode("3"). Essentially, call-by-value means
that a binding between a name and an expression needs to be finalized into
one between the name and the value of the expression before it can be used
in evaluation subsequently. As another example, the following syntax
declares three bindings, two of which are formed simultaneously in the
first line:\

")
")
#langja("
#para("\

ATSでは  #dyncode("val") はキーワードであることに注意してください。
またその宣言はval宣言として分類されます。

概念上、ATSのような即時評価(call-by-value)の言語において実行時に起きることは、
まずはじめに式 #dyncode("1+2") が値 #dyncode("3") に評価されます。
次に #dyncode("x") と #dyncode("1+2") の間に束縛ができ、
#dyncode("x") と #dyncode("3") の間に束縛が #emphasis("決着(finalized)") します。
本質的に即時評価とは、
名前と式の束縛はそれ以降の評価で使われる前に、
その名前とその式の値の束縛に決着されなければならないことを意味します。
別の例としては、次の構文では3つの束縛を宣言しています。
最初の行ではその内2つが同時に宣言されています。 \

")
")

<informalexample><programlisting>
val PI = 3.14 and radius = 10.0
val area = PI * radius * radius
</programlisting></informalexample>

#langeng("
#para("\

Note that it is unspecified in ATS as to which of the first two bindings
(connected by the keyword #dyncode("and")) is finalized ahead of the other
at run-time. However, it is guaranteed that the third binding is finalized
after the first two are done. To see this issue from a different angle, we
can try to typecheck the following code:

<informalexample><programlisting>
val x = 0 and y = x + 1
</programlisting></informalexample>

The error message reported in this case indicates that the name (or dynamic
identifier) #dyncode("x") in the expression #dyncode("x + 1") is unbound.
In particular, the two occurrences of #dyncode("x") in the above code are
unrelated.

")
")
#langja("
#para("\

#dyncode("and") キーワードで繋がっている最初の2つの束縛のどちらが先に実行時に決着されるかは、
ATSにおいては未定義であることに注意してください。
けれども3つ目の束縛は最初の2つが完了した後に決着されることは保証されています。
この論点を別の角度から見るために、次のコードを型検査してみましょう。

<informalexample><programlisting>
val x = 0 and y = x + 1
</programlisting></informalexample>

この場合、エラーメッセージは式 #dyncode("x + 1")
の中にある名前(もしくは動的な識別子) #dyncode("x") が束縛されていないことを示しています。
具体的には上記のコードの中にある2つの #dyncode("x") 同士に関係がないのです。

")
")

</sect1><!--id="names_and_bindings"-->

<!-- ****** ****** -->

<sect1 id="scopes_for_bindings">
#langeng("
#title("Scopes for Bindings")
")
#langja("
#title("束縛のスコープ")
")

#langeng("
#para("\

Each binding is given a fixed scope in which the binding is considered
legal or effective. The scope of a toplevel binding in a file starts from
the point where the binding is introduced until the very end of the
file. The bindings introduced in the following example between the keywords
#dyncode("let") and #dyncode("in") are effective until the keyword
#dyncode("end") is reached:\

")
")
#langja("
#para("\

それぞれの束縛は、それが有効である固定のスコープを持っています。
ファイルの中にあるトップレベルの束縛のスコープは束縛が作られた場所からファイルの終端までです。
次の例では #dyncode("let") と #dyncode("in") キーワードの間で束縛が作られていて、
その束縛は #dyncode("end") キーワードまで有効です。 \

")
")

<informalexample><programlisting>
val area = let
  val PI = 3.14 and radius = 10.0 in PI * radius * radius
end // end of [let]
</programlisting></informalexample>

#langeng("
#para("\

Such bindings are referred to as local bindings, and the names such as
#dyncode("PI") and #dyncode("radius") are referred to as local names.  This
example can also be written in the following style:\

")
")
#langja("
#para("\

このような束縛はローカル束縛と呼ばれていて、
#dyncode("PI") や #dyncode("radius") のような名前はローカル名と呼ばれています。
この例は以下のようなスタイルでも書くことができます。 \

")
")

<informalexample><programlisting>
val area =
  PI * radius * radius where {
  val PI = 3.14 and radius = 10.0 // simultaneous bindings
} // end of [where] // end of [val]
</programlisting></informalexample>

#langeng("
#para("\

The keyword #dyncode("where") appearing immediately after an expression
introduces bindings that are solely effective for evaluating names
contained in the expression.  Note that expressions formed using the
keywords #dyncode("let") and #dyncode("where") are often referred to as
let-expressions and where-expressions, respectively. The former can always
be translated into the latter directly and vice versa.  Which style is
better? I have not formed my opinion yet. The answer seems to entirely
depend on the taste of the programmer.\

")
")
#langja("
#para("\

式の直後に現われるキーワード #dyncode("where") は、
その式に含まれている名前を評価するためのみ有効な束縛を表わしています。
しばしば、キーワード #dyncode("let") と #dyncode("where")
を使って構成された式は、それぞれlet式とwhere式と呼ばれます。
前者はかならず後者に変換でき、また逆にもかならず変換できます。
どちらがより良いスタイルなのでしょうか？
私はまだ自分の意見を持っていません。
その答はプログラマの好みに完全に依存していると思われます。 \

")
")

#langeng("
#para("\

The following example demonstrates an alternative approach to introducing
local bindings:

<informalexample><programlisting>
local

val PI = 3.14 and radius = 10.0

in (* in of [local] *)

val area = PI * radius * radius

end // end of [local]
</programlisting></informalexample>

where the bindings introduced between the keywords #dyncode("local") and
#dyncode("in") are effective until the keyword #dyncode("end") is
reached. Note that the bindings introduced between the keywords
#dyncode("in") and #dyncode("end") are themselves toplevel bindings. The
difference between #dyncode("let") and #dyncode("local") should be clear:
The former is used to form an expression while the latter is used to
introduce a sequence of declarations.\

")
")
#langja("
#para("\

次の例はローカル束縛を作るまた別のアプローチを示しています。

<informalexample><programlisting>
local

val PI = 3.14 and radius = 10.0

in (* in of [local] *)

val area = PI * radius * radius

end // end of [local]
</programlisting></informalexample>

キーワード #dyncode("local") と #dyncode("in") の間で作られた束縛は、
キーワード #dyncode("end") に逹っするまで有効です。
#dyncode("in") と #dyncode("end")の間で作られた束縛は、
トップレベルの束縛になることに注意してください。
#dyncode("let") と #dyncode("local") の違いは明確です。
前者は式を構成するのに使い、後者は宣言を列挙するのに使います。 \

")
")

</sect1><!--id="scopes_for_bindings"-->

<!-- ****** ****** -->

<sect1 id="environments_for_evaluation">
#langeng("
#title("Environments for Evaluation")
")
#langja("
#title("評価のための環境")
")

#langeng("
#para("\
Evaluation is the computational process that reduces expressions to
values.  When performing evaluation, we need not only the expression to be
evaluated but also a collection of bindings that map names in the
expression to values. This collection of bindings, which is just a finite
mapping, is often referred to as an environment (for evaluation). For
instance, suppose that we want to evaluate the following expression:

<informalexample><programlisting>
let
  val PI = 3.14 and radius2 = 10.0 * 10.0 in PI * radius2
end
</programlisting></informalexample>

We start with the empty environment ENV0; we evaluate #dyncode("3.14") to
itself and #dyncode("10.0 * 10.0") to #dyncode("100.0") under the
environment ENV0; we then extend ENV0 to ENV1 with two bindings mapping
#dyncode("PI") to #dyncode("3.14") and #dyncode("radius2") to
#dyncode("100.0"); we then evaluate #dyncode("PI * radius2") under ENV1
to #dyncode("3.14 * radius2"), then to #dyncode("3.14 * 100.0"), and
finally to #dyncode("314.0"), which is the value of the let-expression.\
")
")
#langja("
#para("\
評価とは式を値になるまで単純化する計算過程です。
評価を実行するには、評価される式だけではなく、
その式の中にある名前を値に変換するために束縛の集合も必要です。
この束縛の集合は単なる連想配列で、しばしば(評価のための)環境と呼ばれます。
例えば次の式を評価することを考えてみましょう。

<informalexample><programlisting>
let
  val PI = 3.14 and radius2 = 10.0 * 10.0 in PI * radius2
end
</programlisting></informalexample>

空の環境であるENV0から開始します。
まず環境ENV0において #dyncode("3.14") をそれ自身に、
#dyncode("10.0 * 10.0") を #dyncode("100.0") に評価します。
次にENV0拡張して、
#dyncode("PI") から #dyncode("3.14") に #dyncode("radius2") から #dyncode("100.0")
に変換する2つの束縛をともなうENV1を作ります。
それからENV1において #dyncode("PI * radius2") を #dyncode("3.14 * radius2") に評価し、
さらに #dyncode("3.14 * 100.0") に評価します。
最後に #dyncode("314.0") が得られて、これがlet式の値になります。 \
")
")

</sect1><!--id="environments_for_evaluation"-->

<!-- ****** ****** -->

<sect1 id="static_semantics">
#langeng("
#title("Static Semantics")
")
#langja("
#title("静的な意味論")
")

#langeng("
#para("\
ATS is a programming language equipped with a highly expressive type
system rooted in the #emphasis("Applied Type System") framework,
which also gives ATS its name. I will gradually introduce the type system
of ATS, which is probably the most outstanding and interesting part of this
book.\
")
")
#langja("
#para("\
ATSは #emphasis("Applied Type System") フレームワークを根源とする、
高度に表現力のある型システム備えたプログラミング言語です。
それはまたATSという言語の名前にもなっています。
ATSの型システムを徐々に説明します。
おそらくこの本で最も突出していて興味深い部分でしょう。 \
")
")

#langeng("
#para("\
It is common to treat a type as the set of values it classifies.
However, I find it more approriate to treat a type as a form of
meaning. There are formal rules for assigning types to expressions, which
are referred to as typing rules.  If a type T can be assigned to an
expression, then I say that the expression possesses the static meaning
(semantics) represented by the type T. Note that an expression may be
assigned many distinct static meanings.  An expression is well-typed if
there exists a type T such that the expression can be assigned the type T.\
")
")
#langja("
#para("\
一般には、型を分類された値の集合のように扱います。
けれども、私は型を意味の形として扱う方がより適切であることを見つけました。
式に型を割り振る形式的な規則があり、それは型付け規則と呼ばれています。
もし式に型Tを割り振ることができるとします。
するとその式は型Tで表現された静的な意味(意味論)を持つと言えるのです。
一つの式には複数の異なる静的な意味論を割り振られる可能性があることに注意してください。
もし式に割り振り可能な型Tが唯一1つだけ存在するなら、その式は正しい型付けをされていることになります。 \
")
")

#langeng("
#para("\
If there is a binding between a name and an expression and the
expression is of some type T, then the name is assumed to be of the type T
in the effective scope of the binding. In other words, the name assumes the
static meaning of the expression it refers to.\
")
")
#langja("
#para("\
もし型Tを持つ式と名前とを繋ぐ束縛が存在するなら、
束縛が有効なスコープにおいてその名前は型Tであると見なされます。
言い方を代えると、その名前は対応する式の持つ静的な意味を取るということになります。 \
")
")

#langeng("
#para("\

Let exp0 be an expression of some type T, that is, the type T can be
assigned to exp0 according to certain typing rules. If we can evaluate exp0
to exp1, then exp1 can also be assigned the type T. In other words, static
meaning is an invariant under evaluation. This property is often referred
to as #emphasis("type preservation"), which is part of the soundness of the
type system of ATS. Based on this property, we can readily infer that any
value is of the type T if exp0 can be evaluated to it (in many steps).\

")
")
#langja("
#para("\

exp0が型Tの式であるとしましょう。
つまり型Tがexp0に型付け規則によって割り振られたとします。
exp0をexp1に評価できるなら、exp1もまた型Tが割り振れることになります。
別の言い方をすると、静的な意味は評価の中で不変であると言えるわけです。
この特性はしばしば #emphasis("型保存(type preservation)") と呼ばれます。
これはATSの型システムにおける健全性の一部です。
この特性に基づくと、私達はexp0がいくつかのステップで評価されて値をになるとしても、
型Tの取りうる値をたやすく推察することができるのです。 \

")
")

#langeng("
#para("\

Let exp0 be an expression of some type T. Assume that exp0 is not a value.
Then exp0 can always be evaluated one step further to another expression
exp1. This property is often referred to as #emphasis("progress"), which is
another part of the soundness of the type system of ATS.\

")
")
#langja("
#para("\

exp0が型Tの式であり、またexp0は値ではないとします。
するとexp0は1ステップで別の式であるexp1に評価することがいつでも可能です。
この特性はしばしば #emphasis("プログレス(progress)") と呼ばれます。
そしてこれはATSの型システムにおける健全性のもう一つの部分です。 \

")
")

</sect1><!--id="static_semantics"-->

<!-- ****** ****** -->

<sect1 id="primitive_types">
#title("Primitive Types")

#para("\

The simplest types in ATS are primitive types, which are used to classify
primitive values. For instance, we have the primitive types #dyncode("int")
and #dyncode("double"), which classify integers (in a fixed range) and
floating point numbers (of double precision), respectively.\

")

#para("\

In the current implementation of ATS (Postiats), a program in ATS is first
compiled into one in C (conforming to the C99 standard), which can then be
compiled to object code by a compiler for C such as gcc. In the compilation
from ATS to C, the type #dyncode("int") in ATS is translated to the type of
the same name in C. Similarly, the type #dyncode("double") in ATS is
translated to the type of the same name in C.\

")

#para("\

There are many other primitive types in ATS, and I will introduce
them gradually.  Some commonly used primitive types are listed as follows:

<itemizedlist>

<listitem>
#para("\
#stacode("bool"):
This type is for boolean values #dyncode("true") and #dyncode("false"),
and it is translated into the int type in C.\
")
</listitem>

<listitem>
#para("\
#stacode("char"):
This type is translated into the type in C for characters.\
")
</listitem>

<listitem>
#para("\
#stacode("schar"):
This type is translated into the type in C for signed characters.\
")
</listitem>

<listitem>
#para("\
#stacode("uchar"):
This type is translated into the type in C for unsigned characters.\
")
</listitem>

<listitem>
#para("\
#stacode("float"):
This type is translated into the type in C for floating point numbers of
single precision.\
")
</listitem>

<listitem>
#para("\
#stacode("uint"):
This type is translated into the type in C for unsigned integers.\
")
</listitem>

<listitem>
#para("\
#stacode("lint"):
This type is translated into the type in C for long integers.\
")
</listitem>

<listitem>
#para("\
#stacode("ulint"):
This type is translated into the type in C for unsigned long integers.\
")
</listitem>

<listitem>
#para("\
#stacode("llint"):
This type is translated into the type in C for long long integers.\
")
</listitem>

<listitem>
#para("\
#stacode("ullint"):
This type is translated into the type in C for unsigned long long integers.\
")
</listitem>

<listitem>
#para("\
#stacode("size_t"):
This type is translated into the type in C of the same name, which is for
unsigned integers of certain precision. Usually, the type #stacode("size_t")
can be treated as the type #stacode("ulint") and vice versa.\
")
</listitem>

<listitem>
#para("\
#stacode("ssize_t"):
This type is translated into the type in C of the same name, which is for
signed integers of certain precision. Usually, the type #stacode("ssize_t")
can be treated as the type #stacode("lint") and vice versa.\
")
</listitem>

<listitem>
#para("\
#stacode("string"):
This type is for strings, and its translation in C is the type for
pointers. I will explain this translation elsewhere.\
")
</listitem>

<listitem>
#para("\
#stacode("void"):
This type is for the void value, and its translation in C is the type of
the same name. It should be noted that the void value is unspecified in
ATS. I often say that a function returns no value if it returns the void
value, and vice versa.\
")
</listitem>

</itemizedlist>

I will gradually present programming examples involving various primitive types and
values.\

")

</sect1><!--id="primitive_types"-->

<!-- ****** ****** -->

<sect1 id="tuples_and_tuple_types">
#title("Tuples and Tuple Types")

#para("\

Given two types T1 and T2, we can form a tuple type (T1, T2), which can
also be written as @(T1, T2).  Assume that exp1 and exp2 are two
expressions of the types T1 and T2, respectively. Then the expression
(exp1, exp2), which can also be written as @(exp1, exp2), refers to a tuple
of the tuple type (T1, T2). Accordingly, we can form tuples and tuple types
of more components. In order for a tuple type to be assigned to a tuple,
the tuple and the tuple type must have the equal number of components.\

")

#para("\

When evaluating a tuple expression, we evaluate all of its components
#emphasis("sequentially"). Suppose that the expression contains n
components, then the value of the expression is the tuple consisting of the
n values of the n components listed in the order as the components
themselves.\

")

#para("\

A tuple of length n for n >= 2 is just a record of field names ranging from
0 until n-1, inclusive. Given an expression exp of some tuple type (T1,
T2), we can form expressions (exp).0 and (exp).1, which are of types T1 and
T2, respectively. Note that the expression exp does not have to be a tuple
expression. For instance, exp may be a name or a function application. If
exp evaluates to a tuple of two values, then exp.0 evaluates to the first
value and exp.1 the second value. Clearly, if the tuple type of exp
contains more components, what is stated can be generalized accordingly.\

")

#para("\

In the following example, we first construct a tuple of length 3 and then
introduce bindings between 3 names and all of the 3 components of the
tuple:

<informalexample><programlisting>
val xyz = ('A', 1, 2.0)
val x = xyz.0 and y = xyz.1 and z = xyz.2
</programlisting></informalexample>

Note that the constructed tuple can be assigned the tuple type
#stacode("(char, int, double)"). Another method for selecting components in
a given tuple is based on pattern matching, which is employed in the
following example:

<informalexample><programlisting>
val xyz = ('A', 1, 2.0)
val (x, y, z) = xyz // x = 'A'; y = 1; z = 2.0
</programlisting></informalexample>

Note that #dyncode("(x, y, z)") is a pattern that can match any tuples of
exact 3 components. I will say more about pattern matching elsewhere.
")

#para("\

The tuples introduced above are often referred to as flat tuples, native
tuples or unboxed tuples. There is another kind of tuples supported in ATS,
which are called boxed tuples. A boxed tuple is essentially a pointer
pointing to some heap location where a flat tuple is stored.\

")

#para("\

Assume that exp1 and exp2 are two expressions of the types T1 and T2,
respectively. Then the expression '(exp1, exp2), refers to a tuple of the
tuple type '(T1, T2). Accordingly, we can form boxed tuples and boxed tuple
types of fewer or more components. What should be noted immediately is that
every boxed tuple is of the size of a pointer, and can thus be stored in
any place where a pointer can. Using boxed tuples is rather similar to
using unboxed ones. For instance, the meaning of the following code should
be evident:

<informalexample><programlisting>
val xyz = '( 'A', 1, 2.0 )
val x = xyz.0 and y = xyz.1 and z = xyz.2
</programlisting></informalexample>

Note that a space is needed between #dyncode("'(") and #dyncode("'A'")
for otherwise the current parser (for ATS/Postiats) would be confused.\

")

#para("\

Given the availability of flat and boxed tuples, one naturally wants to
know whether there is a simple way to determine which kind is preferred
over the other. Unfortunately, there is no simple way to do this as far as
I can tell. In order to be certain, some kind of profiling is often
needed. However, if we want to run code with no support of garbage
collection (GC), then we should definitely avoid using boxed tuples.\

")

</sect1><!--id="tuples_and_tuple_types"-->

<!-- ****** ****** -->

<sect1 id="records_and_record_types">
#title("Records and Record Types")

#para("\
A record is just like a tuple except that each field name of the
record is chosen by the programmer (instead of being fixed). Similarly, a
record type is just like a tuple type.  For instance, a record type
#stacode("point2D") is defined as follows:

<informalexample><programlisting>
typedef point2D = @{ x= double, y= double }
</programlisting></informalexample>

where #dyncode("x") and #dyncode("y") are the names of the two fields in
a record value of this type. We also refer to a field in a record as a
component. The special symbol #dyncode("@{") indicates that the formed
type is for flat/native/unboxed records. A value of the type
#stacode("point2D") is constructed as follows and given the name
#dyncode("theOrigin"):

<informalexample><programlisting>
val theOrigin = @{ x= 0.0, y= 0.0 } : point2D
</programlisting></informalexample>
")

#para("\
We can use the standard dot notation to extract out a selected component in
a record, and this is shown in the next line of code:

<informalexample><programlisting>
val theOrigin_x = theOrigin.x and theOrigin_y = theOrigin.y
</programlisting></informalexample>

Alternatively, we can use pattern matching for doing component extraction
as is done in the next line of code:

<informalexample><programlisting>
val @{ x= theOrigin_x, y= theOrigin_y } = theOrigin
</programlisting></informalexample>

In this case, the names #dyncode("theOrigin_x") and
#dyncode("theOrigin_y") are bound to the components in
#dyncode("theOrgin") that are named #dyncode("x") and #dyncode("y"),
respectively. If we only need to extract out a selected few of components
(instead of all the available ones), we can make use of the following
kind of patterns:

<informalexample><programlisting>
val @{ x= theOrigin_x, ... } = theOrigin // the x-component only 
val @{ y= theOrigin_y, ... } = theOrigin // the y-component only 
</programlisting></informalexample>

If you find all this syntax for component extraction to be confusing, then
I suggest that you stick to the dot notation. I myself rarely use pattern
matching on record values.
")

#para("\
Compared with handling native/flat/unboxed records, the only change
needed for handling boxed records is to replace the special symbol
#dyncode("@{") with another one: #dyncode("'{"), which is a quote
followed immediately by a left curly brace.\
")

</sect1><!--id="records_and_record_types"-->

<!-- ****** ****** -->

<sect1 id="conditional_expressions">
#title("Conditional Expressions")

#para("\
A conditional expression consists of a test and two branches. For instance,
the following expression is conditional:

<informalexample><programlisting>
if (x >= 0) then x else ~x
</programlisting></informalexample>

where #dyncode("if"), #dyncode("then") and #dyncode("else") are keywords
in ATS. In a conditional expression, the expression following
#dyncode("if") is the test and the expressions following #dyncode("then")
and #dyncode("else") are referred to as the then-branch and the
else-branch (of the conditional expression), respectively.
")

#para("\

In order to assign a type T to a conditional expression, we need to assign
the type #dyncode("bool") to the test and the type T to both of the
then-branch and the else-branch. For instance, the type #dyncode("int") can
be assigned to the above conditional expression if the name #dyncode("x")
is given the type #dyncode("int").  ")

#para("\

Suppose that we have a conditional expression that is well-typed. When
evaluating it, we first evaluate the test to a value, which is guaranteed
to be either #dyncode("true") or #dyncode("false"); if the value is
#dyncode("true"), then we continue to evaluate the then-branch; otherwise,
we continue to evaluate the else-branch.  ")

#para("\

It is also allowed to form a conditional expression where the else-branch
is missing or truncated. For instance, we can form an expression as follows:

<informalexample><programlisting>
if (x >= 0) then print(x)
</programlisting></informalexample>

which is equivalent to the following conditional expression:

<informalexample><programlisting>
if (x >= 0) then print(x) else ()
</programlisting></informalexample>

Note that #dyncode("()") stands for the void value (of the type
#stacode("void")). If a type can be assigned to a conditional expression
in the truncated form, then the type must be #stacode("void").\
")

</sect1><!--id="conditional_expressions"-->

<!-- ****** ****** -->

<sect1 id="sequence_expressions">
#title("Sequence Expressions")

#para("\

Assume that exp1 and exp2 are expressions of types T1 and T2 respectively,
where T1 is #dyncode("void"). Then a sequence expression (exp1; exp2) can
be formed that is of the type T2.  When evaluating the sequence expression
(exp1; exp2), we first evaluate exp1 to the void value and then evaluate
exp2 to some value, which is also the value of the sequence expression.
When more expressions are sequenced, all of them but the last one need to
be of the type #dyncode("void") and the type of the last expression is also
the type of the sequence expression being formed.  Evaluating a sequence of
more expressions is analogous to evaluating a sequence of two. The
following example is a sequence expression:
 
<informalexample><programlisting>
(print 'H'; print 'e'; print 'l'; print 'l'; print 'o')
</programlisting></informalexample>

Evaluating this sequence expression prints out (onto the console) the
5-letter string \"Hello\". Instead of parentheses, we can also use the
keywords #dyncode("begin") and #dyncode("end") to form a sequence
expression:

<informalexample><programlisting>
begin
  print 'H'; print 'e'; print 'l'; print 'l'; print 'o'
end // end of [begin]
</programlisting></informalexample>

If we like, we may also add a semicolon immediately after the last
expression in a sequence as long as the last expression is of the type
#dyncode("void"). For instance, the above example can also be written as
follows:

<informalexample><programlisting>
begin
  print 'H'; print 'e'; print 'l'; print 'l'; print 'o';
end // end of [begin]
</programlisting></informalexample>

I also want to point out the following style of sequencing:

<informalexample><programlisting>
let
  val () = print 'H'
  val () = print 'e'
  val () = print 'l'
  val () = print 'l'
  val () = print 'o'
in
  // nothing
end // end of [begin]
</programlisting></informalexample>

which is rather common in functional programming.\
")

</sect1><!--id="sequence_expression"-->

<!-- ****** ****** -->

<sect1 id="comments_in_code">
#title("Comments in Code")

#para("\
ATS currently supports four forms of comments: line comment, block
comment of ML-style, block comment of C-style, and rest-of-file comment.

<itemizedlist>

<listitem>
#para("\
A line comment starts with the double slash symbol
(#dyncode("//")) and extends until the end of the current line.\
")
</listitem>

<listitem>
#para("
A block comment of ML-style starts and closes with the tokens
#dyncode("(*") and #dyncode("*)"), respectively. Note that nested block
comments of ML-style are allowed, that is, one block comment of ML-style
can occur within another one of the same style.\
")
</listitem>

<listitem>
#para("\
A block comment of C-style starts and closes with the tokens
#dyncode("/*") and #dyncode("*/"), respectively. Note that block comments
of C-style cannot be nested.  The use of block comments of C-style is
primarily in code that is supposed to be shared by ATS and C. In other
cases, block comments of ML-style should be the preferred choice.\
")
</listitem>

<listitem>
#para("\
A rest-of-file comment starts with the quadruple slash
symbol (#dyncode("////")) and extends until the end of the file. Comments
of this style of are primarily useful for developing or debugging programs.\
")
</listitem>

</itemizedlist>

")#comment("para")

</sect1><!--id="comments_in_code"-->

</chapter><!--id="elements_of_programming"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
