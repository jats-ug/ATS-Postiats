%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="theorem-proving_in_ats_lf">
#langeng("
#title("Theorem-Proving in ATS/LF")
")
#langja("
#title("ATS/LF を使った定理証明")
")

#langeng("
#para("\

Within the ATS programming language system, there is a component named
ATS/LF for supporting (interactive) therorem-proving. In ATS/LF,
theorem-proving is done by constructing proofs as total functional
programs. It will soon become clear that this style of theorem-proving can
be combined cohesively with functional programming to yield a programming
paradigm that is considered the signature of ATS: #emphasis("programming
with theorem-proving"). Moreover, ATS/LF can be employed to encode various
deduction systems and their meta-properties.\

")
")
#langja("
#para("\

ATS プログラミング言語システムには、(対話的な) 定理証明をサポートする ATS/LF という名前の部品あります。
ATS/LF では、全域関数のプログラムとして証明をコンストラクトすることで定理証明は行なわれます。
この定理証明のスタイルは、関数型プログラミングと組み合わさってあるプログラミングパラダイムを産み出すことがすぐに明確になるでしょう。
このようなパラダイムを ATS では #emphasis("定理証明を使ったプログラミング") と呼んでいます。
その上、ATS/LF は様々な演繹システムとそれらのメタな性質をエンコードすることができます。\

")
")

#langeng("
#para("\

Please find #mycodelink("CHAP_THMPRVING/", "on-line")
the code employed for illustration in this chapter plus some additional
code for testing.\

")
")
#langja("
#para("\

この章で解説するコードとテストのための追加コードは
#mycodelink("CHAP_THMPRVING/", "オンライン")
から入手できます。\

")
")

<!-- ****** ****** -->

<sect1
 id="encoding_relations_as_dataprops">
#langeng("
#title("Encoding Relations as Dataprops")
")
#langja("
#title("データ命題 (dataprop) として関係をエンコードする")
")

#langeng("
#para("\

In the statics of ATS, there is a built-in sort #emphasis("prop") for
static terms that represent types for proofs. A static term of the sort
#emphasis("prop") can also be referred to as a type or more accurately, a
prop-type or just a prop. A dataprop can be declared in a manner that is
mostly similar to the declaration of a datatype. For instance, a prop
construct #stacode("FIB") is introduced in the following dataprop declaration:

#sats2xhtml("\
dataprop
FIB(int, int) =
  | FIB0(0, 0) of () // [of ()] can be dropped
  | FIB1(1, 1) of () // [of ()] can be dropped
  | {n:nat}{r0,r1:int}
    FIB2(n+2, r0+r1) of (FIB(n, r0), FIB(n+1, r1))
// end of [FIB]
")

The sort assigned to #stacode("FIB") is #emphasis("(int, int) -&gt; prop"),
indicating that #stacode("FIB") takes two static integers to form a
prop-type. There are three data (or proof) constructors associated with
#stacode("FIB"): #dyncode("FIB0"), #dyncode("FIB1") and #dyncode("FIB2"), which are
assigned the following function types (or more accurately, prop-types):

<itemizedlist>

<listitem>
#para("\
#dyncode("FIB0"): #stacode("() -> FIB(0, 0)")
")
</listitem>

<listitem>
#para("\
#dyncode("FIB1"): #stacode("() -> FIB(1, 1)")
")
</listitem>

<listitem>
#para("\
#dyncode("FIB2"):
 #stacode("{n:nat}{r0,r1:int} (FIB(n, r0), FIB(n+1, r1)) -> FIB(n+2, r0+r1)")
")
</listitem>

</itemizedlist>

Given a natural number n and an integer r, it should be clear that
#stacode("FIB(n, r)") encodes the relation fib(n) = r, where fib is defined
by the following three equations:

<itemizedlist>

<listitem>
#para("\
fib(0) = 0, and
")
</listitem>

<listitem>
#para("
fib(1) = 1, and
")
</listitem>

<listitem>
#para("\
fib(n+2) = fib(n) + fib(n+1) for n >= 2.
")
</listitem>

</itemizedlist>

A proof value of the prop #stacode("FIB(n, r)") can be constructed if and
only if fib(n) equals r. For instance, the proof value
#dyncode("FIB2(FIB0(), FIB1())") is assigned the prop #dyncode("FIB(2,
1)"), attesting to fib(2) equaling 1.\

")#comment("para")
")
#langja("
#para("\

ATS の静的な部分には、証明の型を表わす静的な項のためのビルトインの種 #emphasis("prop") があります。
種 #emphasis("prop") の静的な項は、型もしくはより正確に命題型や、単に命題と呼ばれます。
データ命題はデータ型の宣言とよく似た作法で宣言できます。
例えば、#stacode("FIB") をコンストラクトする証明は次のデータ命題宣言で導入できます:

#sats2xhtml("\
dataprop
FIB(int, int) =
  | FIB0(0, 0) of () // [of ()] can be dropped
  | FIB1(1, 1) of () // [of ()] can be dropped
  | {n:nat}{r0,r1:int}
    FIB2(n+2, r0+r1) of (FIB(n, r0), FIB(n+1, r1))
// end of [FIB]
")

#stacode("FIB") に割り当てられた種は #emphasis("(int, int) -&gt; prop") で、#stacode("FIB")
が2つの静的な整数を取って命題型を作ることを示しています。
#stacode("FIB") に関連して3つのデータ (もしくは命題の) コンストラクタがあります。
それらは #dyncode("FIB0"), #dyncode("FIB1"), #dyncode("FIB2") で、次の関数型 (もしくはより正確に命題型)
が割り当てられています:

<itemizedlist>

<listitem>
#para("\
#dyncode("FIB0"): #stacode("() -> FIB (0, 0)")
")
</listitem>

<listitem>
#para("\
#dyncode("FIB1"): #stacode("() -> FIB (1, 1)")
")
</listitem>

<listitem>
#para("\
#dyncode("FIB2"):
 #stacode("{n:nat}{r0,r1:int} (FIB(n, r0), FIB(n+1, r1)) -> FIB(n+2, r0+r1)")
")
</listitem>

</itemizedlist>

自然数 n と整数 r が与えられた時、#stacode("FIB(n, r)") が関係 fib(n) = r
をエンコードしていることは明確でしょう。
この fib は次の3つの等式で定義されます:

<itemizedlist>

<listitem>
#para("\
fib(0) = 0, and
")
</listitem>

<listitem>
#para("
fib(1) = 1, and
")
</listitem>

<listitem>
#para("\
fib(n+2) = fib(n+1) + fib(n) for n >= 2.
")
</listitem>

</itemizedlist>

命題 #stacode("FIB(n, r)") の証明値は、fib(n) が r と等しい場合のみコンストラクトできます。
例えば、証明の値 #dyncode("FIB2(FIB0(), FIB1())") には命題 #dyncode("FIB(2, 1)") が割り当てられ、
これは fib(2) が 1 に等しいことを証明しています。\

")#comment("para")
")

#langeng("
#para("\

As another example of dataprop, the following declaration introduces a prop
constructor #stacode("MUL") together with three associated proof constructors:

#sats2xhtml("\
dataprop
MUL(int, int, int) =
  | {n:int} MULbas(0, n, 0) of ()
  | {m:nat}{n:int}{p:int}
    MULind(m+1, n, p+n) of MUL(m, n, p)
  | {m:pos}{n:int}{p:int}
    MULneg(~(m), n, ~(p)) of MUL(m, n, p)
// end of [MUL]
")

Given three integers m, n and p, the prop #stacode("MUL(m, n, p)")
encodes the relation m*n = p. As for #dyncode("MULbas"), #dyncode("MULind")
and #dyncode("MULneg"), they correspond to the following three equations,
respectively:

<itemizedlist>

<listitem>
#para("\
0*n = 0 for every integer n, and
")
</listitem>

<listitem>
#para("\
(m+1)*n = m*n + n for each pair of integers m and n, and
")
</listitem>

<listitem>
#para("\
(~m)*n = ~(m*n) for each pair of integers m and n.
")
</listitem>

</itemizedlist>

In other words, the dataprop declaration for #stacode("MUL") encodes the
relation that represents the standard multiplication function on integers.\

")
")
#langja("
#para("\

データ命題の別の例として、次の宣言は命題コンストラクタ #stacode("MUL") と関連する3つの証明コンストラクタを導入しています:

#sats2xhtml("\
dataprop
MUL(int, int, int) =
  | {n:int} MULbas(0, n, 0) of ()
  | {m:nat}{n:int}{p:int}
    MULind(m+1, n, p+n) of MUL(m, n, p)
  | {m:pos}{n:int}{p:int}
    MULneg(~(m), n, ~(p)) of MUL(m, n, p)
// end of [MUL]
")

3つの整数 m, n, p が与えられた時、証明 #stacode("MUL(m, n, p)") は関係 m*n = p をエンコードしています。
#dyncode("MULbas"), #dyncode("MULind"), #dyncode("MULneg") はそれぞれ次の3つの等式に相当します:

<itemizedlist>

<listitem>
#para("\
全ての整数 n について 0*n = 0 、かつ
")
</listitem>

<listitem>
#para("\
整数 m と n のペアそれぞれについて (m+1)*n = m*n + n 、かつ
")
</listitem>

<listitem>
#para("\
整数 m と n のペアそれぞれについて (~m)*n = ~(m*n)
")
</listitem>

</itemizedlist>

言い換えると、データ命題宣言 #stacode("MUL") は整数の乗法関数を表わす関係をエンコードしています。\

")
")

#langeng("
#para("\

It can be readily noticed that the process of encoding a functional
relation (i.e., a relation representing a function) as a dataprop is
analogous to implementing a function in a logic programming language such
as Prolog.\

")#comment("para")
")
#langja("
#para("\

関数的な関係 (例: 関数を表わす関係) をデータ命題にエンコードする過程は Prolog
のような論理型プログラミング言語における関数の実装に類似していることにすぐに気が付くでしょう。\

")#comment("para")
")

</sect1><!--id="encoding_relations_as_dataprops"-->

<!-- ****** ****** -->

<sect1 id="constructing_proofs_as_total_functions">

#langeng("
#title("Constructing Proofs as Total Functions")
")
#langja("
#title("全域関数を使って証明を組み立てる")
")

#langeng("
#para("\
Theorems are represented as types (or more accurately, props) in
ATS/LF. For instance, the following prop states that integer multiplication
is commutative:

#atscode("\
{m,n:int}{p:int} MUL(m, n, p) -<prf> MUL(n, m, p)
")

Constructing a proof for a theorem in ATS/LF means implementing a total
value (which is most likely to be a total function) of the type that is the
encoding of the theorem in ATS/LF, where being total means being pure and
terminating. Please note that this style of theorem-proving may seem rather
peculiar to those who have never tried it before.
")#comment("para")
")
#langja("
#para("\
ATS/LF では、定理は型 (もしくはより正確に命題) によって表現されます。
例えば、次の命題は整数の乗法が可換であると言っています:

#atscode("\
{m,n:int}{p:int} MUL (m, n, p) -<prf> MUL (n, m, p)
")

ATS/LF において定理に対する証明をコンストラクトすることは、ATS/LF
内にエンコーディングされた定理である型の全域値 (ほぼ全域関数になるでしょう) を実装することを意味します。
ここでの全域とは純粋で停止することを意味しています。
このスタイルの定理証明はまだ体験していない人にはやや風変わりに見えるかもしれません。
")#comment("para")
")

#langeng("
#para("\
As a simple introductory example, let us first construct a proof
function in ATS/LF that is given the following interface:

#sats2xhtml("\
prfun mul_istot {m,n:int} (): [p:int] MUL(m, n, p)
")

The keyword #keycode("prfun") indicates that the interface is for a proof
function (in contrast to a non-proof function).  Note that
#dyncode("mul_istot") is declared to be of the following type (or more
accurately, prop):

#atscode("{m,n:int} () -<prf> [p:int] MUL(m, n, p)")

which essentially states that integer multiplication is a total function:
Given any two integers m and n, there exists an integer p such that m, n
and p are related according to the structurally inductively defined
relation #stacode("MUL"). The following code gives an implementation of
#dyncode("mul_istot"):

#dats2xhtml("\
primplement
mul_istot{m,n}() = let
//
prfun istot
  {m:nat;n:int} .<m>. (): [p:int] MUL(m, n, p) =
  sif m > 0 then MULind(istot{m-1,n}()) else MULbas()
// end of [istot]
//
in
  sif m >= 0 then istot{m,n}() else MULneg(istot{~m,n}())
end // end of [mul_istot]  
")

Note that the keyword #keycode("primplement") (instead of
#keycode("implement")) initiates the implementation of a proof.  The inner
proof function #dyncode("istot") encodes a proof showing that there exists
an integer p for any given natural number m and integer n such that m, n
and p are related (according to #stacode("MUL")).  The keyword
#keycode("sif") is used for forming a conditional (proof) expression in
which the test is a static expression.  The proof encoded by
#dyncode("istot") proceeds by induction on m; if m > 0 holds, then there
exists an integer p1 such that m-1, n and p1 are related by induction
hypothesis (on m-1) and thus m, n and p are related for p = p1+n according
to the rule encoded by #dyncode("MULind"); if m = 0, then m, n and p are
related for p = 0. The proof encoded by the implementation of
#dyncode("mul_istot") goes like this: if m is a natural number, then the
lemma proven by #dyncode("istot") shows that m, n and some p are related;
if m is negative, then the same lemma shows that ~m, n and p1 are related
for some integer p1 and thus m, n and p are related for p = ~p1 according
to the rule encoded by #dyncode("MULneg").\

")#comment("para")
")
#langja("
#para("\
はじめに単純で初歩的な例として、次のインターフェイスで与えられる ATS/LF の証明関数をコンストラクトしてみましょう:

#sats2xhtml("\
prfun mul_istot {m,n:int} (): [p:int] MUL(m, n, p)
")

キーワード #keycode("prfun") は (非証明関数ではなく) 証明関数のインターフェイスを示しています。
#dyncode("mul_istot") は次の型 (より正確には命題) で宣言されていることに注意してください:

#atscode("{m,n:int} () -<prf> [p:int] MUL(m, n, p)")

これは本質的に整数の乗法が全域関数であると言っています。
2つのどのような整数 m と n が与えられても、構造的帰納的に定義 #stacode("MUL") に従った m, n, p
の関係にあるような整数 p が存在します。
次のコードは #dyncode("mul_istot") の実装です:

#dats2xhtml("\
primplement
mul_istot{m,n}() = let
//
prfun istot
  {m:nat;n:int} .<m>. (): [p:int] MUL(m, n, p) =
  sif m > 0 then MULind(istot{m-1,n}()) else MULbas()
// end of [istot]
//
in
  sif m >= 0 then istot{m,n}() else MULneg(istot{~m,n}())
end // end of [mul_istot]  
")

(#keycode("implement") ではなく) キーワード #keycode("primplement") は証明の実装の開始です。
内部の証明関数 #dyncode("istot") は、与えられたどんな自然数 m と整数 n についても #stacode("MUL")
に従った m, n, p の関係にあるような整数 p が存在することを示す証明をエンコードしています。
キーワード #keycode("sif") は条件が静的な式であるような (証明の) 条件式を作るのに使われます。
#dyncode("istot") にエンコードされている証明は m について帰納的に進みます;
もし m > 0 なら、m-1, n, p1 が (m-1 としてときの) 帰納法の仮定関係しているような整数 p1
が存在し、したがって m, n, p は関係していて #dyncode("MULind") にエンコードされた規則によれば p = p1+n です;
もし m = 0 なら、m, n, p は関係していて p = 0 です。
#dyncode("mul_istot") の実装にエンコードされている証明は次のようなものです:
もし m が自然数なら、#dyncode("istot") で 証明された補題が m, n, p が関係していることを示しています;
もし m が負の数なら、同じ補題がなんらかの整数 p1 について ~m, n, p1 が関係していることを示していて、したがって
m, n, p は関係していて #dyncode("MULneg") にエンコードされた規則によれば p = ~p1 です。\

")#comment("para")
")

#langeng("
#para("\

As another example of theorem-proving in ATS/LF, a proof function of
the name #dyncode("mul_isfun") is given as follows:

#dats2xhtml("\
prfn mul_isfun
  {m,n:int}{p1,p2:int}
(
  pf1: MUL(m, n, p1), pf2: MUL(m, n, p2)
) : [p1==p2] void = let
  prfun isfun
    {m:nat;n:int}{p1,p2:int} .<m>.
  (
    pf1: MUL(m, n, p1), pf2: MUL(m, n, p2)
  ) : [p1==p2] void =
    case+ pf1 of
    | MULind(pf1prev) => let
        prval MULind(pf2prev) = pf2 in isfun (pf1prev, pf2prev)
      end // end of [MULind]
    | MULbas() => let
        prval MULbas() = pf2 in ()
      end // end of [MULbas]
  // end of [isfun]
in
  case+ pf1 of
  | MULneg(pf1nat) => let
      prval MULneg(pf2nat) = pf2 in isfun (pf1nat, pf2nat)
    end // end of [MULneg]
  | _ (*non-MULneg*) =>> isfun (pf1, pf2)
end // end of [mul_isfun]
")

The keyword #keycode("prfn") is used for defining a non-recursive proof
function, and the keyword #keycode("prval") for introducing bindings that
relate names to proof expressions, that is, expressions of prop-types. As
far as pattern matching exhaustiveness is concerned, #keycode("prval") is
equivalent to #keycode("val+") (as proofs cannot contain any effects such
as failures of pattern matching).\

")
")
#langja("
#para("\

ATS/LF における定理証明の別の例として、
次のような #dyncode("mul_isfun") という名前の証明関数を見てみましょう:

#dats2xhtml("\
prfn mul_isfun
  {m,n:int}{p1,p2:int}
(
  pf1: MUL(m, n, p1), pf2: MUL(m, n, p2)
) : [p1==p2] void = let
  prfun isfun
    {m:nat;n:int}{p1,p2:int} .<m>.
  (
    pf1: MUL(m, n, p1), pf2: MUL(m, n, p2)
  ) : [p1==p2] void =
    case+ pf1 of
    | MULind(pf1prev) => let
        prval MULind(pf2prev) = pf2 in isfun (pf1prev, pf2prev)
      end // end of [MULind]
    | MULbas() => let
        prval MULbas() = pf2 in ()
      end // end of [MULbas]
  // end of [isfun]
in
  case+ pf1 of
  | MULneg(pf1nat) => let
      prval MULneg(pf2nat) = pf2 in isfun (pf1nat, pf2nat)
    end // end of [MULneg]
  | _ (*non-MULneg*) =>> isfun (pf1, pf2)
end // end of [mul_isfun]
")

キーワード #keycode("prfn") は再帰的ではない証明関数を定義するために使われます。
またキーワード #keycode("prval") は証明の式、つまり命題型の式に関連する名前を束縛します。
網羅的なパターンマッチの範囲では、#keycode("prval") は #keycode("val+") と等価です
(証明はパターンマッチの失敗のような作用を含むことができません)。\

")
")

#langeng("
#para("\

What #dyncode("mul_isfun") proves is that the relation #stacode("MUL") is
functional on its first two arguments: If m, n and p1 are related according
to #stacode("MUL") and m, n and p2 are also related according to
#stacode("MUL"), then p1 and p2 are equal.  The statement is first proven
by the inner proof function #dyncode("isfun") under the assumption that m
is a natural number, and then the assumption is dropped.  Let us now take a
look at the first matching clause in the body of #dyncode("isfun"). If the
clause is chosen, then #dyncode("pf1") matches the pattern
#dyncode("MULind(pf1prev)") and thus #dyncode("pf1prev") is of the type
#dyncode("MUL(m1, n1, q1)") for some natural number m1 and integer n1 and
integer p1 such that m=m1+1, n=n1, and p1=q1+n1. This means that
#dyncode("pf2") must be of the form #dyncode("MULind(pf2prev)") for some
#dyncode("pf2prev") of the type #dyncode("MUL(m2, n2, q2)") such that
m2+1=m, n2=n and p2=q2+n2. By calling #dyncode("isfun") on #dyncode("pf1prev")
and #dyncode("pf2prev"), which amounts to invoking the induction hypothesis
on m-1, we establish q1=q2, which implies p1=p2. The second matching clause
in the body of #dyncode("isfun") can be readily understood, which
corresponds to the base case in the inductive proof encoded by
#dyncode("isfun").\

")
")
#langja("
#para("\

#dyncode("mul_isfun") が証明しているのは、関係 #stacode("MUL") が最初の2つの引数について関数的だということです:
もし m, n, p1 が #stacode("MUL") によって関係していて、m, n, p2 もまた #stacode("MUL")
によって関係しているなら、p1 と p2 は等しくなります。
これは、m が自然数であるという仮定で内部の証明関数 #dyncode("isfun") によって最初に証明されます。
そしてその後この仮定は破棄されます。
ここで #dyncode("isfun") の本体で1番目にマッチする節を見てみましょう。
もしこの節が選択されたら、
#dyncode("pf1") はパターン #dyncode("MULind(pf1prev)") にマッチし、従って #dyncode("pf1prev") の型は自然数
m1 と 整数 n1, p1 があるとき #dyncode("MUL(m1, n1, q1)") になります。
そして m=m1+1, n=n1, p1=q1+n1 であるような整数 p1 が存在します。
これは m2+1=m, n2=n, p2=q2+n2 のような型 #dyncode("MUL(m2, n2, q2)") の #dyncode("pf2prev")
があるとき、 #dyncode("pf2") が #dyncode("MULind(pf2prev)") でなければならないことを意味しています。
#dyncode("pf1prev") と #dyncode("pf2prev") について #dyncode("isfun") を呼び出すし、 m-1
における帰納法の仮定を使うと、q1=q2 を証明でき、これは p1=p2 を示しています。
#dyncode("isfun") の本体で2番目にマッチする節はたやすく理解できるでしょう。
これは #dyncode("isfun") にエンコードされた帰納的証明の基底部に相当します。\

")
")

</sect1><!--id="constructing_proofs_as_total_functions"-->

<!-- ****** ****** -->

<sect1
 id="example_distributivity_of_multiplication">
#langeng("
#title("Example: Distributivity of Multiplication")
")
#langja("
#title("例: 乗法の分配法則")
")

#langeng("
#para("\
The distributivity of multiplication over addition means that the following
equation holds

#atscode("m * (n1 + n2) = m * n1 + m * n2")

for m, n1 and n2 ranging over integers. A direct encoding of the equation
is given by the following (proof) function interface:

#sats2xhtml("\
//
prfun
mul_distribute
  {m,n1,n2:int}{p1,p2:int}
  (MUL(m, n1, p1), MUL(m, n2, p2)): MUL(m, n1+n2, p1+p2)
//
")

Plainly speaking, the encoding states that the product of m and (n1+n2) is
p1+p2 if the product of m and n1 is p1 and the product of m and n2 is p2.
An implementation of #dyncode("mul_distribute") is given as follows:

#dats2xhtml("\
primplement
mul_distribute
{m,n1,n2}{p1,p2}
  (pf1, pf2) = let
//
prfun
auxnat
{m:nat}{p1,p2:int} .<m>.
(
  pf1: MUL(m, n1, p1), pf2: MUL(m, n2, p2)
) : MUL(m, n1+n2, p1+p2) =
(
  case+ (pf1, pf2) of
  | (MULbas(), MULbas()) => MULbas()
  | (MULind pf1, MULind pf2) => MULind(auxnat (pf1, pf2))
) (* end of [auxnat] *)
//
in
//
sif
m >= 0
then (
  auxnat (pf1, pf2)
) // end of [then]
else let
  prval MULneg(pf1) = pf1
  prval MULneg(pf2) = pf2
in
  MULneg(auxnat (pf1, pf2))
end // end of [else]
//
end // end of [mul_distribute]
")

The inner function #dyncode("auxnat") encodes a straighforward
proof based on mathematical induction that establishes the following
equation:

#atscode("\
m * (n1 + n2) = m * n1 + m * n2
")

for m ranging over natural numbers and n1 and n2 ranging over integers. The
function #dyncode("mul_distribute") can then be implemented immediately
based on #dyncode("auxnat").\

")
")
#langja("
#para("\
加法に対する乗法の分配法則は次の等式を意味しています:

#atscode("m * (n1 + n2) = m * n1 + m * n2")

m, n1, n2 は整数の範囲を持ちます。
この等式を直接エンコードすると次のような (証明の) 関数インターフェイスが得られます:

#sats2xhtml("\
//
prfun
mul_distribute
  {m,n1,n2:int}{p1,p2:int}
  (MUL(m, n1, p1), MUL(m, n2, p2)): MUL(m, n1+n2, p1+p2)
//
")

端的に言うと、このエンコードは
m と n1 の積が p1 でありかつ m と n2 の積が p2 であったなら m と (n1+n2) の積は p1+p2 になる、と言っています。
#dyncode("mul_distribute") の実装は次のようになります:

#dats2xhtml("\
primplement
mul_distribute
{m,n1,n2}{p1,p2}
  (pf1, pf2) = let
//
prfun
auxnat
{m:nat}{p1,p2:int} .<m>.
(
  pf1: MUL(m, n1, p1), pf2: MUL(m, n2, p2)
) : MUL(m, n1+n2, p1+p2) =
(
  case+ (pf1, pf2) of
  | (MULbas(), MULbas()) => MULbas()
  | (MULind pf1, MULind pf2) => MULind(auxnat (pf1, pf2))
) (* end of [auxnat] *)
//
in
//
sif
m >= 0
then (
  auxnat (pf1, pf2)
) // end of [then]
else let
  prval MULneg(pf1) = pf1
  prval MULneg(pf2) = pf2
in
  MULneg(auxnat (pf1, pf2))
end // end of [else]
//
end // end of [mul_distribute]
")

本質的に、
内部の関数 #dyncode("auxnat") は次の等式を満たす数学的帰納法の証明を素直にエンコードしています:

#atscode("\
m * (n1 + n2) = m * n1 + m * n2
")

m は自然数の範囲を取り、n1 と n2 は整数の範囲を取ります。
関数 #dyncode("mul_distribute") は #dyncode("auxnat") を使ってすぐに実装できます。\

")
")

</sect1><!--id="example_distributivity_of_multiplication"-->

<!-- ****** ****** -->

<sect1
 id="example_commutativity_of_multiplication">
#langeng("
#title("Example: Commutativity of Multiplication")
")
#langja("
#title("例: 乗法の交換法則")
")

#langeng("
#para("\
The commutativity of multiplication means that the following equation
holds

#atscode("m * n = n * m")

for m and n ranging over integers. A direct encoding of this equation
is given by the following (proof) function interface:

#sats2xhtml("\
//
prfun
mul_commute{m,n:int}{p:int}(MUL(m, n, p)): MUL(n, m, p)
//
")

An implementation of #dyncode("mul_commute") is given as follows:

#dats2xhtml("\
primplmnt
mul_commute
  {m,n}{p}(pf0) = let
//
prfun
auxnat
{m:nat}
{p:int} .<m>.
(
pf: MUL(m, n, p)
) : MUL(n, m, p) =
(
  case+ pf of
  | MULbas() => mul_nx0_0{n}()
  | MULind(pf1) =>
      mul_distribute(auxnat(pf1), mul_nx1_n{n}())
    // end of [MULind]
) (* end of [auxnat] *)
//
in
//
sif
m >= 0
then auxnat(pf0)
else let
  prval MULneg(pf1) = pf0 in mul_neg_2(auxnat(pf1))
end // end of [else]
//
end // end of [mul_commute]
")

where the following proof functions are called:

#sats2xhtml("\
//
prfun
mul_nx0_0{n:int}(): MUL(n, 0, 0) // n * 0 = 0
//
prfun
mul_nx1_n{n:int}(): MUL(n, 1, n) // n * 1 = n
//
prfun
mul_neg_2
  {m,n:int}{p:int}(MUL(m,n,p)): MUL(m,~n,~p) // m*(~n) = ~(m*n)
//
")

The inner function #dyncode("auxnat") encodes a straighforward
proof based on mathematical induction that establishes the following
equation:

#atscode("m * n = n * m")

for m ranging over natural numbers and n ranging over integers.
The function #dyncode("mul_commute") can then be implemented immediately
based on #dyncode("auxnat").\
")
")
#langja("
#para("\
乗法の交換法則は次の等式を意味しています:

#atscode("m * n = n * m")

このとき m と n は整数の範囲を持ちます。この等式を直接エンコードすると次のような (証明の) 関数インターフェイスが得られます:

#sats2xhtml("\
//
prfun
mul_commute{m,n:int}{p:int}(MUL(m, n, p)): MUL(n, m, p)
//
")

#dyncode("mul_commute") の実装は次のようになります:

#dats2xhtml("\
primplmnt
mul_commute
  {m,n}{p}(pf0) = let
//
prfun
auxnat
{m:nat}
{p:int} .<m>.
(
pf: MUL(m, n, p)
) : MUL(n, m, p) =
(
  case+ pf of
  | MULbas() => mul_nx0_0{n}()
  | MULind(pf1) =>
      mul_distribute(auxnat(pf1), mul_nx1_n{n}())
    // end of [MULind]
) (* end of [auxnat] *)
//
in
//
sif
m >= 0
then auxnat(pf0)
else let
  prval MULneg(pf1) = pf0 in mul_neg_2(auxnat(pf1))
end // end of [else]
//
end // end of [mul_commute]
")

このとき、次の証明関数が使われています:

#sats2xhtml("\
//
prfun
mul_nx0_0{n:int}(): MUL(n, 0, 0) // n * 0 = 0
//
prfun
mul_nx1_n{n:int}(): MUL(n, 1, n) // n * 1 = n
//
prfun
mul_neg_2
  {m,n:int}{p:int}(MUL(m,n,p)): MUL(m,~n,~p) // m*(~n) = ~(m*n)
//
")

内部の関数 #dyncode("auxnat") は次の等式を満たす数学的帰納法の証明を素直にエンコードしています:

#atscode("m * n = n * m")

このとき m は自然数の範囲を、n は整数の範囲を取ります。関数 #dyncode("mul_commute") は #dyncode("auxnat") を使ってすぐに実装できるでしょう。\
")
")

</sect1><!--id="example_commutativity_of_multiplication"-->

<!-- ****** ****** -->

<sect1 id="datasorts">
#langeng("
#title("Algebraic Datasorts")
")
#langja("
#title("代数的なデータ種 (datasort)")
")

#langeng("
#para("\
A datasort is rather similar to a dataype. However, the former is
declared in the statics of ATS while the latter in the dynamics of ATS. To
see a typical need for datasorts, let us try to encode a theorem in ATS
stating that s is strictly less than 2<superscript>h</superscript> if s and
h are the size and height, respectively, of a given binary tree. To
represent binary trees in the statics, we first declare a datasort as
follows:

#sats2xhtml("\
datasort tree = E of () | B of (tree, tree)
")

The name of the declared datasort is #stacode("tree") and there are two
constructor associated with it: #stacode("E") and #stacode("B"), where E
forms the empty tree and B forms a tree by joining two given trees.  For
instance, #stacode("B(E(), E())") is a static term of the sort
#stacode("tree") that represents a singleton tree, that is, a tree
consisting of exactly one node.  Please note that the trees formed by E and
B are really just tree skeletons carrying no data.\

")
")
#langja("
#para("\
データ種 (datasort) はデータ型 (datatype) に少し似ています。
けれども、後者は ATS の動的な宣言ですが、前者は ATS の静的な宣言です。
データ種の典型的な用途を見るために、
s と h がそれぞれ与えられた二分木のサイズと高さであるなら、s がきっちり 2<superscript>h</superscript>
より小さくなることを示す定理を ATS でエンコードしてみましょう。
二分木を静的に表わすために、まず次のデータ種を宣言しましょう:

#sats2xhtml("\
datasort tree = E of () | B of (tree, tree)
")

宣言した データ種 の名前は #stacode("tree") で、関連する2つのコンストラクタがあります:
それは #stacode("E") と #stacode("B") で、E は空の木を作り、B は与えられた2つの木を結合した木を作ります。
例えば、#stacode("B(E(), E())") は種 #stacode("tree") の静的な項で、シングルトン木を表わしています。
つまりノードが1つしかない木です。
E と B で作った木は全くデータを保持しない骨だけの木であることに注意してください。\

")
")

#langeng("
#para("\
We now declare two dataprops as follows for capturing the notion of
size and height of trees:

#sats2xhtml("\
//
dataprop
SZ (tree, int) =
  | SZE (E (), 0) of ()
  | {tl,tr:tree}{sl,sr:nat}
    SZB (B (tl, tr), 1+sl+sr) of (SZ (tl, sl), SZ (tr, sr))
// end of [SZ]
//
dataprop
HT (tree, int) =
  | HTE (E (), 0) of ()
  | {tl,tr:tree}{hl,hr:nat}
    HTB (B (tl, tr), 1+max(hl,hr)) of (HT (tl, hl), HT (tr, hr))
// end of [HT]
//
")

Given a tree t and an integer s, SZ(t, s) encodes the relation that the
size of t equals s. Similiarly, given a tree t and an integer h, HZ(t, h)
encodes the relation that the height of t equals h.
")
")
#langja("
#para("\
次のように木のサイズと高さの概念を捕捉するために2つのデータ命題を宣言しましょう:

#sats2xhtml("\
//
dataprop
SZ (tree, int) =
  | SZE (E (), 0) of ()
  | {tl,tr:tree}{sl,sr:nat}
    SZB (B (tl, tr), 1+sl+sr) of (SZ (tl, sl), SZ (tr, sr))
// end of [SZ]
//
dataprop
HT (tree, int) =
  | HTE (E (), 0) of ()
  | {tl,tr:tree}{hl,hr:nat}
    HTB (B (tl, tr), 1+max(hl,hr)) of (HT (tl, hl), HT (tr, hr))
// end of [HT]
//
")

木 t と整数 s が与えられた時、SZ(t, s) は t のサイズが s に等しいという関係をエンコードします。
同様に、木 t と整数 h が与えられた時、HZ(t, h) は t の高さが h に等しいという関係をエンコードします。
")
")

#langeng("
#para("\
As the power function (of base 2) is not available in the statics of ATS,
we declare a dataprop as follows to capture it:

#sats2xhtml("\
dataprop
POW2 (int, int) =
  | POW2bas (0, 1)
  | {n:nat}{p:int} POW2ind (n+1, p+p) of POW2 (n, p)
// end of [POW2]
")

Given two integers h and p, POW2 (h, p) encodes the relation that
2<superscript>h</superscript> equals p.
")
")
#langja("
#para("\
2を底にした累乗関数は ATS の静的な部分にはないので、それを捕捉する次のデータ命題を宣言します:

#sats2xhtml("\
dataprop
POW2 (int, int) =
  | POW2bas (0, 1)
  | {n:nat}{p:int} POW2ind (n+1, p+p) of POW2 (n, p)
// end of [POW2]
")

2つの整数 h と p が与えられた時、POW2 (h, p) は 2<superscript>h</superscript> が p
に等しいという関係をエンコードします。
")
")

#langeng("
#para("\
It should be clear by now that the following proof function
interface encodes the theorem stating that s is strictly less than
2<superscript>h</superscript> if s and h are the size and height of a
given binary tree:

#sats2xhtml("\
prfun
lemma_tree_size_height
  {t:tree}{s,h:nat}{p:int}
(
  pf1: SZ (t, s), pf2: HT (t, h), pf3: POW2 (h, p)
) : [s < p] void // end of [prfun]
")

Let us now construct an implementation of this proof function as follows.
")#comment("para")
")
#langja("
#para("\
s と h が与えられた二分木のサイズと高さである時、
s がきっちり 2<superscript>h</superscript> より小さくなることを表わす定理を、
次の証明関数のインターフェイスがエンコードしていることは明確でしょう:

#sats2xhtml("\
prfun
lemma_tree_size_height
  {t:tree}{s,h:nat}{p:int}
(
  pf1: SZ (t, s), pf2: HT (t, h), pf3: POW2 (h, p)
) : [s < p] void // end of [prfun]
")

この証明関数の実装を次のようにコンストラクトしてみましょう。
")#comment("para")
")

#langeng("
#para("\
We first establish some elementary properties on the power function
(of base 2):

#dats2xhtml("\
prfun
pow2_istot
  {h:nat} .<h>. (): [p:int] POW2 (h, p) =
  sif h==0
    then POW2bas () else POW2ind (pow2_istot {h-1} ())
  // end of [sif]
// end of [pow2_istot]

prfun
pow2_pos
  {h:nat}{p:int} .<h>.
  (pf: POW2 (h, p)): [p > 0] void =
  case+ pf of
  | POW2bas () => () | POW2ind (pf1) => pow2_pos (pf1)
// end of [pow2_pos]

prfun
pow2_inc
  {h1,h2:nat | h1 <= h2}{p1,p2:int} .<h2>.
  (pf1: POW2 (h1, p1), pf2: POW2 (h2, p2)): [p1 <= p2] void =
  case+ pf1 of
  | POW2bas () => pow2_pos (pf2)
  | POW2ind (pf11) => let
      prval POW2ind (pf21) = pf2 in pow2_inc (pf11, pf21)
    end // end of [POW2ind]
// end of [pow2_inc]
")

Clearly, #dyncode("pow2_istot") shows that the relation encoded by the
dataprop #stacode("POW2") is a total relation; #dyncode("pow2_pos") proves
that the power of each natural number is positive; #dyncode("pow2_inc")
establishes that the power function is increasing.\

")
")
#langja("
#para("\
はじめに、2を底にした累乗関数のいくつかの基本的な性質を作ります:

#dats2xhtml("\
prfun
pow2_istot
  {h:nat} .<h>. (): [p:int] POW2 (h, p) =
  sif h==0
    then POW2bas () else POW2ind (pow2_istot {h-1} ())
  // end of [sif]
// end of [pow2_istot]

prfun
pow2_pos
  {h:nat}{p:int} .<h>.
  (pf: POW2 (h, p)): [p > 0] void =
  case+ pf of
  | POW2bas () => () | POW2ind (pf1) => pow2_pos (pf1)
// end of [pow2_pos]

prfun
pow2_inc
  {h1,h2:nat | h1 <= h2}{p1,p2:int} .<h2>.
  (pf1: POW2 (h1, p1), pf2: POW2 (h2, p2)): [p1 <= p2] void =
  case+ pf1 of
  | POW2bas () => pow2_pos (pf2)
  | POW2ind (pf11) => let
      prval POW2ind (pf21) = pf2 in pow2_inc (pf11, pf21)
    end // end of [POW2ind]
// end of [pow2_inc]
")

明確に、#dyncode("pow2_istot") はデータ命題 #stacode("POW2")
にエンコードされた関係が全域な関係であることを表わしています;
#dyncode("pow2_pos") は自然数の累乗が正の数になることを証明しています;
#dyncode("pow2_inc") は累乗関数が単調増加であることを証明しています。\

")
")

#langeng("
#para("\

The function #dyncode("lemma_tree_size_height") can be implemented
as follows:

#dats2xhtml("\
primplement
lemma_tree_size_height
  (pf1, pf2, pf3) = let
//
prfun
lemma{t:tree}
  {s,h:nat}{p:int} .<t>.
(
  pf1: SZ (t, s)
, pf2: HT (t, h)
, pf3: POW2 (h, p)
) : [p > s] void =
(
  scase t of
  | E () => let
      prval SZE () = pf1
      prval HTE () = pf2
      prval POW2bas () = pf3
   in
     // nothing
   end // end of [E]
  | B (tl, tr) => let
      prval SZB (pf1l, pf1r) = pf1
      prval HTB {tl,tr}{hl,hr} (pf2l, pf2r) = pf2
      prval POW2ind (pf31) = pf3
      prval pf3l = pow2_istot {hl} ()
      prval pf3r = pow2_istot {hr} ()
      prval () = lemma (pf1l, pf2l, pf3l)
      prval () = lemma (pf1r, pf2r, pf3r)
      prval () = pow2_inc (pf3l, pf31)
      prval () = pow2_inc (pf3r, pf31)
    in
      // nothing
    end // end of [B]
) (* end of [lemma] *)
//
in
  lemma (pf1, pf2, pf3)
end // end of [lemma_tree_size_height]
")

The inner function #dyncode("lemma"), which is given a termination metric
consisting of a static term of the sort #stacode("tree"), corresponds to a
proof based on structural induction (where the involved structure is the
binary tree #dyncode("t")).  Given two terms t1 and t2 of the sort
#stacode("tree"), t1 is (strictly) less than t2 if t1 is a (proper)
substructure of t2. Evidently, this is a well-founded ordering.  The
keyword #keycode("scase") is used to form a dynamic expression that does
case-analysis on a static term (built by constructors associated with some
declared datasort). So the relation between #keycode("sif") and
#keycode("scase") is essentially parallel to that between #keycode("if")
and #keycode("case").  Please find the entirety of the above code
#mycodelink("CHAP_THMPRVING/tree.dats", "on-line").\

")#comment("para")
")
#langja("
#para("\

関数 #dyncode("lemma_tree_size_height") は次のように実装できます:

#dats2xhtml("\
primplement
lemma_tree_size_height
  (pf1, pf2, pf3) = let
//
prfun
lemma{t:tree}
  {s,h:nat}{p:int} .<t>.
(
  pf1: SZ (t, s)
, pf2: HT (t, h)
, pf3: POW2 (h, p)
) : [p > s] void =
(
  scase t of
  | E () => let
      prval SZE () = pf1
      prval HTE () = pf2
      prval POW2bas () = pf3
   in
     // nothing
   end // end of [E]
  | B (tl, tr) => let
      prval SZB (pf1l, pf1r) = pf1
      prval HTB {tl,tr}{hl,hr} (pf2l, pf2r) = pf2
      prval POW2ind (pf31) = pf3
      prval pf3l = pow2_istot {hl} ()
      prval pf3r = pow2_istot {hr} ()
      prval () = lemma (pf1l, pf2l, pf3l)
      prval () = lemma (pf1r, pf2r, pf3r)
      prval () = pow2_inc (pf3l, pf31)
      prval () = pow2_inc (pf3r, pf31)
    in
      // nothing
    end // end of [B]
) (* end of [lemma] *)
//
in
  lemma (pf1, pf2, pf3)
end // end of [lemma_tree_size_height]
")

内部の関数 #dyncode("lemma") は、種 #stacode("tree") の静的な項で構成されている停止性メトリクスを持ちます。
またこの関数は二分木 #dyncode("t") に関連する構造的な帰納法の証明に対応しています。
2つの項 t1 と t2 が種 #stacode("tree") として与えられ、t1 が t2 より小さい構造であるなら、t1 は きっちり t2
より小さくなります。
明らかに、これは根拠の確かな順序です。
キーワード #keycode("scase") は (宣言された データ種 に関連するコンストラクタで構築される)
静的な項のcase判定をする動的な式を作るのに使われます。
そのため、#keycode("sif") と #keycode("scase") の関係は #keycode("if") と #keycode("case") の関係と同じです。
上記のコード全体は #mycodelink("CHAP_THMPRVING/tree.dats", "オンライン") から入手できます。\

")#comment("para")
")

</sect1><!--id="datasorts"-->

<!-- ****** ****** -->

<sect1
 id="example_establishing_properties_on_braun_trees">
#langeng("
#title("Example: Establishing Properties on Braun Trees")
")
#langja("
#title("例: ブラウンツリーの性質を確立する")
")

#langeng("
#para("\

As stated previously in this book, a binary tree is a Braun tree if it is
empty or if its left and right subtrees are Braun trees and the size of the
left one minus the size of the right one is either 0 or 1.  Formally, we
can declare the following dataprop #dyncode("isBraun") to capture the notion
of Braun trees:

#sats2xhtml("\
dataprop
isBraun (tree) =
  | isBraunE (E) of ()
  | {tl,tr:tree}
    {sl,sr:nat | sr <= sl; sl <= sr + 1}
    isBraunB (
      B(tl, tr)) of (isBraun tl, isBraun tr, SZ (tl, sl), SZ (tr, sr)
    ) // end of [isBraunB]
// end of [isBraun]
")
")
")
#langja("
#para("\

この本で以前示したように、空であるか、もしくは左と右の子がブラウンツリーでなおかつ左の子のサイズから右の子のサイズを引くと0もしくは1なら、そのような二分木はブラウンツリーです。
形式的には、ブラウンツリーの概念を捕捉するために、次のデータ命題 #dyncode("isBraun") を宣言できます:

#sats2xhtml("\
dataprop
isBraun (tree) =
  | isBraunE (E) of ()
  | {tl,tr:tree}
    {sl,sr:nat | sr <= sl; sl <= sr + 1}
    isBraunB (
      B(tl, tr)) of (isBraun tl, isBraun tr, SZ (tl, sl), SZ (tr, sr)
    ) // end of [isBraunB]
// end of [isBraun]
")
")
")

#langeng("
#para("\
We first prove that there exists a Braun tree of any given size.
This property can be encoded as follows in ATS:

#sats2xhtml("\
prfun
lemma_existence{n:nat}(): [t:tree] (isBraun (t), SZ (t, n))
")

Literally, the type assigned to #dyncode("lemma_existence") means that there
exists a tree t for any given natural number n such that t is a Braun tree
and the size of t is n. The following code gives an implementation of
#dyncode("lemma_existence"):

#dats2xhtml("\
primplement
lemma_existence
  {n}((*void*)) = let
//
prfun
lemma{n:nat} .<n>.
(
  // argless
) : [t:tree] (isBraun (t), SZ (t, n)) =
  sif n==0
    then (isBraunE (), SZE ())
    else let
      stadef nl = n / 2
      stadef nr = n - 1 - nl
      val (pfl1, pfl2) = lemma{nl}((*void*))
      and (pfr1, pfr2) = lemma{nr}((*void*))
    in
      (isBraunB (pfl1, pfr1, pfl2, pfr2), SZB (pfl2, pfr2))
    end // end of [else]
  // end of [sif]
//
in
  lemma{n}((*void*))
end // end of [lemma_existence]
")

Note that #keycode("stadef") is a keyword in ATS for introducting a static
binding between a name and a static term (of any sort). If one prefers,
this keyword can be chosen to replace the keyword #keycode("typedef") (for
introducing a name and a static term of the sort #keycode("t@ype")).

")#comment("para")
")
#langja("
#para("\
与えられたどんなサイズのブラウンツリーも存在することをはじめに証明しましょう。
この性質は ATS では次のようにエンコードできます:

#sats2xhtml("\
prfun
lemma_existence{n:nat}(): [t:tree] (isBraun (t), SZ (t, n))
")

事実上、#dyncode("lemma_existence") に割り当てられた型は
t がブラウンツリーで t のサイズが n であるような自然数 n が与えられた時、木 t が存在することを意味しています。
次のコードは #dyncode("lemma_existence") の実装です:

#dats2xhtml("\
primplement
lemma_existence
  {n}((*void*)) = let
//
prfun
lemma{n:nat} .<n>.
(
  // argless
) : [t:tree] (isBraun (t), SZ (t, n)) =
  sif n==0
    then (isBraunE (), SZE ())
    else let
      stadef nl = n / 2
      stadef nr = n - 1 - nl
      val (pfl1, pfl2) = lemma{nl}((*void*))
      and (pfr1, pfr2) = lemma{nr}((*void*))
    in
      (isBraunB (pfl1, pfr1, pfl2, pfr2), SZB (pfl2, pfr2))
    end // end of [else]
  // end of [sif]
//
in
  lemma{n}((*void*))
end // end of [lemma_existence]
")

#keycode("stadef") は、名前と (なんらかの種の) 静的な項の間に静的な束縛を導入するための ATS
のキーワードであることに注意してください。
もし望めば、このキーワードは #keycode("typedef") で置き換えることもできます
(名前と種 #keycode("t@ype") の静的な項を束縛します)。

")#comment("para")
")

#langeng("
#para("\
Next we show that two Braun trees of the same size are identical. This
property can be encoded as follows:

#sats2xhtml("\
prfun
lemma_unicity
  {n:nat}{t1,t2:tree}
(
  pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
) : EQ (t1, t2) // end of [lemma_unicity]
")

where #stacode("EQ") is a prop-constructor introduced by the following
dataprop declaration:

#sats2xhtml("\
dataprop EQ (tree, tree) =
  | EQE (E, E) of ()
  | {t1l,t1r:tree}{t2l,t2r:tree}
    EQB (B (t1l, t1r), B (t2l, t2r)) of (EQ (t1l, t2l), EQ (t1r, t2r))
// end of [EQ]
")

Clearly, #stacode("EQ") is the inductively defined equality on trees.
An implementation of the proof function #dyncode("lemma_unicity") is presented
as follows:

#dats2xhtml("\
primplement
lemma_unicity
  (pf1, pf2, pf3, pf4) = let
  prfun lemma{n:nat}{t1,t2:tree} .<n>.
  (
    pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
  ) : EQ (t1, t2) =
    sif n==0
      then let
        prval SZE () = pf3 and SZE () = pf4
        prval isBraunE () = pf1 and isBraunE () = pf2
      in
        EQE ()
      end // end of [then]
      else let
        prval SZB (pf3l, pf3r) = pf3
        prval SZB (pf4l, pf4r) = pf4
        prval isBraunB (pf1l, pf1r, pf1lsz, pf1rsz) = pf1
        prval isBraunB (pf2l, pf2r, pf2lsz, pf2rsz) = pf2
        prval () = SZ_istot (pf1lsz, pf3l) and () = SZ_istot (pf1rsz, pf3r)
        prval () = SZ_istot (pf2lsz, pf4l) and () = SZ_istot (pf2rsz, pf4r)
        prval pfeql = lemma (pf1l, pf2l, pf3l, pf4l)
        prval pfeqr = lemma (pf1r, pf2r, pf3r, pf4r)
      in
        EQB (pfeql, pfeqr)
      end // end of [else]
    // end of [sif]
in
  lemma (pf1, pf2, pf3, pf4)
end // end of [lemma_unicity]
")

Note that the proof function #dyncode("SZ_istot") in this implementation of
#dyncode("lemma_unicity") is given the following interface:

#sats2xhtml("\
prfun
SZ_istot{t:tree}{n1,n2:int}
  (pf1: SZ (t, n1), pf2: SZ (t, n2)): [n1==n2] void
")

which simply states that #stacode("SZ") is a functional relation with
respect to its first parameter, that is, there is at most one n for every
given t such that t and n are related according to #stacode("SZ").

Clearly, the mathematical proof corresponding to this implementation is of
induction on the size n of the two given trees t1 and t2. In the base case
where n is 0, t1 and t2 are equal as they both are the empty tree. In the
inductive case where n > 0, it is proven that n1l and n2l are of the same
value where n1l and n2l are the sizes of the left subtrees of t1 and t2,
respecitvely; similarly, it is also proven that n1r and n2r are of the same
value where n1r and n2r are the sizes of the right subtrees of t1 and t2,
respectively; by induction hypothesis on n1l, the left substrees of t1 and
t2 are the same; by induction hypothesis on n1r, the right substrees of t1
and t2 are the same; by the definition of tree equality (encoded by
#stacode("EQ")), t1 and t2 are the same.\

")#comment("para")
")
#langja("
#para("\
次に、同じサイズの2つのブラウンツリーが同一であることを示します。
この性質は次のようにエンコードできます:

#sats2xhtml("\
prfun
lemma_unicity
  {n:nat}{t1,t2:tree}
(
  pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
) : EQ (t1, t2) // end of [lemma_unicity]
")

#stacode("EQ") は次のデータ命題宣言で導入されている命題コンストラクタです:

#sats2xhtml("\
dataprop EQ (tree, tree) =
  | EQE (E, E) of ()
  | {t1l,t1r:tree}{t2l,t2r:tree}
    EQB (B (t1l, t1r), B (t2l, t2r)) of (EQ (t1l, t2l), EQ (t1r, t2r))
// end of [EQ]
")

#stacode("EQ") が木の等式を帰納的に定義していることは明確です。
証明関数 #dyncode("lemma_unicity") の実装は次のようになります:

#dats2xhtml("\
primplement
lemma_unicity
  (pf1, pf2, pf3, pf4) = let
  prfun lemma{n:nat}{t1,t2:tree} .<n>.
  (
    pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
  ) : EQ (t1, t2) =
    sif n==0
      then let
        prval SZE () = pf3 and SZE () = pf4
        prval isBraunE () = pf1 and isBraunE () = pf2
      in
        EQE ()
      end // end of [then]
      else let
        prval SZB (pf3l, pf3r) = pf3
        prval SZB (pf4l, pf4r) = pf4
        prval isBraunB (pf1l, pf1r, pf1lsz, pf1rsz) = pf1
        prval isBraunB (pf2l, pf2r, pf2lsz, pf2rsz) = pf2
        prval () = SZ_istot (pf1lsz, pf3l) and () = SZ_istot (pf1rsz, pf3r)
        prval () = SZ_istot (pf2lsz, pf4l) and () = SZ_istot (pf2rsz, pf4r)
        prval pfeql = lemma (pf1l, pf2l, pf3l, pf4l)
        prval pfeqr = lemma (pf1r, pf2r, pf3r, pf4r)
      in
        EQB (pfeql, pfeqr)
      end // end of [else]
    // end of [sif]
in
  lemma (pf1, pf2, pf3, pf4)
end // end of [lemma_unicity]
")

#dyncode("lemma_unicity") のこの実装内の証明関数 #dyncode("SZ_istot")
は次のインターフェイスを持つことに注意してください:

#sats2xhtml("\
prfun
SZ_istot{t:tree}{n1,n2:int}
  (pf1: SZ (t, n1), pf2: SZ (t, n2)): [n1==n2] void
")

これは #stacode("SZ") がその最初のパラメータに関して関数的な関係であることを単純に表わしています。
つまり、#stacode("SZ") によって関係付けられた t と n があるとい、どのような t が与えられても1つ以上の n
が存在します。

明確に、この実装に対応する数学的証明は与えられた2つの木 t1 と t2 のサイズ n に対する帰納法で証明されます。
n が 0 の基底部では、t1 と t2 は両方とも空の木なので等しくなります。
n > 0 の場合、帰納的に、それぞれ t1 と t2 の左の子のサイズである n1l と n2l が同じ値であることを証明します;
同様に、それぞれ t1 と t2 の右の子のサイズである n1r と n2r が同じ値であることを証明します;
n1l について帰納法の仮定から、t1 と t2 の左の子は同じです;
n1r について帰納法の仮定から、t1 と t2 の右の子は同じです;
木の等式の定義 (#stacode("EQ") にエンコードされています) から、t1 と t2 は同じです。\

")#comment("para")
")

#langeng("
#para("\

As a comparison, the following code gives another implementation of
#dyncode("lemma_unicity") that is of a different (and rather unusual) style:

#dats2xhtml("\
primplement
lemma_unicity
  (pf1, pf2, pf3, pf4) = let
//
prfun
lemma{n:nat}{t1,t2:tree} .<t1>.
(
  pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
) : EQ (t1, t2) =
  case+ (pf1, pf2) of
//
  | (isBraunE (), isBraunE ()) => EQE ()
//
  | (isBraunB (pf11, pf12, pf13, pf14),
     isBraunB (pf21, pf22, pf23, pf24)) => let
//
      prval SZB (pf31, pf32) = pf3
      prval SZB (pf41, pf42) = pf4
//
      prval () = SZ_istot (pf13, pf31)
      prval () = SZ_istot (pf23, pf41)
//
      prval () = SZ_istot (pf14, pf32)
      prval () = SZ_istot (pf24, pf42)
//
      prval pfeq1 = lemma (pf11, pf21, pf31, pf41)
      prval pfeq2 = lemma (pf12, pf22, pf32, pf42)
    in
      EQB (pfeq1, pfeq2)
    end
//
  | (isBraunE _, isBraunB _) =/=>
    let prval SZE _ = pf3 and SZB _ = pf4 in (*none*) end
  | (isBraunB _, isBraunE _) =/=>
    let prval SZB _ = pf3 and SZE _ = pf4 in (*none*) end
//
in
  lemma (pf1, pf2, pf3, pf4)
end // end of [lemma_unicity]
")

This implementation corresponds to a proof by induction on the structure of
the given tree t1. Note that the use of the special symbol #keycode("=/=>"),
which is a keyword in ATS, is to indicate to the typechecker of ATS that
the involved clause of pattern matching is #emphasis("unreachable"): It is the
responsibility of the programmer to establish the falsehood on the
right-hand side of the clause. Please find the entirety of the above code
#mycodelink("CHAP_THMPRVING/brauntree.dats", "on-line").\

")#comment("para")
")
#langja("
#para("\

比較として、次のコードは #dyncode("lemma_unicity") の別の実装ですが、少し独特のスタイルです:

#dats2xhtml("\
primplement
lemma_unicity
  (pf1, pf2, pf3, pf4) = let
//
prfun
lemma{n:nat}{t1,t2:tree} .<t1>.
(
  pf1: isBraun t1, pf2: isBraun t2, pf3: SZ (t1, n), pf4: SZ (t2, n)
) : EQ (t1, t2) =
  case+ (pf1, pf2) of
//
  | (isBraunE (), isBraunE ()) => EQE ()
//
  | (isBraunB (pf11, pf12, pf13, pf14),
     isBraunB (pf21, pf22, pf23, pf24)) => let
//
      prval SZB (pf31, pf32) = pf3
      prval SZB (pf41, pf42) = pf4
//
      prval () = SZ_istot (pf13, pf31)
      prval () = SZ_istot (pf23, pf41)
//
      prval () = SZ_istot (pf14, pf32)
      prval () = SZ_istot (pf24, pf42)
//
      prval pfeq1 = lemma (pf11, pf21, pf31, pf41)
      prval pfeq2 = lemma (pf12, pf22, pf32, pf42)
    in
      EQB (pfeq1, pfeq2)
    end
//
  | (isBraunE _, isBraunB _) =/=>
    let prval SZE _ = pf3 and SZB _ = pf4 in (*none*) end
  | (isBraunB _, isBraunE _) =/=>
    let prval SZB _ = pf3 and SZE _ = pf4 in (*none*) end
//
in
  lemma (pf1, pf2, pf3, pf4)
end // end of [lemma_unicity]
")

この実装は与えられた木 t1 の構造に対する帰納法の証明に対応します。
特殊記号 #keycode("=/=>") の使用に注意してください。
これは ATS のキーワードで、パターンマッチに含まれる節が #emphasis("到達不能") であることを ATS
の型検査器に指示します;
節の右辺に嘘を書くのはプログラマの責務です。
上記のコード全体は #mycodelink("CHAP_THMPRVING/brauntree.dats", "オンライン") から入手できます。\

")#comment("para")
")

</sect1><!--id="example_establishing_properties_on_braun_trees"-->

<!-- ****** ****** -->

<sect1
 id="programmer_centric_theorem_proving">
#langeng("
#title("Programmer-Centric Theorem-Proving")
")
#langja("
#title("プログラマ中心の定理証明")
")

#langeng("
#para("\

I have so far presented several formal proofs in ATS.  However,
constructing such formal proofs is at most a secondary issue in ATS. If I
compare ATS with theorem-proving systems such as Isabelle and Coq, I would
like to state emphatically that the design for theorem-proving in ATS takes
a fundamentally different view of theorem-proving. In particular,
theorem-proving in ATS does not take a foundational approach that
establishes the validity of a theorem by reducing it to the validity of a
minimal set of axioms and rules. Instead, theorem-proving in ATS is mostly
done in a semi-formal manner and its primary purpose is to greatly diminish
the chance of a programmer making use of incorrect assumptions or
claims. In this regard, theorem-proving in ATS is rather similar to
contructing informal paper-and-pencil proofs (in mathematics and
elsewhere). I refer to this style of theorem-proving in ATS as being
programmer-centric.  In order to allow the reader to obtain a more concrete
feel as to what this style of theorem-proving is like, I present in the
rest of this section a simple but telling example of programmer-centric
theorem-proving.\

")#comment("para")
")
#langja("
#para("\

ATS におけるいくつかの形式の証明をこれまで紹介してきました。けれども、そのような証明を構築することは、ATSにおいて最重要ではありません。もし私が Isabelle や Coq のような定理証明システムと ATS を比較するとしたら、ATS における定理証明のデザインは定理証明に対する視点が根本的に異なることを指摘したいと思います。特に、ATS における定理証明は、定理を公理や法則の最小集合の正当性に変換することで、その正当さを立証するような基礎的なアプローチを取りません。その代わりに、ATS での定理証明は準形式的な作法で行なわれ、その主眼は、間違った仮定や要求をプログラマが使ってしまう可能性を大きく減少させることです。この点において、ATS の定理証明は (数学その他における) 紙とペンによる非形式的な証明の構築に似ています。私は ATS における定理証明のこのスタイルをプログラマ中心であると呼んでいます。このような定理証明のスタイルがどのようなものなのか、読者により具体的な実感を得てもらうために、この章では単純かつ有用なプログラマ中心の定理証明の例を示します。\

")#comment("para")
")

#langeng("
#para("\

Suppose we are to prove that the square of any rational number cannot equal
2. Note that this statement is a bit weaker than the one stating that the
square root of 2 is irrational as the latter assumes the very existence of the
square root of 2. Let us first sketch an informal proof as follows.\

")#comment("para")
")
#langja("
#para("\

有理数の二乗が2に等しくないことを証明することを想像してみましょう。この表明は、2の平方根が有理数でない表明より少し弱いことに注意してください。後者は2の平方根の存在を仮定しています。はじめに、次のような非形式的な証明をスケッチしてみましょう。\

")#comment("para")
")

#langeng("
#para("\

Suppose (m/n)#sup("2")=2 for some positive numbers m and n. Clearly,
this means (m)#sup("2")=2(n)#sup("2"), implying m being an even number.
Let m=2m#sub("2"). We have (2m#sub("2"))#sup("2")=2(n)#sup("2"), implying
(n/m#sub("2"))#sup("2")=2. Clearly, m &gt; n &gt; m#sub("2") holds. If we
assume that m is the least positive number satisfying (m/n)#sup("2")=2 for
some n, then a contradiction is reached as n satisfies the same property.
Therefore, there is no rational number whose square equals 2. Clearly,
this proof still holds if the number 2 is replaced with another prime number.

")#comment("para")
")
#langja("
#para("\

なんらかの正の数 m と n について、(m/n)#sup("2")=2 を考えます。これは (m)#sup("2")=2(n)#sup("2") を意味し、m は偶数であることを暗示しています。m=2m#sub("2") としてみると、(2m#sub("2"))#sup("2")=2(n)#sup("2") が得られ、これは (n/m#sub("2"))#sup("2")=2 を暗示しています。明確に、m &gt; n &gt; m#sub("2") ということになります。なんらかの n について (m/n)#sup("2")=2 を満たすような最小の正の数を m と仮定すると、n は m と同じ特性を持つことになり、矛盾が生じます。従って、二乗が2に等しくなる有理数は存在しません。数2を別の素数で置き換えてもこの証明は成立することも明確です。

")#comment("para")
")

#langeng("
#para("\

The primary argument in the above informal proof can be encoded in
ATS as follows:

#dats2xhtml('\
//
extern
prfun
mylemma_main
{m,n,p:int | m*m==p*n*n}(PRIME(p)): [m2:nat | n*n==p*m2*m2] void
//
primplmnt
mylemma_main
{m,n,p}(pfprm) = let
  prval pfeq_mm_pnn =
    eqint_make{m*m,p*n*n}()
  prval () = square_is_nat{m}()
  prval () = square_is_nat{n}()
  prval () = lemma_PRIME_param(pfprm)
  prval
  pfmod1 =
    lemma_MOD0_intr{m*m,p,n*n}()
  prval
  pfmod2 = mylemma1{m,p}(pfmod1, pfprm)
  prval
  [m2:int]
  EQINT() =
    lemma_MOD0_elim(pfmod2)
  prval EQINT() = pfeq_mm_pnn
  prval () =
  __assert{p}{p*m2*m2,n*n}() where
  {
    extern prfun __assert{p:pos}{x,y:int | p*x==p*y}(): [x==y] void
  } (* end of [where] *) // end of [prval]
in
  #[m2 | ()]
end // end of [mylemma_main]
//
')

The interface for #dyncode("mylemma_main") states that
(m)#sup("2")=p(n)#sup("2") implies (n)#sup("2")=p(m#sub("2"))#sup("2") for
some natural number m#sub("2").

")
")
#langja("
#para("\

上記の非形式的な証明における主な論拠は、ATS では次のようにエンコードできます:

#dats2xhtml('\
//
extern
prfun
mylemma_main
{m,n,p:int | m*m==p*n*n}(PRIME(p)): [m2:nat | n*n==p*m2*m2] void
//
primplmnt
mylemma_main
{m,n,p}(pfprm) = let
  prval pfeq_mm_pnn =
    eqint_make{m*m,p*n*n}()
  prval () = square_is_nat{m}()
  prval () = square_is_nat{n}()
  prval () = lemma_PRIME_param(pfprm)
  prval
  pfmod1 =
    lemma_MOD0_intr{m*m,p,n*n}()
  prval
  pfmod2 = mylemma1{m,p}(pfmod1, pfprm)
  prval
  [m2:int]
  EQINT() =
    lemma_MOD0_elim(pfmod2)
  prval EQINT() = pfeq_mm_pnn
  prval () =
  __assert{p}{p*m2*m2,n*n}() where
  {
    extern prfun __assert{p:pos}{x,y:int | p*x==p*y}(): [x==y] void
  } (* end of [where] *) // end of [prval]
in
  #[m2 | ()]
end // end of [mylemma_main]
//
')

#dyncode("mylemma_main") のインターフェイスは、なんらかの自然数 m#sub("2") について、(m)#sup("2")=p(n)#sup("2") は (n)#sup("2")=p(m#sub("2"))#sup("2") を意味することを表明しています。

")
")

#langeng("
#para("\

Given two integers m and p, #dyncode("MOD0(m,p)") means that m equals the
product of p and q for some natural number q. This meaning is encoded into
the following two proof functions:

#sats2xhtml("\
//
prfun
lemma_MOD0_intr{m,p,q:nat | m==p*q}(): MOD0(m, p)
//
prfun
lemma_MOD0_elim{m,p:int}(MOD0(m, p)): [q:nat] EQINT(m, p*q)
//
")

where #dyncode("EQINT") is a dataprop declared as follows:

#sats2xhtml('\
dataprop EQINT(int, int) = {x:int} EQINT(x, x)
')

Given two integers x and y, #dyncode("EQINT(x, y)") simply means that
x equals y.  Also, the function #dyncode("eqint_make") is assgined the
interface below:

#sats2xhtml('\
prfun eqint_make{x,y:int | x == y}((*void*)): EQINT (x, y)
')

Given an integer p, #dyncode("PRIME(p)") means that p is a prime number.
The following two proof functions are called in the above implementation
of #dyncode("mylemma_main"):

#sats2xhtml('\
//
prfun lemma_PRIME_param{p:int}(PRIME(p)): [p >= 2] void
//
prfun mylemma1{n,p:int}(MOD0(n*n, p), PRIME(p)): MOD0(n, p)
//
')

The proof function #dyncode("mylemma1") encodes a proposition stating that
p divides n if p divides the square of n and p is also a prime number.
I give no implementation of #dyncode("mylemma1") as I see the encoded
proposition to be obviously true. Certainly, this is a kind of programmer-centric
judgment. \

")
")
#langja("
#para("\

2つの整数 m と p が与えられたとき、#dyncode("MOD0(m,p)") はなんらかの自然数 q について、m が p と q の積に等しいことを意味するとします。この意味は次の2つの証明関数にエンコードできます:

#sats2xhtml("\
//
prfun
lemma_MOD0_intr{m,p,q:nat | m==p*q}(): MOD0(m, p)
//
prfun
lemma_MOD0_elim{m,p:int}(MOD0(m, p)): [q:nat] EQINT(m, p*q)
//
")

このとき #dyncode("EQINT") は次のようなデータ命題です:

#sats2xhtml('\
dataprop EQINT(int, int) = {x:int} EQINT(x, x)
')

2つの整数 x と y が与えられたとき、#dyncode("EQINT(x, y)") は x と y が等しいことを意味するとします。また、関数 #dyncode("eqint_make") には以下のインターフェイスが割り当てられます:

#sats2xhtml('\
prfun eqint_make{x,y:int | x == y}((*void*)): EQINT (x, y)
')

整数 p が与えられたとき、#dyncode("PRIME(p)") は p が素数であることを意味するとします。次の2つの証明関数が、上記 #dyncode("mylemma_main") の実装では使われています:

#sats2xhtml('\
//
prfun lemma_PRIME_param{p:int}(PRIME(p)): [p >= 2] void
//
prfun mylemma1{n,p:int}(MOD0(n*n, p), PRIME(p)): MOD0(n, p)
//
')

証明関数 #dyncode("mylemma1") は、もし p が n の二乗で割り切れるなら p は n で割り切れ、かつ p は素数である、という命題をエンコードしています。エンコードされた命題は明らかに真であると見做したので、私は #dyncode("mylemma1") に実装を与えませんでした。これがプログラマ中心の判断です。\

")
")

#langeng("
#para("\

One may find that
the following declaration in the implementation of #dyncode("mylemma_main")
looks mysterious:

#atscode("\
  prval EQINT() = pfeq_mm_pnn
")

Note that #dyncode("pfeq_mm_pnn")
is of the prop #dyncode('EQINT(m*m, p*(n*n))').
Also, m equaling p*m#sub("2") for some natural number m#sub("2") is
available when the above declaration is typechecked.
This means that the equality between
(p*m#sub("2"))#sup("2") and p*(n)#sup("2") is added into the current store
of (static) assumptions after the above declaration is typechecked.

")
")
#langja("
#para("\

#dyncode("mylemma_main") の実装において次の宣言が不可解だ、という人がいるかもしれません:

#atscode("\
  prval EQINT() = pfeq_mm_pnn
")

#dyncode("pfeq_mm_pnn") は命題 #dyncode('EQINT(m*m, p*(n*n))') であることに注意してください。また、上記の宣言が型検査された時点で、なんらかの自然数 m#sub("2") について m が p*m#sub("2") に等しいことになります。これは、上記の宣言が型検査された後で、(p*m#sub("2"))#sup("2") と p*(n)#sup("2") が等しいことを静的な仮定に追加することを意味しています。

")
")

#langeng("
#para("\

Please find #mycodelink("CHAP_THMPRVING/sqrt2_irrat.dats", "on-line") the
entirety of an encoded proof showing that there exists no rational number whose
square equals 2.\

")
")
#langja("
#para("\

二乗が2に等しくなる有理数が存在しないことをエンコードした証明全体は #mycodelink("CHAP_THMPRVING/sqrt2_irrat.dats", "オンライン") から入手できます。\

")
")

</sect1><!--id="programmer_centric_theorem_proving"-->

<!-- ****** ****** -->

</chapter><!--id="theorem-proving_in_ats_lf"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
