%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="from-genericity-to-late-binding">
#langeng("
#title("From Genericity to Late-Binding")
")
#langja("
#title("ジェネリックスから遅延束縛へ")
")

<!-- ****** ****** -->

#langeng("
#para('\

The support for function templates in ATS is deeply ingrained in the design
and implementation of ATS. Primarily, function templates are meant to
provide a general approach to code reuse in ATS that is highly flexible (in
terms of applicability) while incurring minimal run-time overhead if
any. Both ATSPRE (that is, ATSLIB/prelude) and ATSLIB/libats are nearly
entirely template-based, and the templates in these libraries are for use
by #command("atsopt") to generate C code that implements template
instances in the ATS source being compiled. The library files of ATS for
linking (#filename("libatslib.a") and #filename("libatslib.so")) are minimal, and
they are not even necessary for compiling ATS source into executable binaries.

')#comment("para")
")
#langja("
#para('\

ATS における関数テンプレートのサポートは ATS のデザインと実装に深く根差しています。
第一に、関数テンプレートは ATS におけるコード再利用の一般的なアプローチを提供しています。
それは (妥当性の面で) とても柔軟で、必要になる実行時オーバーヘッドは最小のものです。
ATSPRE (つまり ATSLIB/prelude) と ATSLIB/libats の両方はテンプレートに基いていて、#command("atsopt")
によって吐き出されるC言語コードが ATS ソースコード中のテンプレート実体を実装するためにそれらのライブラリにおけるテンプレートは使われます。
リンクする ATS のライブラリファイル (#filename("libatslib.a") と #filename("libatslib.so")) は最小のものです。
それらは ATS ソースコードを実行バイナリにコンパイルするのに不要なことさえあります。

')#comment("para")
")

#langeng("
#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_FNTMPINT/", "on-line").\

")
")
#langja("
#para("\

この章で紹介するコードとテストコードは #mycodelink("CHAP_FNTMPINT/", "オンライン") から入手できます。\

")
")

<!-- ****** ****** -->

<sect1
 id="genericity-of-template-implementations">
#langeng("
#title("Genericity of Template Implementations")
")
#langja("
#title("テンプレート実装のジェネリックス")
")

#langeng("
#para('\

As is briefly explained in Part I of the book, function templates can be
seen as a natural solution to the problem of supporting parametric
polymorphism in the presence of native unboxed data. However, function
templates can do much more than just supporting parametric polymorphism.
Let #dyncode("myprint") be a function template of the following interface:

#sats2xhtml('\
fun{a:t@ype} myprint (x: a): void
')

Given a value, #dyncode("myprint") is supposed to print out some kind of
representation for this value. For example, we can implement
#dyncode("myprint") as follows:

#dats2xhtml('\
implement{a} myprint (x) = print_string "?"
')

This implementation of #dyncode("myprint") is often referred to as a
(fully) generic template implementation due to no restriction being imposed
on the template parameter. Following is another way to code the same
implementation:

#dats2xhtml('\
implement(a) myprint<a> (x) = print_string "?"
')

Clearly, the above generic implementation of #dyncode("myprint") is
unsatisfactory as it outputs no specific information on a given value.  We
may want to implement #dyncode("myprint") as follows for only values of the
type #stacode("int"):

#dats2xhtml('\
implement myprint<int> (x) = print_int (x)
')

where #dyncode("print_int") is called to print out a given integer. This
implementation of #dyncode("myprint") is often referred to as a specific
template implementation due to the template parameter being bound to a
specific type (that is, #stacode("int") in this case). The following code
implements #dyncode("myprint") for list-values (that is, values of type
#stacode("List(T)") for some type T):

#dats2xhtml('\
implement(a)
myprint<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) =>
    (myprint<a> (x); myprint<List(a)> (xs))
')

This implementation of #dyncode("myprint") is often referred to as a
partially generic template implementation. In order for an instance of
#dyncode("myprint") to use this implementation, the template parameter for
the instance must be of the form #stacode("List(T)") for some type T.
As an example, the following code calls an instance of #dyncode("myprint")
to print out a list of two integer lists:

#dats2xhtml('\
(*
** The output is "0123401234"
*)
val ys = $list{int}(0,1,2,3,4)
val yss = $list{List(int)}(ys, ys)
val ((*void*)) = myprint<List(List(int))> (yss)
val ((*void*)) = print_newline((*void*))
')

')#comment("para")
")
#langja("
#para('\

この本の I 章で概説した通り、ネイティブのアンボックス化されたデータの存在下におけるパラメータ多相に関する問題に対して、関数テンプレートは自然な解決策です。
けれども、関数テンプレートはパラメータ多相の単なるサポートより多くのことが可能です。
#dyncode("myprint") が次のインターフェイスの関数テンプレートだとしましょう:

#sats2xhtml('\
fun{a:t@ype} myprint (x: a): void
')

値が与えられたとき、#dyncode("myprint") はこの値に対するなんらかの表現を印字するものとしましょう。
例えば、#dyncode("myprint") を次のように実装できます:

#dats2xhtml('\
implement{a} myprint (x) = print_string "?"
')

#dyncode("myprint") のこの実装はしばしば (完全な) 総称テンプレート実装と呼ばれます。
そのテンプレートパラメータに何の制限も課されていないからです。
次のように同じ実装を書く別の方法もあります:

#dats2xhtml('\
implement(a) myprint<a> (x) = print_string "?"
')

明らかに、上記 #dyncode("myprint") のジェネリックス実装は、与えられた値について特別な情報を何も印字できないという点において十分ではありません。
型 #stacode("int") の値のみをサポートする #dyncode("myprint") を実装したくなるかもしれません:

#dats2xhtml('\
implement myprint<int> (x) = print_int (x)
')

このとき #dyncode("print_int") は与えられた整数を印字します。
#dyncode("myprint") のこの実装は特殊テンプレート実装としばしば呼ばれます。
テンプレートパラメータに特別な型 (つまりこの例では #stacode("int")) を割り当てているからです。
次のコードは、リスト値 (つまりなんらかの型 T に対する型 #stacode("List(T)") の値) のための #dyncode("myprint") を実装しています:

#dats2xhtml('\
implement(a)
myprint<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) =>
    (myprint<a> (x); myprint<List(a)> (xs))
')

#dyncode("myprint") のこの実装は、しばしば部分的な総称テンプレート実装を呼ばれます。
この実装を使う #dyncode("myprint") のインスタンスのために、そのインスタンスに対するテンプレートパラメータはなんらかの型
T において #stacode("List(T)") でなければなりません。
例えば、次のコードは2つの整数のリストのリストを印字するのに #dyncode("myprint") のインスタンスを呼び出しています:

#dats2xhtml('\
(*
** The output is "0123401234"
*)
val ys = $list{int}(0,1,2,3,4)
val yss = $list{List(int)}(ys, ys)
val ((*void*)) = myprint<List(List(int))> (yss)
val ((*void*)) = print_newline((*void*))
')

')#comment("para")
")

#langeng("
#para('\

Implementations of a function template can be ordered according to an
obvious partial ordering referred to as genericity ordering: The genericity
of one implementation is less than or equal to that of another one if the
former implementation is an instance of the latter one. Please note that
the first-fit (instead of best-fit) strategy is employed to locate the
template implementation needed for compiling a given template instance.
More specifically, locating the template implementation for a particular
template instance follows the standard principle of lexical scoping to
search for the first one that is available for use.

')#comment("para")
")
#langja("
#para('\

関数テンプレートの実装はある特定の順序に従って順序付けられます。
これはジェネリックス順序 (genericity ordering) と呼ばれます:
もし、ある実装が別の実装のインスタンスであるなら、前者のジェネリックスは後者のジェネリックス以下になります。
与えられたテンプレートインスタンスをコンパイルするのに必要なテンプレート実装の配置には
(best-fit ではなく) first-fit 戦略が取られることに注意してください。
より具体的には、特殊テンレプートインスタンスに対するテンプレート実装の配置では、使用可能な最初の1つを探すのにレキシカルスコープの原理に従っています。

')#comment("para")
")

#langeng("
#para('\

In practice, there is quite a bit of subtlety in locating a template
implementation for a template instance. Let #dyncode("myprint2") be a
function template of the following interface:

#sats2xhtml('\
fun{a:t@ype} myprint2 (x: a): int
')

Following is a partially generic implementation of #dyncode("myprint2"):

#dats2xhtml('\
//
implement(a)
myprint2<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) =>
    (myprint<a> (x); 1 + myprint2 (xs))
//
')

This template implementation actually behaves very differently from what
one might have expected. Note that the template parameter of the called
instance of #dyncode("myprint2") in the body of the implementation is
synthesized to be a type of the form #stacode("list(a, N)") for some static
term N (of the sort #stacode("int")). As this form can never match
#stacode("List(T)") for any type T, the called instance of the template
#dyncode("myprint2") cannot be compiled according to the given template
implementation of #dyncode("myprint2"). This issue can be readily fixed by
passing explicity the type #stacode("List(a)") (as a template parameter) to
the called instance of #dyncode("myprint2"):

#dats2xhtml('\
//
implement(a)
myprint2<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) =>
    (myprint<a> (x); 1 + myprint2<List(a)> (xs))
//
')

The instance #dyncode("myprint2&lt;List(a)&gt;") in this example is often
referred to as a recursive instance. In general, it is a good programming
practice to #emphasis("avoid") using recursive instances. For example, the
following equivalent implementation of #dyncode("myprint2") makes no use of
recursive instances:

#dats2xhtml('\
//
implement(a)
myprint2<List(a)>
  (xs) = let
//
fun
aux
(xs: List(a)): int =
//
case+ xs of
| list_nil () => 0
| list_cons (x, xs) => (myprint<a>(x); 1 + aux(xs))
//
in
  aux (xs)
end // end of [myprint2<List(a)>]
//
')

')#comment("para")
")
#langja("
#para('\

実際には、テンプレートインスタンスに対するテンプレート実装の配置にはほんの少し巧妙な点があります。
#dyncode("myprint2") を次のようなインターフェイスを持つ関数テンプレートとしましょう:

#sats2xhtml('\
fun{a:t@ype} myprint2 (x: a): int
')

次のコードは #dyncode("myprint2") の部分的な総称テンプレート実装です:

#dats2xhtml('\
//
implement(a)
myprint2<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) =>
    (myprint<a> (x); 1 + myprint2 (xs))
//
')

このテンプレート実装は、実際には予想される共同と違った振舞いをします。
実装本体で呼び出された #dyncode("myprint2") のインスタンスのテンプレートパラメータは、なんらかの
(種 #stacode("int") の) 静的な項 N に対する #stacode("list(a, N)") 型になることに注意してください。
これはどのような型 T に対する #stacode("List(T)") にもマッチしないので、テンプレート #dyncode("myprint2")
の呼び出されたインスタンスは与えられた #dyncode("myprint2") のテンプレート実装に従ってコンパイルできません。
この問題は、呼び出される #dyncode("myprint2") のインスタンスに、明示的に型 #stacode("List(a)") をテンプレートパラメータとして渡せば簡単に修正できます:

#dats2xhtml('\
//
implement(a)
myprint2<List(a)> (xs) =
case+ xs of
| list_nil () => ()
| list_cons (x, xs) =>
    (myprint<a> (x); 1 + myprint2<List(a)> (xs))
//
')

この例におけるインスタンス #dyncode("myprint2&lt;List(a)&gt;") はしばしば再帰的なインスタンスと呼ばれます。
一般に、再帰的なインスタンスの使用を #emphasis("避ける") ことは良いプログラミング習慣です。
例えば、次のような #dyncode("myprint2") に相当する実装は再帰的なインスタンスを使っていません:

#dats2xhtml('\
//
implement(a)
myprint2<List(a)>
  (xs) = let
//
fun
aux
(xs: List(a)): int =
//
case+ xs of
| list_nil () => 0
| list_cons (x, xs) => (myprint<a>(x); 1 + aux(xs))
//
in
  aux (xs)
end // end of [myprint2<List(a)>]
//
')

')#comment("para")
")


#langeng("
#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/myprint.dats", "myprint.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")
")
#langja("
#para('\

この章で紹介したコード全体とテストコードを含む
#mycodelink("CHAP_FNTMPINT/myprint.dats", "myprint.dats")
はオンラインから入手できます。\

')#comment("para")
")

</sect1><!--id="genericity-of-template-implementations"-->

<!-- ****** ****** -->

<sect1
 id="generic-operations-on-numbers">
#langeng("
#title("Example: Generic Operations on Numbers")
")
#langja("
#title("例: 数に対するジェネリックス演算")
")

#langeng("
#para("\

There are many types of numbers in ATS. With function templates, we can
greatly enhance code sharing in numerical computation. For example, we can
give a generic implementation of matrix multiplication of the following
interface:

#sats2xhtml("\
fun
{a:t@ype}
matrix_mul
  {p,q,r:int}
(
  p: int(p)
, q: int(q)
, r: int(r)
, A: &matrix(a, p, q)
, B: &matrix(a, q, r)
, C: &matrix(a?, p, r) >> matrix(a, p, r)
) : void // end of [matrix_mul]
")

and then use it to immediately obtain implementations of matrix
multiplication for matrices of integers, matrices of floating point
numbers, matrices of floating point complex numbers, etc. This approach is
clearly far superior to relying on error-prone macros in C.

")#comment("para")
")
#langja("
#para("\

ATS には数多くの数値型があります。
関数テンプレートを用いると、数値演算においてコードの共有を向上させることができます。
例えば、持つ行列の乗法のジェネリックス実装に次のインターフェイスを与えることができます:

#sats2xhtml("\
fun
{a:t@ype}
matrix_mul
  {p,q,r:int}
(
  p: int(p)
, q: int(q)
, r: int(r)
, A: &matrix(a, p, q)
, B: &matrix(a, q, r)
, C: &matrix(a?, p, r) >> matrix(a, p, r)
) : void // end of [matrix_mul]
")

それからこれを使って、整数の行列, 浮動小数点数の行列, 浮動小数点複素数の行列などの行列乗法の実装をすぐに得られます。
このアプローチは、エラーを招きやすいC言語マクロの使用よりも明確に優れています。

")#comment("para")
")

#langeng("
#para("\

Let us take a look at a concrete example involving generic operations on
numbers. The following code gives a standard implementation of the
factorial function:

#dats2xhtml('\
//
extern
fun fact(n: int): int
//
implement
fact(n) =
  if n > 0 then n * fact(n-1) else 1
// end of [fact]
//
')

When applied to 100, #dyncode("fact") is likely to return 0. This can be
easily understood as the true value of the factorial of 100 is a multiple
of 2#sup("32") and the multiplication operation on integers of the type
#stacode("int") is probably modulo 2#sup("32"). Suppose that we want to
replace this multiplication operation with the one on floating point
numbers of double precision. This can be done by implementing a slight variant
of #dyncode("fact") as follows

#dats2xhtml('\
//
extern
fun factd(n: int): double
//
implement
factd(n) =
  if n > 0 then n * factd(n-1) else 1.0
// end of [factd]
//
')

When applied to 100, #dyncode("factd") should return a large floating point
number. Obviously, there is a great deal of code duplication between the
implementations of #dyncode("fact") and #dyncode("factd"). We can readily
eliminate this duplication by introducing a generic implementation of the
factorial function as follows:

#dats2xhtml('\
//
extern
fun{a:t@ype} gfact(n: int): a
//
implement
{a}(*tmp*)
gfact(n) = (
//
if n > 0
then gmul_int_val<a>(n, gfact<a>(n-1))
else gnumber_int<a>(1)
//
) (* end of [gfact] *)
//
')

With a bit of help from the support for
overloading in ATS, we can rewrite #dyncode("gfact") as follows:

#dats2xhtml('\
implement
{a}(*tmp*)
gfact(n) = let
//
overload * with gmul_int_val
//
in
//
if n > 0
then n * gfact<a>(n-1) else gnumber_int<a>(1)
//
end (* end of [gfact] *)
')

We can now implement #dyncode("fact") and #dyncode("factd")
as follows:

#dats2xhtml('\
//
implement fact(n) = gfact<int>(n)
implement factd(n) = gfact<double>(n)
//
')

There is support in ATS based on the GNU multiple precision arithmetic
library (GMPLIB) for integers of unlimited precision. The following code
presents a way to compute the true value of the factorial of 100:

#dats2xhtml('\
//
staload _(*T*) =
"{$LIBATSHWXI}/intinf/DATS/intinf_t.dats"
staload _(*VT*) =
"{$LIBATSHWXI}/intinf/DATS/intinf_vt.dats"
//
staload GINTINF =
"{$LIBATSHWXI}/intinf/DATS/gintinf_t.dats"
//
typedef intinf = $GINTINF.intinf
overload print with $GINTINF.print_intinf
//
val () =
println! ("gfact<intinf>(100) = ", gfact<intinf>(100))
//
')

I only list some leading digits of the result:

#atscode('\
gfact<intinf>(100) = 933262154439441526816992388562667[...omitted...]
')
")
")
#langja("
#para("\

数に対するジェネリックス演算の具体的な例を見てみましょう。
次のコードは階乗関数の一般的な実装です:

#dats2xhtml('\
//
extern
fun fact(n: int): int
//
implement
fact(n) =
  if n > 0 then n * fact(n-1) else 1
// end of [fact]
//
')

100 に適用されると、#dyncode("fact") は 0 を返すでしょう。
これは 100 の階乗が 2#sup("32") の倍数になり、型 #stacode("int")
の整数に対する乗算が 2#sup("32") を法とすることから容易に理解できます。
この乗法を倍精度の浮動小数点数における乗法に置き換えたいとします。
これは次のように #dyncode("fact") のわずかな偏見を実装するだけで済みます:

#dats2xhtml('\
//
extern
fun factd(n: int): double

implement
factd(n) =
  if n > 0 then n * factd(n-1) else 1.0
// end of [factd]
//
')

100 に適用されると、#dyncode("factd") は大きな浮動小数点数を返します。
明らかに #dyncode("fact") と #dyncode("factd") の実装の間にはコードの重複があります。
次のような階乗関数のジェネリックス実装を導入することで、この重複をたやすく取り除くことができます。

#dats2xhtml('\
//
extern
fun{a:t@ype} gfact(n: int): a
//
implement
{a}(*tmp*)
gfact(n) = (
//
if n > 0
then gmul_int_val<a>(n, gfact<a>(n-1))
else gnumber_int<a>(1)
//
) (* end of [gfact] *)
//
')

ATS でオーバーロードをサポートによって少しきれいにできます。
#dyncode("gfact") を次のように書き直せます:

#dats2xhtml('\
implement
{a}(*tmp*)
gfact(n) = let
//
overload * with gmul_int_val
//
in
//
if n > 0
then n * gfact<a>(n-1) else gnumber_int<a>(1)
//
end (* end of [gfact] *)
')

これで #dyncode("fact") と #dyncode("factd") は次のように実装できます:

#dats2xhtml('\
//
implement fact(n) = gfact<int>(n)
implement factd(n) = gfact<double>(n)
//
')

GNU multiple precision arithmetic library (GMPLIB) に基づいて多倍長整数を ATS はサポートしています。
次のコードは 100 の階乗の正しい値を算出する方法を示しています:

#dats2xhtml('\
//
staload _(*T*) =
"{$LIBATSHWXI}/intinf/DATS/intinf_t.dats"
staload _(*VT*) =
"{$LIBATSHWXI}/intinf/DATS/intinf_vt.dats"
//
staload GINTINF =
"{$LIBATSHWXI}/intinf/DATS/gintinf_t.dats"
//
typedef intinf = $GINTINF.intinf
overload print with $GINTINF.print_intinf
//
val () =
println! ("gfact<intinf>(100) = ", gfact<intinf>(100))
//
')

次のような数値が得られました:

#atscode('\
gfact<intinf>(100) = 933262154439441526816992388562667[...omitted...]
')
")
")

#langeng("
#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/gnumber.dats", "gnumber.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")
")
#langja("
#para('\

この章で紹介したコード全体とテストコードを含む
#mycodelink("CHAP_FNTMPINT/gnumber.dats", "gnumber.dats")
はオンラインから入手できます。\

')#comment("para")
")

</sect1><!--id="generic-operations-on-numbers"-->

<!-- ****** ****** -->

<sect1
 id="templates-as-a-special-form-of-functors">
#langeng("
#title("Templates as a Special Form of Functors")
")
#langja("
#title("ファンクタの特殊形としてのテンプレート")
")

#langeng("
#para("\

Many uses of higher-order functions can be readily replaced with function
templates in ATS.  In particular, higher-order functions are often
implemented in ATS based on the corresponding function templates.
Let us start with a concrete example. Following is a standard
implementation of list mapping as a higher-order function (template):

#atscode('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map_fun{n:nat}
  (xs: list(a, n), f: a -> b): list_vt(b, n)
//
implement
{a}{b}
list_map_fun (xs, f) = let
//
fun
aux{n:nat}
  (xs: list(a, n)): list_vt(b, n) =
(
case+ xs of
| list_nil () => list_vt_nil ()
| list_cons (x, xs) => list_vt_cons (f(x), aux(xs))
)
//
in
  aux(xs)
end // end of [list_map_fun]
//
')

Given a list of cerntain length and a function (which is envless),
#dyncode("list_map_fun") returns a linear list of the same
length. Unfortunately, #dyncode("list_map_fun") cannot be called on a list and
a closure-function. We certainly can implement a variant of
#dyncode("list_map_fun") of the following interface by essentially duplicating
the implementation of #dyncode("list_map_fun"):

#atscode('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map_cloref{n:nat}
  (xs: list(a, n), f: a -<cloref1> b): list_vt(b, n)
//
')

While #dyncode("list_map_cloref") can be called on a list and a
closure-function, the closure-function that is formed at run-time to be
passed to a call to #dyncode("list_map_cloref") most likely becomes garbage
immediately after the call returns. Without garbage collection (GC), the
memory for storing the closure is leaked. We surely have many good reasons
for avoiding using a higher-order function like #dyncode("list_map_cloref")
when doing embedded programming in ATS.

")
")
#langja("
#para("\

ATS では、高階関数の使用の多くは関数テンプレートによって容易に置き換えできます。
特に、高階関数は対応する関数テンプレートを元に実装されることもしばしばです。
実際の例を最初に見てみましょう。
次のコードは、高階関数テンプレートとしてのリストのマップの一般的な実装です:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map_fun{n:nat}
  (xs: list(a, n), f: a -> b): list_vt(b, n)
//
implement
{a}{b}
list_map_fun (xs, f) = let
//
fun
aux{n:nat}
  (xs: list(a, n)): list_vt(b, n) =
(
case+ xs of
| list_nil () => list_vt_nil ()
| list_cons (x, xs) => list_vt_cons (f(x), aux(xs))
)
//
in
  aux(xs)
end // end of [list_map_fun]
//
')

ある長さのリストと (無環境の) 関数が与えられたとき、#dyncode("list_map_fun")
は同じ長さの線形リストを返します。
不幸にも、リストとクロージャ関数に対して #dyncode("list_map_fun") を呼び出すことはできません。
もちろん、#dyncode("list_map_fun") の実装を複製することで、次のインターフェイスを持つ
#dyncode("list_map_fun") の変種を実装することはできます:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map_cloref{n:nat}
  (xs: list(a, n), f: a -<cloref1> b): list_vt(b, n)
//
')

#dyncode("list_map_cloref") はリストとクロージャ関数に対して呼び出せますが、#dyncode("list_map_cloref")
呼び出しに渡されるために実行時に生成されるクロージャ関数は、関数呼び出しが返ると即座にゴミになってしまうでしょう。
ガベージコレクション (GC) がない場合、そのクロージャを保管していたメモリはリークしてしまいます。
ATS を使って組み込みプログラミングを行なう際は、#dyncode("list_map_cloref") のような高階関数の使用を避けた方が良いでしょう。

")
")

#langeng("
#para('\

A proper way to implement list mapping (as I see it) is given as follows:

#atscode('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map{n:nat}
  (xs: list(a, n)): list_vt(b, n)
//
extern
fun
{a:t@ype}{b:t@ype} list_map$fopr(x: a): b
//
implement
{a}{b}
list_map (xs) = let
//
fun
aux{n:nat}
  (xs: list(a, n)): list_vt(b, n) =
(
case+ xs of
| list_nil () => list_vt_nil ()
| list_cons (x, xs) => list_vt_cons (list_map$fopr<a><b>(x), aux(xs))
) (* end of [aux] *)
//
in
  aux(xs)
end // end of [list_map]
//
')

The function template #dyncode("list_map") is given in a style that is
often referred to as being functorial: #dyncode("list_map") can be thought
of as a functor in Standard ML that applies to a module consisting of a
single function #dyncode("list_map$fopr"). In SML, each argument of a
functor, which itself is a module, needs to be constructed and then passed
to the functor explcitly. In ATS, the template implementation needed for
compiling a particular template instance is located through a search
procedure (that follows the standard principle of lexical scoping).

')#comment("para")
")
#langja("
#para('\

リストのマップを実装する正当な方法は (私の知るかぎり) 次のようなものです:

#dats2xhtml('\
//
extern
fun
{a:t@ype}
{b:t@ype}
list_map{n:nat}
  (xs: list(a, n)): list_vt(b, n)
//
extern
fun
{a:t@ype}{b:t@ype} list_map$fopr(x: a): b
//
implement
{a}{b}
list_map (xs) = let
//
fun
aux{n:nat}
  (xs: list(a, n)): list_vt(b, n) =
(
case+ xs of
| list_nil () => list_vt_nil ()
| list_cons (x, xs) => list_vt_cons (list_map$fopr<a><b>(x), aux(xs))
) (* end of [aux] *)
//
in
  aux(xs)
end // end of [list_map]
//
')

関数テンプレート #dyncode("list_map") はファンクタ的 (functorial) と呼ばれるスタイルです:
#dyncode("list_map") は、1つの関数 #dyncode("list_map$fopr") から成るモジュールに適用する Standard ML のファンクタと考えることができます。
SML では、それ自身がモジュールであるファンクタのそれぞれの引数はコンストラクトされる必要があり、それから明示的にファンクタに渡されます。
ATS では、特殊テンプレートインスタンスをコンパイルするために必要なテンプレート実装は検索して配置されます。
(これはレキシカルスコープの原理に従います。)

')#comment("para")
")

#langeng("
#para('\

With #dyncode("list_map"), we can implement both #dyncode("list_map_fun")
and #dyncode("list_map_cloref") as follows in a straightforward manner:

#dats2xhtml('\
implement
{a}{b}
list_map_fun(xs, f) = let
//
implement list_map$fopr<a><b> (x) = f(x)
//
in
  list_map<a><b> (xs)
end // end of [list_map_fun]

(* ****** ****** *)

implement
{a}{b}
list_map_cloref(xs, f) = let
//
implement list_map$fopr<a><b> (x) = f(x)
//
in
  list_map<a><b> (xs)
end // end of [list_map_cloref]
')

For those who are familiar with functors in SML, the implementation of
#dyncode("list_map_fun") and #dyncode("list_map_cloref") should clearly
remind them of functor application.

')#comment("para")
")
#langja("
#para('\

#dyncode("list_map") を用いて、#dyncode("list_map_fun") と #dyncode("list_map_cloref")
の両方を次のようにそのまま実装できます:

#dats2xhtml('\
implement
{a}{b}
list_map_fun(xs, f) = let
//
implement list_map$fopr<a><b> (x) = f(x)
//
in
  list_map<a><b> (xs)
end // end of [list_map_fun]

(* ****** ****** *)

implement
{a}{b}
list_map_cloref(xs, f) = let
//
implement list_map$fopr<a><b> (x) = f(x)
//
in
  list_map<a><b> (xs)
end // end of [list_map_cloref]
')

SML におけるファンクタとして馴染みのあるように、#dyncode("list_map_fun") と #dyncode("list_map_cloref")
の実装は明らかにファンクタの適用のそれに似ています。

')#comment("para")
")

#langeng("
#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/list_map.dats", "list_map.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")
")
#langja("
#para('\

この章で紹介したコード全体とテストコードを含む
#mycodelink("CHAP_FNTMPINT/list_map.dats", "list_map.dats")
ファイルはオンラインから入手できます。\

')#comment("para")
")

</sect1><!--id="templates-as-a-special-form-of-functors"-->

<!-- ****** ****** -->

<sect1
 id="template-for-loop-construction">
#langeng("
#title("Example: Templates for Loop Construction")
")
#langja("
#title("例: ループ生成のためのテンプレート")
")

#langeng("
#para('\

Beginners in functional programming (FP) who have already acquired some
knowledge of imperative programming often ask about ways to construct
for-loops and while-loops in FP. A commonly given answer is that loop
constructs are unnecessary in FP as they can be readily replaced with
higher-order functions. Let us first see some thorny issues with this
answer.\

')#comment("para")
")
#langja("
#para('\

命令型プログラミングに経験がある関数型プログラミング (FP) の初心者は、FP において for ループや while ループを作る方法にしばしば疑問を持ちます。
一般的な答は、それらは高階関数で置き換えられるので FP ではループを生成する必要はない、というものです。
はじめに、この答においていくつか困難な問題があることを見てみましょう。\

')#comment("para")
")

#langeng("
#para('\

The following code in C implements a function that returns the sum
of the first n natural numbers when applied to a natural number n:

#atscode('\
int
tally (int n) {
  int i, res;
  for (i = 0, res = 0; i < n; i += 1) res += i;
  return res;
}
')

This function #dyncode("tally") can be given the following
equivalent implementation in ATS:

#dats2xhtml('\
fun
tally
(
  n: int
) : int = loop (0, 0) where
{
  fun loop (i: int, res: int): int =
    if i < n then loop (i + 1, res + i) else res
}
')

where the tail-recursive function #dyncode("loop") is just a translation
of the for-loop in C.

')#comment("para")
")
#langja("
#para('\

次のC言語コードは、自然数 n に適用されると最初の n 個の自然数の合計を返す関数を実装しています:

#atscode('\
int
tally (int n) {
  int i, res;
  for (i = 0, res = 0; i < n; i += 1) res += i;
  return res;
}
')

この関数 #dyncode("tally") と等価な ATS の関数は次のように与えられます:

#dats2xhtml('\
fun
tally
(
  n: int
) : int = loop (0, 0) where
{
  fun loop (i: int, res: int): int =
    if i < n then loop (i + 1, res + i) else res
}
')

このとき、末尾再帰関数 #dyncode("loop") はC言語の for ループを単純に変換したものです。

')#comment("para")
")

#langeng("
#para('\

When someone claims that loop constructs can be replaced with higher-order
functions, he or she probably means to construct loops with a function like
the following one:

#dats2xhtml('\
fun
for_loop
(
  count: int, limit: int, fwork: (int) -<cloref1> void
) : void = (
//
if count < limit
  then (fwork(count); for_loop(count+1, limit, fwork)) else ()
// end of [if]
) (* end of [for_loop] *)
')

For example, the following function #dyncode("tally2") is directly based
on #dyncode("for_loop"):

#dats2xhtml('\
fun
tally2
(
  n: int
) : int = let
  val res = ref<int> (0)
in
  for_loop (0, n, lam (i) => !res := !res + i); !res
end // end of [tally2]
')

While both #dyncode("tally") and #dyncode("tally2") return the same result
when applied to a given natural number, they behave very differently at
run-time. In particular, each call to #dyncode("tally2") creates a
(persistent) reference on heap for temporary use; the reference becomes
garbage immediately after the call returns. Compared to #dyncode("tally"),
#dyncode("tally2") is inefficient both time-wise and memory-wise.\

')#comment("para")
")
#langja("
#para('\

ループ生成を高階関数で置換できると誰かが指摘するとき、彼等はおそらく次のような関数でループを生成しようとするでしょう:

#dats2xhtml('\
fun
for_loop
(
  count: int, limit: int, fwork: (int) -<cloref1> void
) : void = (
if count < limit
  then (fwork(count); for_loop(count+1, limit, fwork)) else ()
// end of [if]
) (* end of [for_loop] *)
')

例えば、次の関数 #dyncode("tally2") は #dyncode("for_loop") を直接使っています:

#dats2xhtml('\
fun
tally2
(
  n: int
) : int = let
  val res = ref<int> (0)
in
  for_loop (0, n, lam (i) => !res := !res + i); !res
end // end of [tally2]
')

自然数に適用すると #dyncode("tally") と #dyncode("tally2") は同じ結果を返しますが、実行時には異なる挙動をします。
特に、#dyncode("tally2") 呼び出しは一時的な用途に (永続的な) 参照をヒープに作ります;
呼び出しが返るとこの参照はすぐにゴミになります。

#dyncode("tally") と比較すると #dyncode("tally2") は時間効率と空間効率の両面で非効率です。\

')#comment("para")
")

#langeng("
#para('\

To eliminate the need for reference creation in #dyncode("tally2"), we
turn #dyncode("for_loop") into the following function template
#dyncode("for_loop2"):

#dats2xhtml('\
//
fun{
env:t@ype
} for_loop2
(
  count: int, limit: int
, env: &env >> _, fwork: (int, &env >> _) -<cloref1> void
) : void = (
//
if
count < limit
then (
  fwork(count, env); for_loop2<env> (count+1, limit, env, fwork)
) else ()
// end of [if]
//
) (* end of [for_loop2] *)
')

We can further turn #dyncode("tally2") into the following #dyncode("tally3")
based on #dyncode("for_loop2"):

#dats2xhtml('\
fun
tally3
(
  n: int
) : int = let
  var res: int = 0
in
  for_loop2<int> (0, n, res, lam (i, res) => res := res + i); res
end // end of [tally3]
')

While #dyncode("tally3") improves upon #dyncode("tally2"), it is still a
bit unsatisfactory. Clearly, the closure function formed before
#dyncode("tally3") calls #dyncode("for_loop2") becomes garbage immediately
after the call returns. It is plausible to expect that an optimizing C
compiler (e.g., gcc and clang) can eliminate the need for actual closure
formation when it compiles on the C code generated from ATS source, but
there is no guarantee. In order to have such a guarantee, we can evolve
#dyncode("for_loop2") into the following function template
#dyncode("for_loop3:")

#dats2xhtml('\
fun{
env:t@ype
} for_loop3
(
  count: int, limit: int, env: &env >> _
) : void = (
//
if
count < limit
then (
  for_loop3$fwork<env>(count, env); for_loop3<env>(count+1, limit, env)
) else ()
// end of [if]
//
) (* end of [for_loop3] *)
')

where #dyncode("for_loop3$fwork") is given the interface below:

#sats2xhtml('\
fun{
env:t@ype
} for_loop3$fwork(count: int, env: &env >> _): void
')

Finally, we can turn #dyncode("tally3") into #dyncode("tally4")
as follows:

#dats2xhtml('\
fun
tally4
(
  n: int
) : int = let
//
var res: int = 0
//
implement
for_loop3$fwork<int> (i, res) = res := res + i
//
in
  for_loop3<int> (0, n, res); res
end // end of [tally4]
')

By inspecting the C code generated by #command("atsopt") from compiling
#dyncode("tally4"), we can see that the C code is essentially equivalent to
the implementation of #dyncode("tally") in C (given at the beginning of
this section).

')#comment("para")
")
#langja("
#para('\

#dyncode("tally2") における参照の必要性を除去するために、#dyncode("for_loop")
を次のような関数テンレプレート #dyncode("for_loop2") に変換しましょう:

#dats2xhtml('\
//
fun{
env:t@ype
} for_loop2
(
  count: int, limit: int
, env: &env >> _, fwork: (int, &env >> _) -<cloref1> void
) : void = (
//
if
count < limit
then (
  fwork(count, env); for_loop2<env> (count+1, limit, env, fwork)
) else ()
// end of [if]
//
) (* end of [for_loop2] *)
')

さらに #dyncode("tally2") を、#dyncode("for_loop2") を用いて次の #dyncode("tally3") に変換できます:

#dats2xhtml('\
fun
tally3
(
  n: int
) : int = let
  var res: int = 0
in
  for_loop2<int> (0, n, res, lam (i, res) => res := res + i); res
end // end of [tally3]
')

#dyncode("tally3") は #dyncode("tally2") より良いものですが、まだ完全ではありせん。
#dyncode("tally3") が #dyncode("for_loop2") を呼び出す前に作ったクロージャ関数は、呼び出しが返ると即座にゴミになることは明確です。
ATS ソースコードから生成されたC言語コードで呼び出されるので、Cコンパイラ (例えば gcc や clang)
の最適化が実際のクロージャ関数を不要にしてくれることを期待することもできますが、その保証はありません。
そのような保証を得るために、#dyncode("for_loop2") を次のような関数テンプレート #dyncode("for_loop3") に発展させることができます:

#dats2xhtml('\
fun{
env:t@ype
} for_loop3
(
  count: int, limit: int, env: &env >> _
) : void = (
if
count < limit
then (
  for_loop3$fwork<env>(count, env); for_loop3<env>(count+1, limit, env)
) else ()
// end of [if]
) (* end of [for_loop3] *)
')

このとき #dyncode("for_loop3$fwork") には次のようなインターフェイスが割り当てられます:

#sats2xhtml('\
fun{
env:t@ype
} for_loop3$fwork(count: int, env: &env >> _): void
')

最終的に #dyncode("tally3") を次のような #dyncode("tally4") に変換できます:

#dats2xhtml('\
fun
tally4
(
  n: int
) : int = let
//
var res: int = 0
//
implement
for_loop3$fwork<int> (i, res) = res := res + i
//
in
  for_loop3<int> (0, n, res); res
end // end of [tally4]
')

#command("atsopt") が #dyncode("tally4") をコンパイルして生成したC言語コードを調べれば、そのC言語コードは
(この章の最初で登場した) C言語による #dyncode("tally") の実装と本質的に等価であることがわかるでしょう。

')#comment("para")
")

#langeng("
#para('\

By now, the reader probably agrees with me if I say the statement should at
least be considered grossly inaccurate that claims loop constructs in FP
can be readily replaced with higher-order functions.  Please find on-line
the file #mycodelink("CHAP_FNTMPINT/loopcons.dats", "loopcons.dats")
containing the entirety of the code presented in this section plus some
testing code.\

')#comment("para")
")
#langja("
#para('\

ここまで読んだ読者は、FP におけるループ生成は高階関数で容易に置き換えられるという主張が著しく不正確であることに同意できるでしょう。
この章で紹介したコード全体とテストコードを含む
#mycodelink("CHAP_FNTMPINT/loopcons.dats", "loopcons.dats")
ファイルはオンラインから入手できます。\

')#comment("para")
")

</sect1><!--id="template-for-loop-construction"-->

<!-- ****** ****** -->

<sect1
 id="template-based-support-for-late-binding">
#langeng("
#title("Template-Based Support for Late-Binding")
")
#langja("
#title("テンプレートを用いた遅延束縛のサポート")
")

#langeng("
#para('\

When asked about the meaning of object-oriented programming (OOP),
Alan Kay once said that OOP to him meant only messaging, local retention
and protection and hiding of state-process, and extreme late-binding of all
things.\

')#comment("para")
")
#langja("
#para('\

オブジェクト指向プログラミング (OOP) の意味について聞かれたとき、アラン・ケイは彼にとっての
OOP はメッセージ、状態プロセスの局所的な保持, 保護, 隠蔽と全てに対する極端な遅延束縛 (late-binding) であると答えました。\

')#comment("para")
")

#langeng("
#para('\

In ATS, function templates can provide a highly flexible approach to
supporting late-binding (of function calls). Let us first take a look at a
simple example to see why late-binding can be so desirable. The following
code declares a datatype #stacode("intfloat") such that each value of this
declared type represents either an integer or a floating point number (of
double precision):

#sats2xhtml('\
//
datatype
intfloat = INT of int | FLOAT of double
//
')

In order to print values of the type #stacode("intfloat"), we can implement
#dyncode("print_intfloat") as follows:

#dats2xhtml('\
//
fun
print_intfloat
  (x: intfloat): void =
(
case+ x of
| INT(int) => print_int(int)
| FLOAT(float) => print_double(float)
)
//
')

where #dyncode("print_int") and #dyncode("print_double") are monomorphic
functions for printing an integer and a floating point number (of double
precision), respectively. There are certainly many different ways to print
integers and floating point numbers, but #dyncode("print_intfloat") only
uses a particular one for integers (via #dyncode("print_int")) and a
particular one for floating point numbers (via #dyncode("print_double")).
One possibility of avoiding this form of extreme inflexibility is to define
a higher-order function #dyncode("fprint_intfloat") as follows:

#dats2xhtml('\
//
fun
fprint_intfloat
(
  x: intfloat
, print_int: int -> void
, print_double: double -> void
) : void =
(
case+ x of
| INT(int) => print_int(int)
| FLOAT(float) => print_double(float)
)
//
')

With #dyncode("fprint_intfloat"), one can decide to choose implementations
for #dyncode("print_int") and #dyncode("print_double") at a later stage. In
this regard, I say that higher-order functions can support a form of
late-binding. However, using higher-order functions in such a manner is not
without serious problems. Basically, any function that calls
#dyncode("print_int") either directly or indirectly needs to be turned into
a higher-order function, and the same applies to functions calling
#dyncode("print_double") as well. This style of programming with extensive
use of higher-order functions can soon become extremely unwieldy when the
number of functions grows large that need to be treated like
#dyncode("print_int") and #dyncode("print_double").

')#comment("para")
")
#langja("
#para('\

ATS では、関数テンプレートは (関数呼び出しの) 遅延束縛に高度に柔軟なアプローチを提供します。
はじめに、なぜ遅延束縛が魅力的なのか知るために、単純な例を見てみましょう。

次のコードは、整数もしくは (倍精度の) 浮動小数点数を表わすような型である、データ型 #stacode("intfloat") を宣言しています:

#sats2xhtml('\
//
datatype
intfloat = INT of int | FLOAT of double
//
')

型 #stacode("intfloat") の値を印字するために、次のような #dyncode("print_intfloat") を実装できます:

#dats2xhtml('\
//
fun
print_intfloat
  (x: intfloat): void =
(
case+ x of
| INT(int) => print_int(int)
| FLOAT(float) => print_double(float)
)
//
')

このとき、#dyncode("print_int") と #dyncode("print_double") は、それぞれ整数と (倍精度の) 浮動小数点数を印字する単相関数です。
整数と浮動小数点数を印字するにはもちろん数多くの方法があります。
けれども、#dyncode("print_intfloat") は唯一1つの印字方法しか使えません。
すなわち #dyncode("print_int") を通じて整数を表わし、#dyncode("print_double") を通じて浮動小数点数を表わすしかありません。
このような柔軟性の欠如を回避する方法の1つは、次のような高階関数 #dyncode("fprint_intfloat") を定義することです:

#dats2xhtml('\
//
fun
fprint_intfloat
(
  x: intfloat
, print_int: int -> void
, print_double: double -> void
) : void =
(
case+ x of
| INT(int) => print_int(int)
| FLOAT(float) => print_double(float)
)
//
')

#dyncode("fprint_intfloat") を用いると、後から #dyncode("print_int") と #dyncode("print_double") の実装を選択できます。
この点で、高階関数は遅延束縛の一種をサポートしていると言えます。
けれども、そのような高階関数の使用に問題がないわけではありません。
基本的に、#dyncode("print_int") を直接もしくは間接的に呼び出すどのような関数も、高階関数になる必要があります。
#dyncode("print_double") についても同様です。
#dyncode("print_int") や #dyncode("print_double")
のように扱う必要がある関数が増えた場合、高階関数を多様するこのプログラミングスタイルは極端に不恰好なものになりえます。

')#comment("para")
")

#langeng("
#para('\

Instead of using higher-order functions, we can rely on template functions
to support late-binding (of function calls). For example, the following
code implements a template function #dyncode("tprint_intfloat") for
printing values of the type #stacode("intfloat"):

#dats2xhtml('\
//
extern
fun{}
tprint_int(int): void
extern
fun{}
tprint_double(double): void
extern
fun{}
tprint_intfloat(intfloat): void
//
(* ****** ****** *)
//
implement
tprint_int<> (x) = print_int(x)
implement
tprint_double<> (x) = print_double(x)
//
(* ****** ****** *)
//
implement
tprint_intfloat<> (x) =
(
case+ x of
| INT(int) => tprint_int<> (int)
| FLOAT(float) => tprint_double<> (float)
)
//
')

Please note that the default implementations for #dyncode("tprint_int") and
#dyncode("tprint_double") are based on #dyncode("print_int") and #dyncode("print_double"),
respectively. As can be expected, the following code outputs two lines:

#dats2xhtml('\
//
val () = (
  tprint_intfloat<> (INT(0)); print_newline()
) (* end of [val] *)
//
val () = (
  tprint_intfloat<> (FLOAT(1.0)); print_newline()
) (* end of [val] *)
//
')

where the first line consists of the string "0" and the second one
the string "1.000000". The following code also outputs two lines:

#dats2xhtml('\
local
//
implement
tprint_int<> (x) = print! ("INT(", x, ")")
implement
tprint_double<> (x) = print! ("FLOAT(", x, ")")
//
in (* in-of-local *)
//
val () = (
  tprint_intfloat<> (INT(0)); print_newline()
) (* end of [val] *)
//
val () = (
  tprint_intfloat<> (FLOAT(1.0)); print_newline()
) (* end of [val] *)
//
end // end of [local]
')

where the first line consists of the string "INT(0)" and the second one the
string "FLOAT(1.000000)"). In the latter case, the calls to template instances
#dyncode("tprint_int&lt;&gt;") and #dyncode("tprint_double&lt;&gt;") are compiled
according to the implementations for #dyncode("tprint_int") and #dyncode("tprint_double")
given between the keywords #keycode("local") and #keycode("in").\

')#comment("para")
")
#langja("
#para('\

高階関数を使用する代わりに、テンプレート関数を使って (関数呼び出しの) 遅延束縛をサポートできます。
例えば、次のコードは型 #stacode("intfloat") の値を印字するテンプレート関数 #dyncode("tprint_intfloat") を実装しています:

#dats2xhtml('\
//
extern
fun{}
tprint_int(int): void
extern
fun{}
tprint_double(double): void
extern
fun{}
tprint_intfloat(intfloat): void
//
(* ****** ****** *)
//
implement
tprint_int<> (x) = print_int(x)
implement
tprint_double<> (x) = print_double(x)
//
(* ****** ****** *)
//
implement
tprint_intfloat<> (x) =
(
case+ x of
| INT(int) => tprint_int<> (int)
| FLOAT(float) => tprint_double<> (float)
)
//
')

#dyncode("tprint_int") と #dyncode("tprint_double") のデフォルト実装はそれぞれ
#dyncode("print_int") と #dyncode("print_double") であることに注意してください。
予想されることですが、次のコードは2行印字します:

#dats2xhtml('\
//
val () = (
  tprint_intfloat<> (INT(0)); print_newline()
) (* end of [val] *)
//
val () = (
  tprint_intfloat<> (FLOAT(1.0)); print_newline()
) (* end of [val] *)
//
')

このとき、出力される最初の行は文字列 "0" で、次の行は文字列 "1.000000" になります。
次のコードもまた2行印字します:

#dats2xhtml('\
local
//
implement
tprint_int<> (x) = print! ("INT(", x, ")")
implement
tprint_double<> (x) = print! ("FLOAT(", x, ")")
//
in (* in-of-local *)
//
val () = (
  tprint_intfloat<> (INT(0)); print_newline()
) (* end of [val] *)
//
val () = (
  tprint_intfloat<> (FLOAT(1.0)); print_newline()
) (* end of [val] *)
//
end // end of [local]
')

このとき、出力される最初の行は文字列 "INT(0)" で、次の行は文字列 "FLOAT(1.000000)" になります。
この後者のケースでは、テンプレートインスタンス #dyncode("tprint_int&lt;&gt;") と #dyncode("tprint_double&lt;&gt;")
の呼び出しは、キーワード #keycode("local") と #keycode("in") の間で与えられている
#dyncode("tprint_int") と #dyncode("tprint_double") の実装に従ってコンパイルされます。\

')#comment("para")
")

#langeng("
#para('\

Please find on-line the file
#mycodelink("CHAP_FNTMPINT/intfloat.dats", "intfloat.dats") containing the
entirety of the code presented in this section plus some testing code.\

')#comment("para")
")
#langja("
#para('\

この章で紹介したコード全体とテストコードを含む
#mycodelink("CHAP_FNTMPINT/intfloat.dats", "intfloat.dats")
ファイルはオンラインから入手できます。\

')#comment("para")
")

</sect1><!--id="template-based-support-for-late-binding"-->

<!-- ****** ****** -->

</chapter>
<!--id="from-genericity-to-late-binding"-->

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
