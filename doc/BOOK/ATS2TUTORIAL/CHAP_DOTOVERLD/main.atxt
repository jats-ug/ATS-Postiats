%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/ats2tutorial.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="dot-overload">
#langeng("
#title("Dot-Symbol Overloading")
")
#langja("
#title("ドット記号オーバーロード")
")

#langeng("
#para('\

In many programming languages, the so-called dot-notation is commonly
associated with selecting a field from a given tuple-value, record-value or
object-value.  In ATS, field selection can be done through either pattern
matching or the use of dot-notation. For example, the following code
constructs a flat tuple and also a boxed one, and then uses dot-notation to
select their components:

#dats2xhtml('\
//
val tup_flat = @("a", "b")
val tup_boxed = $tup("a", "b")
//
val-"a" = tup_flat.0 and "b" = tup_flat.1
val-"a" = tup_boxed.0 and "b" = tup_boxed.1
//
')

There is support in ATS for overloading a specified dot-symbol with
multiple function names so that dot-notation can be employed to call these
functions, resulting in code that reads like field selection from tuples or
records. This style of calling functions can, sometimes, make the code
written in ATS more easily accessible, and it is especially so when
ATS interacts with languages that support object-oriented programming.\

')
")
#langja("
#para('\

多くのプログラミング言語では、一般的にいわゆるドット表記は与えられたタプル値、レコード値、オブジェクト値のフィールドを選択するために使われます。ATS では、パターンマッチもしくはドット表記の使用によってフィールドを選択することができます。例えば、次のコードはフラットなタプルとボックス化タプルをコンストラクトしています。そして、それらの構成要素を選択するためにドット表記を使っています:

#dats2xhtml('\
//
val tup_flat = @("a", "b")
val tup_boxed = $tup("a", "b")
//
val-"a" = tup_flat.0 and "b" = tup_flat.1
val-"a" = tup_boxed.0 and "b" = tup_boxed.1
//
')

ATS では、ドット表記で複数の関数を呼び出すために、それらの関数名で特定のドット記号をオーバーロードすることができます。その結果、タプルやレコードのフィールド選択のようにコードがよめるようになります。このスタイルの関数呼び出しは、ときに、ATS で書かれたコードをより読み易いものにするでしょう。またそれは ATS とオブジェクト指向プログラミング言語を相互呼び出しする際に顕著です。\

')
")

#langeng("
#para('\

As an example of dot-notation in overloading, let us introduce a non-linear
abstract type #stacode("point") for points in a 2-dimensional space and also
declare some associated functions:

#dats2xhtml('\
//
abstype point = ptr // boxed
//
extern
fun
point_make
  (x: double, y: double): point
//
extern
fun point_get_x (p: point): double
and point_get_y (p: point): double
//
extern
fun point_set_x (p: point, x: double): void
and point_set_y (p: point, x: double): void
//
')

For getting the x-coordinate and y-coordinate of a given point, the
functions #dyncode("point_get_x") and #dyncode("point_get_y") can be
called, respectively.  For setting the x-coordinate and y-coordinate of a
given point, the functions #dyncode("point_set_x") and
#dyncode("point_set_y") can be called, respectively. By introducing two
dot-symbols #dyncode(".x") and #dyncode(".y") and then overloading them
with certain function names as follows:

#dats2xhtml('\
symintr .x .y
overload .x with point_get_x
overload .x with point_set_x
overload .y with point_get_y
overload .y with point_set_y
')

we can use dot-notation to call the corresponding get-functions and
set-functions as is shown in the following code:

#dats2xhtml('\
val p0 = point_make (1.0, ~1.0)
val x0 = p0.x() // point_get_x (p0)
and y0 = p0.y() // point_get_y (p0)
val () = p0.x := y0 // point_set_x (p0, y0)
and () = p0.y := x0 // point_set_y (p0, x0)
')

Note that writing #dyncode("p0.x") for #dyncode("p0.x()") is currently not
supported.  The dot-notation in any assigement is only allowed to refer to
a function that returns the void-value. In the above example, both
#dyncode("point_set_x") and #dyncode("point_set_y") return the void-value.

')
")
#langja("
#para('\

オーバーロードにおけるドット表記の例として、2次元空間の点を表わす非線形抽象型 #stacode("point") を導入し、さらに関連する関数群を宣言してみましょう:

#dats2xhtml('\
//
abstype point = ptr // boxed
//
extern
fun
point_make
  (x: double, y: double): point
//
extern
fun point_get_x (p: point): double
and point_get_y (p: point): double
//
extern
fun point_set_x (p: point, x: double): void
and point_set_y (p: point, x: double): void
//
')

関数 #dyncode("point_get_x") と #dyncode("point_get_y") を呼び出すことで、与えられた点の X 座標と Y 座標をそれぞれ得ることができます。関数 #dyncode("point_set_x") と #dyncode("point_set_y") を呼び出すことで、与えられた点の X 座標と Y 座標をそれぞれ設定できます。ドット記号 #dyncode(".x") と #dyncode(".y") を導入し、それらを次のような関数名でオーバーロードします:

#dats2xhtml('\
symintr .x .y
overload .x with point_get_x
overload .x with point_set_x
overload .y with point_get_y
overload .y with point_set_y
')

すると次のコードに示すように、対応する get 関数と set 関数の呼び出しにドット表記を使うことができます:

#dats2xhtml('\
val p0 = point_make (1.0, ~1.0)
val x0 = p0.x() // point_get_x (p0)
and y0 = p0.y() // point_get_y (p0)
val () = p0.x := y0 // point_set_x (p0, y0)
and () = p0.y := x0 // point_set_y (p0, x0)
')

代入におけるドット表記は void 値を返す関数のみ参照できることに注意してください。上記の例では、関数 #dyncode("point_set_x") と #dyncode("point_set_y") は両方とも void 値を返します。 また、上記で示したオーバーロードされたドット表記は非線形の値にのみ適用できることを強調しなければなりません。線形値を扱うためには、わずかな制限が要求されます。これは次に説明します。

')
")

#langeng("
#para("\

Let us introduce a linear abstract type #stacode("counter") for counter
objects and a few functions associated with it:

#dats2xhtml('\
//
absvtype counter = ptr
//
extern
fun counter_make (): counter
extern
fun counter_free (counter): void
//
extern
fun counter_get (cntr: !counter): int
extern
fun counter_incby (cntr: !counter, n: int): void
//
')

As can be expected, the functions #dyncode("counter_make") and
#dyncode("counter_free") are for creating and destroying a counter object,
respectively. The function #dyncode("counter_get") returns the current
count stored in a give counter, and the function #dyncode("counter_incby")
increase that count by a given integer value.

")#comment("para")
")
#langja("
#para("\

カウンタオブジェクトを表わす線形抽象型 #stacode("counter") と関連するいくつかの関数を導入しましょう:

#dats2xhtml('\
//
absvtype counter = ptr
//
extern
fun counter_make (): counter
extern
fun counter_free (counter): void
//
extern
fun counter_get (cntr: !counter): int
extern
fun counter_incby (cntr: !counter, n: int): void
//
')

予想されることですが、関数 #dyncode("counter_make") と #dyncode("counter_free") はカウンタオブジェクトの生成と破棄をそれぞれ表わします。関数 #dyncode("counter_get") は与えられたカウンタに保管されている現在のカウントを返し、関数 #dyncode("counter_incby") は与えられた整数値でそのカウントを増やします。

")#comment("para")
")

#langeng("
#para("\

Let us introduce the following overloading declarations:

#dats2xhtml('\
//
overload .get with counter_get
overload .incby with counter_incby
//
')

As is expected, one can now call #dyncode("counter_get") as follows:

#dats2xhtml('\
val n0 = c0.get() // = counter_get(c0)
')

Similarly, one can call #dyncode("counter_incby") as follows to increase
the count stored in #dyncode("c0") by 1:

#dats2xhtml('\
val () = c0.incby(1) // = counter_incby(c0, 1)
')

If we revisit the previous example involving (non-linear) points, then
we can see that the following code also typechecks:

#dats2xhtml('\
val p0 = point_make (1.0, ~1.0)
val x0 = p0.x() // point_get_x (p0)
and y0 = p0.y() // point_get_y (p0)
val () = p0.x(y0) // point_set_x (p0, y0)
and () = p0.y(x0) // point_set_y (p0, x0)
')

I may use the phrase #emphasis("functional dot-notation") to refer to
this form of dot-notation so as to differentiate it from the general form of
dot-notation.

")#comment("para")
")
#langja("
#para("\

次のようなオーバーロード宣言を導入したとしましょう:

#dats2xhtml('\
//
overload .get with counter_get
overload .incby with counter_incby
//
')

期待されたるように、これで次のように  #dyncode("counter_get") を呼び出すことができます:

#dats2xhtml('\
val n0 = c0.get() // = counter_get(c0)
')

同様に、#dyncode("c0") に保管されているカウンタを 1 増やすために、次のように #dyncode("counter_incby") を呼び出すことができます:

#dats2xhtml('\
val () = c0.incby(1) // = counter_incby(c0, 1)
')

もし (非線形の) point の例に戻るのであれば、次のコードもまた型検査に成功します:

#dats2xhtml('\
val p0 = point_make (1.0, ~1.0)
val x0 = p0.x() // point_get_x (p0)
and y0 = p0.y() // point_get_y (p0)
val () = p0.x(y0) // point_set_x (p0, y0)
and () = p0.y(x0) // point_set_y (p0, x0)
')

ドット表記の一般的な形式と区別するために、私はこの形式のドット表記を #emphasis("関数的なドット表記") と呼ぶことがあります。

")#comment("para")
")

#langeng("
#para("\

Please find #mycodelink("chap_dotoverld.dats", "on-line") the entirety of the
code presented in this chapter plus some testing code.\

")#comment("para")
")
#langja("
#para("\

この章で示したコード全体とテストコードは #mycodelink("chap_dotoverld.dats", "オンライン") から入手できます。\

")#comment("para")
")

</chapter><!--"dot-overload"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
